(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{90:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("\n// CONCATENATED MODULE: ./node_modules/linkifyjs/dist/linkify.es.js\n// THIS FILE IS AUTOMATICALLY GENERATED DO NOT EDIT DIRECTLY\n// See update-tlds.js for encoding/decoding format\n// https://data.iana.org/TLD/tlds-alpha-by-domain.txt\nconst encodedTlds = 'aaa1rp3barth4b0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0faromeo7ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4vianca6w0s2x0a2z0ure5ba0by2idu3namex3narepublic11d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2ntley5rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re2s2c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y0eats7k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0cast4mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking0channel11l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dabur3d1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t0isalat7u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0at2delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d0network8tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntdoor4ier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0ardian6cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5gtv3iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0eles2s3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6logistics9properties14fh2g1h1i0a1ds2m1nder2le4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3ncaster5ia3d0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4de2k2psy3ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0cys3drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7serati6ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic3tual5v1w1x1y1z2na0b1goya4me2tura4vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rthwesternmutual14on4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9dnavy5lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3ssagens7y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cher3ks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0a1b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp2w2ell3ia1ksha5oes2p0ping5uji3w0time7i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ffany5ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0channel7ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mögensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lkswagen7vo3te1ing3o2yage5u0elos6wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4finity6ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2';\n// Internationalized domain names containing non-ASCII\nconst encodedUtlds = 'ελ1υ2бг1ел3дети4ею2католик6ом3мкд2он1сква6онлайн5рг3рус2ф2сайт3рб3укр3қаз3հայ3ישראל5קום3ابوظبي5تصالات6رامكو5لاردن4بحرين5جزائر5سعودية6عليان5مغرب5مارات5یران5بارت2زار4يتك3ھارت5تونس4سودان3رية5شبكة4عراق2ب2مان4فلسطين6قطر3كاثوليك6وم3مصر2ليسيا5وريتانيا7قع4همراه5پاکستان7ڀارت4कॉम3नेट3भारत0म्3ोत5संगठन5বাংলা5ভারত2ৰত4ਭਾਰਤ4ભારત4ଭାରତ4இந்தியா6லங்கை6சிங்கப்பூர்11భారత్5ಭಾರತ4ഭാരതം5ලංකා4คอม3ไทย3ລາວ3გე2みんな3アマゾン4クラウド4グーグル4コム2ストア3セール3ファッション6ポイント4世界2中信1国1國1文网3亚马逊3企业2佛山2信息2健康2八卦2公司1益2台湾1灣2商城1店1标2嘉里0大酒店5在线2大拿2天主教3娱乐2家電2广东2微博2慈善2我爱你3手机2招聘2政务1府2新加坡2闻2时尚2書籍2机构2淡马锡3游戏2澳門2点看2移动2组织机构4网址1店1站1络2联通2谷歌2购物2通販2集团2電訊盈科4飞利浦3食品2餐厅2香格里拉3港2닷넷1컴2삼성2한국2';\n\n/**\n * @template A\n * @template B\n * @param {A} target\n * @param {B} properties\n * @return {A & B}\n */\nconst linkify_es_assign = (target, properties) => {\n  for (const key in properties) {\n    target[key] = properties[key];\n  }\n  return target;\n};\n\n/**\n * Finite State Machine generation utilities\n */\n\n/**\n * @template T\n * @typedef {{ [group: string]: T[] }} Collections\n */\n\n/**\n * @typedef {{ [group: string]: true }} Flags\n */\n\n// Keys in scanner Collections instances\nconst numeric = 'numeric';\nconst ascii = 'ascii';\nconst alpha = 'alpha';\nconst asciinumeric = 'asciinumeric';\nconst alphanumeric = 'alphanumeric';\nconst domain = 'domain';\nconst emoji = 'emoji';\nconst scheme = 'scheme';\nconst slashscheme = 'slashscheme';\nconst whitespace = 'whitespace';\n\n/**\n * @template T\n * @param {string} name\n * @param {Collections<T>} groups to register in\n * @returns {T[]} Current list of tokens in the given collection\n */\nfunction registerGroup(name, groups) {\n  if (!(name in groups)) {\n    groups[name] = [];\n  }\n  return groups[name];\n}\n\n/**\n * @template T\n * @param {T} t token to add\n * @param {Collections<T>} groups\n * @param {Flags} flags\n */\nfunction addToGroups(t, flags, groups) {\n  if (flags[numeric]) {\n    flags[asciinumeric] = true;\n    flags[alphanumeric] = true;\n  }\n  if (flags[ascii]) {\n    flags[asciinumeric] = true;\n    flags[alpha] = true;\n  }\n  if (flags[asciinumeric]) {\n    flags[alphanumeric] = true;\n  }\n  if (flags[alpha]) {\n    flags[alphanumeric] = true;\n  }\n  if (flags[alphanumeric]) {\n    flags[domain] = true;\n  }\n  if (flags[emoji]) {\n    flags[domain] = true;\n  }\n  for (const k in flags) {\n    const group = registerGroup(k, groups);\n    if (group.indexOf(t) < 0) {\n      group.push(t);\n    }\n  }\n}\n\n/**\n * @template T\n * @param {T} t token to check\n * @param {Collections<T>} groups\n * @returns {Flags} group flags that contain this token\n */\nfunction flagsForToken(t, groups) {\n  const result = {};\n  for (const c in groups) {\n    if (groups[c].indexOf(t) >= 0) {\n      result[c] = true;\n    }\n  }\n  return result;\n}\n\n/**\n * @template T\n * @typedef {null | T } Transition\n */\n\n/**\n * Define a basic state machine state. j is the list of character transitions,\n * jr is the list of regex-match transitions, jd is the default state to\n * transition to t is the accepting token type, if any. If this is the terminal\n * state, then it does not emit a token.\n *\n * The template type T represents the type of the token this state accepts. This\n * should be a string (such as of the token exports in `text.js`) or a\n * MultiToken subclass (from `multi.js`)\n *\n * @template T\n * @param {T} [token] Token that this state emits\n */\nfunction State(token) {\n  if (token === void 0) {\n    token = null;\n  }\n  // this.n = null; // DEBUG: State name\n  /** @type {{ [input: string]: State<T> }} j */\n  this.j = {}; // IMPLEMENTATION 1\n  // this.j = []; // IMPLEMENTATION 2\n  /** @type {[RegExp, State<T>][]} jr */\n  this.jr = [];\n  /** @type {?State<T>} jd */\n  this.jd = null;\n  /** @type {?T} t */\n  this.t = token;\n}\n\n/**\n * Scanner token groups\n * @type Collections<string>\n */\nState.groups = {};\nState.prototype = {\n  accepts() {\n    return !!this.t;\n  },\n  /**\n   * Follow an existing transition from the given input to the next state.\n   * Does not mutate.\n   * @param {string} input character or token type to transition on\n   * @returns {?State<T>} the next state, if any\n   */\n  go(input) {\n    const state = this;\n    const nextState = state.j[input];\n    if (nextState) {\n      return nextState;\n    }\n    for (let i = 0; i < state.jr.length; i++) {\n      const regex = state.jr[i][0];\n      const nextState = state.jr[i][1]; // note: might be empty to prevent default jump\n      if (nextState && regex.test(input)) {\n        return nextState;\n      }\n    }\n    // Nowhere left to jump! Return default, if any\n    return state.jd;\n  },\n  /**\n   * Whether the state has a transition for the given input. Set the second\n   * argument to true to only look for an exact match (and not a default or\n   * regular-expression-based transition)\n   * @param {string} input\n   * @param {boolean} exactOnly\n   */\n  has(input, exactOnly) {\n    if (exactOnly === void 0) {\n      exactOnly = false;\n    }\n    return exactOnly ? input in this.j : !!this.go(input);\n  },\n  /**\n   * Short for \"transition all\"; create a transition from the array of items\n   * in the given list to the same final resulting state.\n   * @param {string | string[]} inputs Group of inputs to transition on\n   * @param {Transition<T> | State<T>} [next] Transition options\n   * @param {Flags} [flags] Collections flags to add token to\n   * @param {Collections<T>} [groups] Master list of token groups\n   */\n  ta(inputs, next, flags, groups) {\n    for (let i = 0; i < inputs.length; i++) {\n      this.tt(inputs[i], next, flags, groups);\n    }\n  },\n  /**\n   * Short for \"take regexp transition\"; defines a transition for this state\n   * when it encounters a token which matches the given regular expression\n   * @param {RegExp} regexp Regular expression transition (populate first)\n   * @param {T | State<T>} [next] Transition options\n   * @param {Flags} [flags] Collections flags to add token to\n   * @param {Collections<T>} [groups] Master list of token groups\n   * @returns {State<T>} taken after the given input\n   */\n  tr(regexp, next, flags, groups) {\n    groups = groups || State.groups;\n    let nextState;\n    if (next && next.j) {\n      nextState = next;\n    } else {\n      // Token with maybe token groups\n      nextState = new State(next);\n      if (flags && groups) {\n        addToGroups(next, flags, groups);\n      }\n    }\n    this.jr.push([regexp, nextState]);\n    return nextState;\n  },\n  /**\n   * Short for \"take transitions\", will take as many sequential transitions as\n   * the length of the given input and returns the\n   * resulting final state.\n   * @param {string | string[]} input\n   * @param {T | State<T>} [next] Transition options\n   * @param {Flags} [flags] Collections flags to add token to\n   * @param {Collections<T>} [groups] Master list of token groups\n   * @returns {State<T>} taken after the given input\n   */\n  ts(input, next, flags, groups) {\n    let state = this;\n    const len = input.length;\n    if (!len) {\n      return state;\n    }\n    for (let i = 0; i < len - 1; i++) {\n      state = state.tt(input[i]);\n    }\n    return state.tt(input[len - 1], next, flags, groups);\n  },\n  /**\n   * Short for \"take transition\", this is a method for building/working with\n   * state machines.\n   *\n   * If a state already exists for the given input, returns it.\n   *\n   * If a token is specified, that state will emit that token when reached by\n   * the linkify engine.\n   *\n   * If no state exists, it will be initialized with some default transitions\n   * that resemble existing default transitions.\n   *\n   * If a state is given for the second argument, that state will be\n   * transitioned to on the given input regardless of what that input\n   * previously did.\n   *\n   * Specify a token group flags to define groups that this token belongs to.\n   * The token will be added to corresponding entires in the given groups\n   * object.\n   *\n   * @param {string} input character, token type to transition on\n   * @param {T | State<T>} [next] Transition options\n   * @param {Flags} [flags] Collections flags to add token to\n   * @param {Collections<T>} [groups] Master list of groups\n   * @returns {State<T>} taken after the given input\n   */\n  tt(input, next, flags, groups) {\n    groups = groups || State.groups;\n    const state = this;\n\n    // Check if existing state given, just a basic transition\n    if (next && next.j) {\n      state.j[input] = next;\n      return next;\n    }\n    const t = next;\n\n    // Take the transition with the usual default mechanisms and use that as\n    // a template for creating the next state\n    let nextState,\n      templateState = state.go(input);\n    if (templateState) {\n      nextState = new State();\n      linkify_es_assign(nextState.j, templateState.j);\n      nextState.jr.push.apply(nextState.jr, templateState.jr);\n      nextState.jd = templateState.jd;\n      nextState.t = templateState.t;\n    } else {\n      nextState = new State();\n    }\n    if (t) {\n      // Ensure newly token is in the same groups as the old token\n      if (groups) {\n        if (nextState.t && typeof nextState.t === 'string') {\n          const allFlags = linkify_es_assign(flagsForToken(nextState.t, groups), flags);\n          addToGroups(t, allFlags, groups);\n        } else if (flags) {\n          addToGroups(t, flags, groups);\n        }\n      }\n      nextState.t = t; // overwrite anything that was previously there\n    }\n\n    state.j[input] = nextState;\n    return nextState;\n  }\n};\n\n// Helper functions to improve minification (not exported outside linkifyjs module)\n\n/**\n * @template T\n * @param {State<T>} state\n * @param {string | string[]} input\n * @param {Flags} [flags]\n * @param {Collections<T>} [groups]\n */\nconst ta = (state, input, next, flags, groups) => state.ta(input, next, flags, groups);\n\n/**\n * @template T\n * @param {State<T>} state\n * @param {RegExp} regexp\n * @param {T | State<T>} [next]\n * @param {Flags} [flags]\n * @param {Collections<T>} [groups]\n */\nconst tr = (state, regexp, next, flags, groups) => state.tr(regexp, next, flags, groups);\n\n/**\n * @template T\n * @param {State<T>} state\n * @param {string | string[]} input\n * @param {T | State<T>} [next]\n * @param {Flags} [flags]\n * @param {Collections<T>} [groups]\n */\nconst ts = (state, input, next, flags, groups) => state.ts(input, next, flags, groups);\n\n/**\n * @template T\n * @param {State<T>} state\n * @param {string} input\n * @param {T | State<T>} [next]\n * @param {Collections<T>} [groups]\n * @param {Flags} [flags]\n */\nconst tt = (state, input, next, flags, groups) => state.tt(input, next, flags, groups);\n\n/******************************************************************************\nText Tokens\nIdentifiers for token outputs from the regexp scanner\n******************************************************************************/\n\n// A valid web domain token\nconst WORD = 'WORD'; // only contains a-z\nconst UWORD = 'UWORD'; // contains letters other than a-z, used for IDN\n\n// Special case of word\nconst LOCALHOST = 'LOCALHOST';\n\n// Valid top-level domain, special case of WORD (see tlds.js)\nconst TLD = 'TLD';\n\n// Valid IDN TLD, special case of UWORD (see tlds.js)\nconst UTLD = 'UTLD';\n\n// The scheme portion of a web URI protocol. Supported types include: `mailto`,\n// `file`, and user-defined custom protocols. Limited to schemes that contain\n// only letters\nconst SCHEME = 'SCHEME';\n\n// Similar to SCHEME, except makes distinction for schemes that must always be\n// followed by `://`, not just `:`. Supported types include `http`, `https`,\n// `ftp`, `ftps`\nconst SLASH_SCHEME = 'SLASH_SCHEME';\n\n// Any sequence of digits 0-9\nconst NUM = 'NUM';\n\n// Any number of consecutive whitespace characters that are not newline\nconst WS = 'WS';\n\n// New line (unix style)\nconst NL$1 = 'NL'; // \\n\n\n// Opening/closing bracket classes\nconst OPENBRACE = 'OPENBRACE'; // {\nconst OPENBRACKET = 'OPENBRACKET'; // [\nconst OPENANGLEBRACKET = 'OPENANGLEBRACKET'; // <\nconst OPENPAREN = 'OPENPAREN'; // (\nconst CLOSEBRACE = 'CLOSEBRACE'; // }\nconst CLOSEBRACKET = 'CLOSEBRACKET'; // ]\nconst CLOSEANGLEBRACKET = 'CLOSEANGLEBRACKET'; // >\nconst CLOSEPAREN = 'CLOSEPAREN'; // )\n\n// Various symbols\nconst AMPERSAND = 'AMPERSAND'; // &\nconst APOSTROPHE = 'APOSTROPHE'; // '\nconst ASTERISK = 'ASTERISK'; // *\nconst AT = 'AT'; // @\nconst BACKSLASH = 'BACKSLASH'; // \\\nconst BACKTICK = 'BACKTICK'; // `\nconst CARET = 'CARET'; // ^\nconst COLON = 'COLON'; // :\nconst COMMA = 'COMMA'; // ,\nconst DOLLAR = 'DOLLAR'; // $\nconst DOT = 'DOT'; // .\nconst EQUALS = 'EQUALS'; // =\nconst EXCLAMATION = 'EXCLAMATION'; // !\nconst HYPHEN = 'HYPHEN'; // -\nconst PERCENT = 'PERCENT'; // %\nconst PIPE = 'PIPE'; // |\nconst PLUS = 'PLUS'; // +\nconst POUND = 'POUND'; // #\nconst QUERY = 'QUERY'; // ?\nconst QUOTE = 'QUOTE'; // \"\n\nconst SEMI = 'SEMI'; // ;\nconst SLASH = 'SLASH'; // /\nconst TILDE = 'TILDE'; // ~\nconst UNDERSCORE = 'UNDERSCORE'; // _\n\n// Emoji symbol\nconst EMOJI$1 = 'EMOJI';\n\n// Default token - anything that is not one of the above\nconst SYM = 'SYM';\n\nvar tk = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tWORD: WORD,\n\tUWORD: UWORD,\n\tLOCALHOST: LOCALHOST,\n\tTLD: TLD,\n\tUTLD: UTLD,\n\tSCHEME: SCHEME,\n\tSLASH_SCHEME: SLASH_SCHEME,\n\tNUM: NUM,\n\tWS: WS,\n\tNL: NL$1,\n\tOPENBRACE: OPENBRACE,\n\tOPENBRACKET: OPENBRACKET,\n\tOPENANGLEBRACKET: OPENANGLEBRACKET,\n\tOPENPAREN: OPENPAREN,\n\tCLOSEBRACE: CLOSEBRACE,\n\tCLOSEBRACKET: CLOSEBRACKET,\n\tCLOSEANGLEBRACKET: CLOSEANGLEBRACKET,\n\tCLOSEPAREN: CLOSEPAREN,\n\tAMPERSAND: AMPERSAND,\n\tAPOSTROPHE: APOSTROPHE,\n\tASTERISK: ASTERISK,\n\tAT: AT,\n\tBACKSLASH: BACKSLASH,\n\tBACKTICK: BACKTICK,\n\tCARET: CARET,\n\tCOLON: COLON,\n\tCOMMA: COMMA,\n\tDOLLAR: DOLLAR,\n\tDOT: DOT,\n\tEQUALS: EQUALS,\n\tEXCLAMATION: EXCLAMATION,\n\tHYPHEN: HYPHEN,\n\tPERCENT: PERCENT,\n\tPIPE: PIPE,\n\tPLUS: PLUS,\n\tPOUND: POUND,\n\tQUERY: QUERY,\n\tQUOTE: QUOTE,\n\tSEMI: SEMI,\n\tSLASH: SLASH,\n\tTILDE: TILDE,\n\tUNDERSCORE: UNDERSCORE,\n\tEMOJI: EMOJI$1,\n\tSYM: SYM\n});\n\n// Note that these two Unicode ones expand into a really big one with Babel\nconst ASCII_LETTER = /[a-z]/;\nconst LETTER = /\\p{L}/u; // Any Unicode character with letter data type\nconst EMOJI = /\\p{Emoji}/u; // Any Unicode emoji character\nconst EMOJI_VARIATION$1 = /\\ufe0f/;\nconst DIGIT = /\\d/;\nconst SPACE = /\\s/;\n\nvar regexp = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tASCII_LETTER: ASCII_LETTER,\n\tLETTER: LETTER,\n\tEMOJI: EMOJI,\n\tEMOJI_VARIATION: EMOJI_VARIATION$1,\n\tDIGIT: DIGIT,\n\tSPACE: SPACE\n});\n\n/**\n\tThe scanner provides an interface that takes a string of text as input, and\n\toutputs an array of tokens instances that can be used for easy URL parsing.\n*/\nconst NL = '\\n'; // New line character\nconst EMOJI_VARIATION = '\\ufe0f'; // Variation selector, follows heart and others\nconst EMOJI_JOINER = '\\u200d'; // zero-width joiner\n\nlet tlds = null,\n  utlds = null; // don't change so only have to be computed once\n\n/**\n * Scanner output token:\n * - `t` is the token name (e.g., 'NUM', 'EMOJI', 'TLD')\n * - `v` is the value of the token (e.g., '123', '❤️', 'com')\n * - `s` is the start index of the token in the original string\n * - `e` is the end index of the token in the original string\n * @typedef {{t: string, v: string, s: number, e: number}} Token\n */\n\n/**\n * @template T\n * @typedef {{ [collection: string]: T[] }} Collections\n */\n\n/**\n * Initialize the scanner character-based state machine for the given start\n * state\n * @param {[string, boolean][]} customSchemes List of custom schemes, where each\n * item is a length-2 tuple with the first element set to the string scheme, and\n * the second element set to `true` if the `://` after the scheme is optional\n */\nfunction init$2(customSchemes) {\n  if (customSchemes === void 0) {\n    customSchemes = [];\n  }\n  // Frequently used states (name argument removed during minification)\n  /** @type Collections<string> */\n  const groups = {}; // of tokens\n  State.groups = groups;\n  /** @type State<string> */\n  const Start = new State();\n  if (tlds == null) {\n    tlds = decodeTlds(encodedTlds);\n  }\n  if (utlds == null) {\n    utlds = decodeTlds(encodedUtlds);\n  }\n\n  // States for special URL symbols that accept immediately after start\n  tt(Start, \"'\", APOSTROPHE);\n  tt(Start, '{', OPENBRACE);\n  tt(Start, '[', OPENBRACKET);\n  tt(Start, '<', OPENANGLEBRACKET);\n  tt(Start, '(', OPENPAREN);\n  tt(Start, '}', CLOSEBRACE);\n  tt(Start, ']', CLOSEBRACKET);\n  tt(Start, '>', CLOSEANGLEBRACKET);\n  tt(Start, ')', CLOSEPAREN);\n  tt(Start, '&', AMPERSAND);\n  tt(Start, '*', ASTERISK);\n  tt(Start, '@', AT);\n  tt(Start, '`', BACKTICK);\n  tt(Start, '^', CARET);\n  tt(Start, ':', COLON);\n  tt(Start, ',', COMMA);\n  tt(Start, '$', DOLLAR);\n  tt(Start, '.', DOT);\n  tt(Start, '=', EQUALS);\n  tt(Start, '!', EXCLAMATION);\n  tt(Start, '-', HYPHEN);\n  tt(Start, '%', PERCENT);\n  tt(Start, '|', PIPE);\n  tt(Start, '+', PLUS);\n  tt(Start, '#', POUND);\n  tt(Start, '?', QUERY);\n  tt(Start, '\"', QUOTE);\n  tt(Start, '/', SLASH);\n  tt(Start, ';', SEMI);\n  tt(Start, '~', TILDE);\n  tt(Start, '_', UNDERSCORE);\n  tt(Start, '\\\\', BACKSLASH);\n  const Num = tr(Start, DIGIT, NUM, {\n    [numeric]: true\n  });\n  tr(Num, DIGIT, Num);\n\n  // State which emits a word token\n  const Word = tr(Start, ASCII_LETTER, WORD, {\n    [ascii]: true\n  });\n  tr(Word, ASCII_LETTER, Word);\n\n  // Same as previous, but specific to non-fsm.ascii alphabet words\n  const UWord = tr(Start, LETTER, UWORD, {\n    [alpha]: true\n  });\n  tr(UWord, ASCII_LETTER); // Non-accepting\n  tr(UWord, LETTER, UWord);\n\n  // Whitespace jumps\n  // Tokens of only non-newline whitespace are arbitrarily long\n  // If any whitespace except newline, more whitespace!\n  const Ws = tr(Start, SPACE, WS, {\n    [whitespace]: true\n  });\n  tt(Start, NL, NL$1, {\n    [whitespace]: true\n  });\n  tt(Ws, NL); // non-accepting state to avoid mixing whitespaces\n  tr(Ws, SPACE, Ws);\n\n  // Emoji tokens. They are not grouped by the scanner except in cases where a\n  // zero-width joiner is present\n  const Emoji = tr(Start, EMOJI, EMOJI$1, {\n    [emoji]: true\n  });\n  tr(Emoji, EMOJI, Emoji);\n  tt(Emoji, EMOJI_VARIATION, Emoji);\n  // tt(Start, EMOJI_VARIATION, Emoji); // This one is sketchy\n\n  const EmojiJoiner = tt(Emoji, EMOJI_JOINER);\n  tr(EmojiJoiner, EMOJI, Emoji);\n  // tt(EmojiJoiner, EMOJI_VARIATION, Emoji); // also sketchy\n\n  // Generates states for top-level domains\n  // Note that this is most accurate when tlds are in alphabetical order\n  const wordjr = [[ASCII_LETTER, Word]];\n  const uwordjr = [[ASCII_LETTER, null], [LETTER, UWord]];\n  for (let i = 0; i < tlds.length; i++) {\n    fastts(Start, tlds[i], TLD, WORD, wordjr);\n  }\n  for (let i = 0; i < utlds.length; i++) {\n    fastts(Start, utlds[i], UTLD, UWORD, uwordjr);\n  }\n  addToGroups(TLD, {\n    tld: true,\n    ascii: true\n  }, groups);\n  addToGroups(UTLD, {\n    utld: true,\n    alpha: true\n  }, groups);\n\n  // Collect the states generated by different protocols. NOTE: If any new TLDs\n  // get added that are also protocols, set the token to be the same as the\n  // protocol to ensure parsing works as expected.\n  fastts(Start, 'file', SCHEME, WORD, wordjr);\n  fastts(Start, 'mailto', SCHEME, WORD, wordjr);\n  fastts(Start, 'http', SLASH_SCHEME, WORD, wordjr);\n  fastts(Start, 'https', SLASH_SCHEME, WORD, wordjr);\n  fastts(Start, 'ftp', SLASH_SCHEME, WORD, wordjr);\n  fastts(Start, 'ftps', SLASH_SCHEME, WORD, wordjr);\n  addToGroups(SCHEME, {\n    scheme: true,\n    ascii: true\n  }, groups);\n  addToGroups(SLASH_SCHEME, {\n    slashscheme: true,\n    ascii: true\n  }, groups);\n\n  // Register custom schemes. Assumes each scheme is asciinumeric with hyphens\n  customSchemes = customSchemes.sort((a, b) => a[0] > b[0] ? 1 : -1);\n  for (let i = 0; i < customSchemes.length; i++) {\n    const sch = customSchemes[i][0];\n    const optionalSlashSlash = customSchemes[i][1];\n    const flags = optionalSlashSlash ? {\n      [scheme]: true\n    } : {\n      [slashscheme]: true\n    };\n    if (sch.indexOf('-') >= 0) {\n      flags[domain] = true;\n    } else if (!ASCII_LETTER.test(sch)) {\n      flags[numeric] = true; // numbers only\n    } else if (DIGIT.test(sch)) {\n      flags[asciinumeric] = true;\n    } else {\n      flags[ascii] = true;\n    }\n    ts(Start, sch, sch, flags);\n  }\n\n  // Localhost token\n  ts(Start, 'localhost', LOCALHOST, {\n    ascii: true\n  });\n\n  // Set default transition for start state (some symbol)\n  Start.jd = new State(SYM);\n  return {\n    start: Start,\n    tokens: linkify_es_assign({\n      groups\n    }, tk)\n  };\n}\n\n/**\n\tGiven a string, returns an array of TOKEN instances representing the\n\tcomposition of that string.\n\n\t@method run\n\t@param {State<string>} start scanner starting state\n\t@param {string} str input string to scan\n\t@return {Token[]} list of tokens, each with a type and value\n*/\nfunction run$1(start, str) {\n  // State machine is not case sensitive, so input is tokenized in lowercased\n  // form (still returns regular case). Uses selective `toLowerCase` because\n  // lowercasing the entire string causes the length and character position to\n  // vary in some non-English strings with V8-based runtimes.\n  const iterable = stringToArray(str.replace(/[A-Z]/g, c => c.toLowerCase()));\n  const charCount = iterable.length; // <= len if there are emojis, etc\n  const tokens = []; // return value\n\n  // cursor through the string itself, accounting for characters that have\n  // width with length 2 such as emojis\n  let cursor = 0;\n\n  // Cursor through the array-representation of the string\n  let charCursor = 0;\n\n  // Tokenize the string\n  while (charCursor < charCount) {\n    let state = start;\n    let nextState = null;\n    let tokenLength = 0;\n    let latestAccepting = null;\n    let sinceAccepts = -1;\n    let charsSinceAccepts = -1;\n    while (charCursor < charCount && (nextState = state.go(iterable[charCursor]))) {\n      state = nextState;\n\n      // Keep track of the latest accepting state\n      if (state.accepts()) {\n        sinceAccepts = 0;\n        charsSinceAccepts = 0;\n        latestAccepting = state;\n      } else if (sinceAccepts >= 0) {\n        sinceAccepts += iterable[charCursor].length;\n        charsSinceAccepts++;\n      }\n      tokenLength += iterable[charCursor].length;\n      cursor += iterable[charCursor].length;\n      charCursor++;\n    }\n\n    // Roll back to the latest accepting state\n    cursor -= sinceAccepts;\n    charCursor -= charsSinceAccepts;\n    tokenLength -= sinceAccepts;\n\n    // No more jumps, just make a new token from the last accepting one\n    tokens.push({\n      t: latestAccepting.t,\n      // token type/name\n      v: str.slice(cursor - tokenLength, cursor),\n      // string value\n      s: cursor - tokenLength,\n      // start index\n      e: cursor // end index (excluding)\n    });\n  }\n\n  return tokens;\n}\n\n/**\n * Convert a String to an Array of characters, taking into account that some\n * characters like emojis take up two string indexes.\n *\n * Adapted from core-js (MIT license)\n * https://github.com/zloirock/core-js/blob/2d69cf5f99ab3ea3463c395df81e5a15b68f49d9/packages/core-js/internals/string-multibyte.js\n *\n * @function stringToArray\n * @param {string} str\n * @returns {string[]}\n */\nfunction stringToArray(str) {\n  const result = [];\n  const len = str.length;\n  let index = 0;\n  while (index < len) {\n    let first = str.charCodeAt(index);\n    let second;\n    let char = first < 0xd800 || first > 0xdbff || index + 1 === len || (second = str.charCodeAt(index + 1)) < 0xdc00 || second > 0xdfff ? str[index] // single character\n    : str.slice(index, index + 2); // two-index characters\n    result.push(char);\n    index += char.length;\n  }\n  return result;\n}\n\n/**\n * Fast version of ts function for when transition defaults are well known\n * @param {State<string>} state\n * @param {string} input\n * @param {string} t\n * @param {string} defaultt\n * @param {[RegExp, State<string>][]} jr\n * @returns {State<string>}\n */\nfunction fastts(state, input, t, defaultt, jr) {\n  let next;\n  const len = input.length;\n  for (let i = 0; i < len - 1; i++) {\n    const char = input[i];\n    if (state.j[char]) {\n      next = state.j[char];\n    } else {\n      next = new State(defaultt);\n      next.jr = jr.slice();\n      state.j[char] = next;\n    }\n    state = next;\n  }\n  next = new State(t);\n  next.jr = jr.slice();\n  state.j[input[len - 1]] = next;\n  return next;\n}\n\n/**\n * Converts a string of Top-Level Domain names encoded in update-tlds.js back\n * into a list of strings.\n * @param {str} encoded encoded TLDs string\n * @returns {str[]} original TLDs list\n */\nfunction decodeTlds(encoded) {\n  const words = [];\n  const stack = [];\n  let i = 0;\n  let digits = '0123456789';\n  while (i < encoded.length) {\n    let popDigitCount = 0;\n    while (digits.indexOf(encoded[i + popDigitCount]) >= 0) {\n      popDigitCount++; // encountered some digits, have to pop to go one level up trie\n    }\n\n    if (popDigitCount > 0) {\n      words.push(stack.join('')); // whatever preceded the pop digits must be a word\n      for (let popCount = parseInt(encoded.substring(i, i + popDigitCount), 10); popCount > 0; popCount--) {\n        stack.pop();\n      }\n      i += popDigitCount;\n    } else {\n      stack.push(encoded[i]); // drop down a level into the trie\n      i++;\n    }\n  }\n  return words;\n}\n\n/**\n * An object where each key is a valid DOM Event Name such as `click` or `focus`\n * and each value is an event handler function.\n *\n * https://developer.mozilla.org/en-US/docs/Web/API/Element#events\n * @typedef {?{ [event: string]: Function }} EventListeners\n */\n\n/**\n * All formatted properties required to render a link, including `tagName`,\n * `attributes`, `content` and `eventListeners`.\n * @typedef {{ tagName: any, attributes: {[attr: string]: any}, content: string,\n * eventListeners: EventListeners }} IntermediateRepresentation\n */\n\n/**\n * Specify either an object described by the template type `O` or a function.\n *\n * The function takes a string value (usually the link's href attribute), the\n * link type (`'url'`, `'hashtag`', etc.) and an internal token representation\n * of the link. It should return an object of the template type `O`\n * @template O\n * @typedef {O | ((value: string, type: string, token: MultiToken) => O)} OptObj\n */\n\n/**\n * Specify either a function described by template type `F` or an object.\n *\n * Each key in the object should be a link type (`'url'`, `'hashtag`', etc.). Each\n * value should be a function with template type `F` that is called when the\n * corresponding link type is encountered.\n * @template F\n * @typedef {F | { [type: string]: F}} OptFn\n */\n\n/**\n * Specify either a value with template type `V`, a function that returns `V` or\n * an object where each value resolves to `V`.\n *\n * The function takes a string value (usually the link's href attribute), the\n * link type (`'url'`, `'hashtag`', etc.) and an internal token representation\n * of the link. It should return an object of the template type `V`\n *\n * For the object, each key should be a link type (`'url'`, `'hashtag`', etc.).\n * Each value should either have type `V` or a function that returns V. This\n * function similarly takes a string value and a token.\n *\n * Example valid types for `Opt<string>`:\n *\n * ```js\n * 'hello'\n * (value, type, token) => 'world'\n * { url: 'hello', email: (value, token) => 'world'}\n * ```\n * @template V\n * @typedef {V | ((value: string, type: string, token: MultiToken) => V) | { [type: string]: V | ((value: string, token: MultiToken) => V) }} Opt\n */\n\n/**\n * See available options: https://linkify.js.org/docs/options.html\n * @typedef {{\n * \tdefaultProtocol?: string,\n *  events?: OptObj<EventListeners>,\n * \tformat?: Opt<string>,\n * \tformatHref?: Opt<string>,\n * \tnl2br?: boolean,\n * \ttagName?: Opt<any>,\n * \ttarget?: Opt<string>,\n * \trel?: Opt<string>,\n * \tvalidate?: Opt<boolean>,\n * \ttruncate?: Opt<number>,\n * \tclassName?: Opt<string>,\n * \tattributes?: OptObj<({ [attr: string]: any })>,\n *  ignoreTags?: string[],\n * \trender?: OptFn<((ir: IntermediateRepresentation) => any)>\n * }} Opts\n */\n\n/**\n * @type Required<Opts>\n */\nconst defaults = {\n  defaultProtocol: 'http',\n  events: null,\n  format: noop,\n  formatHref: noop,\n  nl2br: false,\n  tagName: 'a',\n  target: null,\n  rel: null,\n  validate: true,\n  truncate: Infinity,\n  className: null,\n  attributes: null,\n  ignoreTags: [],\n  render: null\n};\n\n/**\n * Utility class for linkify interfaces to apply specified\n * {@link Opts formatting and rendering options}.\n *\n * @param {Opts | Options} [opts] Option value overrides.\n * @param {(ir: IntermediateRepresentation) => any} [defaultRender] (For\n *   internal use) default render function that determines how to generate an\n *   HTML element based on a link token's derived tagName, attributes and HTML.\n *   Similar to render option\n */\nfunction Options(opts, defaultRender) {\n  if (defaultRender === void 0) {\n    defaultRender = null;\n  }\n  let o = linkify_es_assign({}, defaults);\n  if (opts) {\n    o = linkify_es_assign(o, opts instanceof Options ? opts.o : opts);\n  }\n\n  // Ensure all ignored tags are uppercase\n  const ignoredTags = o.ignoreTags;\n  const uppercaseIgnoredTags = [];\n  for (let i = 0; i < ignoredTags.length; i++) {\n    uppercaseIgnoredTags.push(ignoredTags[i].toUpperCase());\n  }\n  /** @protected */\n  this.o = o;\n  if (defaultRender) {\n    this.defaultRender = defaultRender;\n  }\n  this.ignoreTags = uppercaseIgnoredTags;\n}\nOptions.prototype = {\n  o: defaults,\n  /**\n   * @type string[]\n   */\n  ignoreTags: [],\n  /**\n   * @param {IntermediateRepresentation} ir\n   * @returns {any}\n   */\n  defaultRender(ir) {\n    return ir;\n  },\n  /**\n   * Returns true or false based on whether a token should be displayed as a\n   * link based on the user options.\n   * @param {MultiToken} token\n   * @returns {boolean}\n   */\n  check(token) {\n    return this.get('validate', token.toString(), token);\n  },\n  // Private methods\n\n  /**\n   * Resolve an option's value based on the value of the option and the given\n   * params. If operator and token are specified and the target option is\n   * callable, automatically calls the function with the given argument.\n   * @template {keyof Opts} K\n   * @param {K} key Name of option to use\n   * @param {string} [operator] will be passed to the target option if it's a\n   * function. If not specified, RAW function value gets returned\n   * @param {MultiToken} [token] The token from linkify.tokenize\n   * @returns {Opts[K] | any}\n   */\n  get(key, operator, token) {\n    const isCallable = operator != null;\n    let option = this.o[key];\n    if (!option) {\n      return option;\n    }\n    if (typeof option === 'object') {\n      option = token.t in option ? option[token.t] : defaults[key];\n      if (typeof option === 'function' && isCallable) {\n        option = option(operator, token);\n      }\n    } else if (typeof option === 'function' && isCallable) {\n      option = option(operator, token.t, token);\n    }\n    return option;\n  },\n  /**\n   * @template {keyof Opts} L\n   * @param {L} key Name of options object to use\n   * @param {string} [operator]\n   * @param {MultiToken} [token]\n   * @returns {Opts[L] | any}\n   */\n  getObj(key, operator, token) {\n    let obj = this.o[key];\n    if (typeof obj === 'function' && operator != null) {\n      obj = obj(operator, token.t, token);\n    }\n    return obj;\n  },\n  /**\n   * Convert the given token to a rendered element that may be added to the\n   * calling-interface's DOM\n   * @param {MultiToken} token Token to render to an HTML element\n   * @returns {any} Render result; e.g., HTML string, DOM element, React\n   *   Component, etc.\n   */\n  render(token) {\n    const ir = token.render(this); // intermediate representation\n    const renderFn = this.get('render', null, token) || this.defaultRender;\n    return renderFn(ir, token.t, token);\n  }\n};\nfunction noop(val) {\n  return val;\n}\n\nvar linkify_es_options = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tdefaults: defaults,\n\tOptions: Options,\n\tassign: linkify_es_assign\n});\n\n/******************************************************************************\n\tMulti-Tokens\n\tTokens composed of arrays of TextTokens\n******************************************************************************/\n\n/**\n * @param {string} value\n * @param {Token[]} tokens\n */\nfunction MultiToken(value, tokens) {\n  this.t = 'token';\n  this.v = value;\n  this.tk = tokens;\n}\n\n/**\n * Abstract class used for manufacturing tokens of text tokens. That is rather\n * than the value for a token being a small string of text, it's value an array\n * of text tokens.\n *\n * Used for grouping together URLs, emails, hashtags, and other potential\n * creations.\n * @class MultiToken\n * @property {string} t\n * @property {string} v\n * @property {Token[]} tk\n * @abstract\n */\nMultiToken.prototype = {\n  isLink: false,\n  /**\n   * Return the string this token represents.\n   * @return {string}\n   */\n  toString() {\n    return this.v;\n  },\n  /**\n   * What should the value for this token be in the `href` HTML attribute?\n   * Returns the `.toString` value by default.\n   * @param {string} [scheme]\n   * @return {string}\n  */\n  toHref(scheme) {\n    return this.toString();\n  },\n  /**\n   * @param {Options} options Formatting options\n   * @returns {string}\n   */\n  toFormattedString(options) {\n    const val = this.toString();\n    const truncate = options.get('truncate', val, this);\n    const formatted = options.get('format', val, this);\n    return truncate && formatted.length > truncate ? formatted.substring(0, truncate) + '…' : formatted;\n  },\n  /**\n   *\n   * @param {Options} options\n   * @returns {string}\n   */\n  toFormattedHref(options) {\n    return options.get('formatHref', this.toHref(options.get('defaultProtocol')), this);\n  },\n  /**\n   * The start index of this token in the original input string\n   * @returns {number}\n   */\n  startIndex() {\n    return this.tk[0].s;\n  },\n  /**\n   * The end index of this token in the original input string (up to this\n   * index but not including it)\n   * @returns {number}\n   */\n  endIndex() {\n    return this.tk[this.tk.length - 1].e;\n  },\n  /**\n  \tReturns an object  of relevant values for this token, which includes keys\n  \t* type - Kind of token ('url', 'email', etc.)\n  \t* value - Original text\n  \t* href - The value that should be added to the anchor tag's href\n  \t\tattribute\n  \t\t@method toObject\n  \t@param {string} [protocol] `'http'` by default\n  */\n  toObject(protocol) {\n    if (protocol === void 0) {\n      protocol = defaults.defaultProtocol;\n    }\n    return {\n      type: this.t,\n      value: this.toString(),\n      isLink: this.isLink,\n      href: this.toHref(protocol),\n      start: this.startIndex(),\n      end: this.endIndex()\n    };\n  },\n  /**\n   *\n   * @param {Options} options Formatting option\n   */\n  toFormattedObject(options) {\n    return {\n      type: this.t,\n      value: this.toFormattedString(options),\n      isLink: this.isLink,\n      href: this.toFormattedHref(options),\n      start: this.startIndex(),\n      end: this.endIndex()\n    };\n  },\n  /**\n   * Whether this token should be rendered as a link according to the given options\n   * @param {Options} options\n   * @returns {boolean}\n   */\n  validate(options) {\n    return options.get('validate', this.toString(), this);\n  },\n  /**\n   * Return an object that represents how this link should be rendered.\n   * @param {Options} options Formattinng options\n   */\n  render(options) {\n    const token = this;\n    const href = this.toHref(options.get('defaultProtocol'));\n    const formattedHref = options.get('formatHref', href, this);\n    const tagName = options.get('tagName', href, token);\n    const content = this.toFormattedString(options);\n    const attributes = {};\n    const className = options.get('className', href, token);\n    const target = options.get('target', href, token);\n    const rel = options.get('rel', href, token);\n    const attrs = options.getObj('attributes', href, token);\n    const eventListeners = options.getObj('events', href, token);\n    attributes.href = formattedHref;\n    if (className) {\n      attributes.class = className;\n    }\n    if (target) {\n      attributes.target = target;\n    }\n    if (rel) {\n      attributes.rel = rel;\n    }\n    if (attrs) {\n      linkify_es_assign(attributes, attrs);\n    }\n    return {\n      tagName,\n      attributes,\n      content,\n      eventListeners\n    };\n  }\n};\n\n/**\n * Create a new token that can be emitted by the parser state machine\n * @param {string} type readable type of the token\n * @param {object} props properties to assign or override, including isLink = true or false\n * @returns {new (value: string, tokens: Token[]) => MultiToken} new token class\n */\nfunction createTokenClass(type, props) {\n  class Token extends MultiToken {\n    constructor(value, tokens) {\n      super(value, tokens);\n      this.t = type;\n    }\n  }\n  for (const p in props) {\n    Token.prototype[p] = props[p];\n  }\n  Token.t = type;\n  return Token;\n}\n\n/**\n\tRepresents a list of tokens making up a valid email address\n*/\nconst Email = createTokenClass('email', {\n  isLink: true,\n  toHref() {\n    return 'mailto:' + this.toString();\n  }\n});\n\n/**\n\tRepresents some plain text\n*/\nconst Text = createTokenClass('text');\n\n/**\n\tMulti-linebreak token - represents a line break\n\t@class Nl\n*/\nconst Nl = createTokenClass('nl');\n\n/**\n\tRepresents a list of text tokens making up a valid URL\n\t@class Url\n*/\nconst Url = createTokenClass('url', {\n  isLink: true,\n  /**\n  \tLowercases relevant parts of the domain and adds the protocol if\n  \trequired. Note that this will not escape unsafe HTML characters in the\n  \tURL.\n  \t\t@param {string} [scheme] default scheme (e.g., 'https')\n  \t@return {string} the full href\n  */\n  toHref(scheme) {\n    if (scheme === void 0) {\n      scheme = defaults.defaultProtocol;\n    }\n    // Check if already has a prefix scheme\n    return this.hasProtocol() ? this.v : `${scheme}://${this.v}`;\n  },\n  /**\n   * Check whether this URL token has a protocol\n   * @return {boolean}\n   */\n  hasProtocol() {\n    const tokens = this.tk;\n    return tokens.length >= 2 && tokens[0].t !== LOCALHOST && tokens[1].t === COLON;\n  }\n});\n\nvar multi = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tMultiToken: MultiToken,\n\tBase: MultiToken,\n\tcreateTokenClass: createTokenClass,\n\tEmail: Email,\n\tText: Text,\n\tNl: Nl,\n\tUrl: Url\n});\n\n/**\n\tNot exactly parser, more like the second-stage scanner (although we can\n\ttheoretically hotswap the code here with a real parser in the future... but\n\tfor a little URL-finding utility abstract syntax trees may be a little\n\toverkill).\n\n\tURL format: http://en.wikipedia.org/wiki/URI_scheme\n\tEmail format: http://en.wikipedia.org/wiki/EmailAddress (links to RFC in\n\treference)\n\n\t@module linkify\n\t@submodule parser\n\t@main run\n*/\nconst makeState = arg => new State(arg);\n\n/**\n * Generate the parser multi token-based state machine\n * @param {{ groups: Collections<string> }} tokens\n */\nfunction init$1(_ref) {\n  let {\n    groups\n  } = _ref;\n  // Types of characters the URL can definitely end in\n  const qsAccepting = groups.domain.concat([AMPERSAND, ASTERISK, AT, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, NUM, PERCENT, PIPE, PLUS, POUND, SLASH, SYM, TILDE, UNDERSCORE]);\n\n  // Types of tokens that can follow a URL and be part of the query string\n  // but cannot be the very last characters\n  // Characters that cannot appear in the URL at all should be excluded\n  const qsNonAccepting = [APOSTROPHE, CLOSEANGLEBRACKET, CLOSEBRACE, CLOSEBRACKET, CLOSEPAREN, COLON, COMMA, DOT, EXCLAMATION, OPENANGLEBRACKET, OPENBRACE, OPENBRACKET, OPENPAREN, QUERY, QUOTE, SEMI];\n\n  // For addresses without the mailto prefix\n  // Tokens allowed in the localpart of the email\n  const localpartAccepting = [AMPERSAND, APOSTROPHE, ASTERISK, BACKSLASH, BACKTICK, CARET, CLOSEBRACE, DOLLAR, EQUALS, HYPHEN, OPENBRACE, PERCENT, PIPE, PLUS, POUND, QUERY, SLASH, SYM, TILDE, UNDERSCORE];\n\n  // The universal starting state.\n  /**\n   * @type State<Token>\n   */\n  const Start = makeState();\n  const Localpart = tt(Start, TILDE); // Local part of the email address\n  ta(Localpart, localpartAccepting, Localpart);\n  ta(Localpart, groups.domain, Localpart);\n  const Domain = makeState(),\n    Scheme = makeState(),\n    SlashScheme = makeState();\n  ta(Start, groups.domain, Domain); // parsed string ends with a potential domain name (A)\n  ta(Start, groups.scheme, Scheme); // e.g., 'mailto'\n  ta(Start, groups.slashscheme, SlashScheme); // e.g., 'http'\n\n  ta(Domain, localpartAccepting, Localpart);\n  ta(Domain, groups.domain, Domain);\n  const LocalpartAt = tt(Domain, AT); // Local part of the email address plus @\n\n  tt(Localpart, AT, LocalpartAt); // close to an email address now\n\n  // Local part of an email address can be e.g. 'http' or 'mailto'\n  tt(Scheme, AT, LocalpartAt);\n  tt(SlashScheme, AT, LocalpartAt);\n  const LocalpartDot = tt(Localpart, DOT); // Local part of the email address plus '.' (localpart cannot end in .)\n  ta(LocalpartDot, localpartAccepting, Localpart);\n  ta(LocalpartDot, groups.domain, Localpart);\n  const EmailDomain = makeState();\n  ta(LocalpartAt, groups.domain, EmailDomain); // parsed string starts with local email info + @ with a potential domain name\n  ta(EmailDomain, groups.domain, EmailDomain);\n  const EmailDomainDot = tt(EmailDomain, DOT); // domain followed by DOT\n  ta(EmailDomainDot, groups.domain, EmailDomain);\n  const Email$1 = makeState(Email); // Possible email address (could have more tlds)\n  ta(EmailDomainDot, groups.tld, Email$1);\n  ta(EmailDomainDot, groups.utld, Email$1);\n  tt(LocalpartAt, LOCALHOST, Email$1);\n\n  // Hyphen can jump back to a domain name\n  const EmailDomainHyphen = tt(EmailDomain, HYPHEN); // parsed string starts with local email info + @ with a potential domain name\n  ta(EmailDomainHyphen, groups.domain, EmailDomain);\n  ta(Email$1, groups.domain, EmailDomain);\n  tt(Email$1, DOT, EmailDomainDot);\n  tt(Email$1, HYPHEN, EmailDomainHyphen);\n\n  // Final possible email states\n  const EmailColon = tt(Email$1, COLON); // URL followed by colon (potential port number here)\n  /*const EmailColonPort = */\n  ta(EmailColon, groups.numeric, Email); // URL followed by colon and port numner\n\n  // Account for dots and hyphens. Hyphens are usually parts of domain names\n  // (but not TLDs)\n  const DomainHyphen = tt(Domain, HYPHEN); // domain followed by hyphen\n  const DomainDot = tt(Domain, DOT); // domain followed by DOT\n  ta(DomainHyphen, groups.domain, Domain);\n  ta(DomainDot, localpartAccepting, Localpart);\n  ta(DomainDot, groups.domain, Domain);\n  const DomainDotTld = makeState(Url); // Simplest possible URL with no query string\n  ta(DomainDot, groups.tld, DomainDotTld);\n  ta(DomainDot, groups.utld, DomainDotTld);\n  ta(DomainDotTld, groups.domain, Domain);\n  ta(DomainDotTld, localpartAccepting, Localpart);\n  tt(DomainDotTld, DOT, DomainDot);\n  tt(DomainDotTld, HYPHEN, DomainHyphen);\n  tt(DomainDotTld, AT, LocalpartAt);\n  const DomainDotTldColon = tt(DomainDotTld, COLON); // URL followed by colon (potential port number here)\n  const DomainDotTldColonPort = makeState(Url); // TLD followed by a port number\n  ta(DomainDotTldColon, groups.numeric, DomainDotTldColonPort);\n\n  // Long URL with optional port and maybe query string\n  const Url$1 = makeState(Url);\n\n  // URL with extra symbols at the end, followed by an opening bracket\n  const UrlNonaccept = makeState(); // URL followed by some symbols (will not be part of the final URL)\n\n  // Query strings\n  ta(Url$1, qsAccepting, Url$1);\n  ta(Url$1, qsNonAccepting, UrlNonaccept);\n  ta(UrlNonaccept, qsAccepting, Url$1);\n  ta(UrlNonaccept, qsNonAccepting, UrlNonaccept);\n\n  // Become real URLs after `SLASH` or `COLON NUM SLASH`\n  // Here works with or without scheme:// prefix\n  tt(DomainDotTld, SLASH, Url$1);\n  tt(DomainDotTldColonPort, SLASH, Url$1);\n\n  // Note that domains that begin with schemes are treated slighly differently\n  const SchemeColon = tt(Scheme, COLON); // e.g., 'mailto:'\n  const SlashSchemeColon = tt(SlashScheme, COLON); // e.g., 'http:'\n  const SlashSchemeColonSlash = tt(SlashSchemeColon, SLASH); // e.g., 'http:/'\n\n  const UriPrefix = tt(SlashSchemeColonSlash, SLASH); // e.g., 'http://'\n\n  // Scheme states can transition to domain states\n  ta(Scheme, groups.domain, Domain);\n  tt(Scheme, DOT, DomainDot);\n  tt(Scheme, HYPHEN, DomainHyphen);\n  ta(SlashScheme, groups.domain, Domain);\n  tt(SlashScheme, DOT, DomainDot);\n  tt(SlashScheme, HYPHEN, DomainHyphen);\n\n  // Force URL with scheme prefix followed by anything sane\n  ta(SchemeColon, groups.domain, Url$1);\n  tt(SchemeColon, SLASH, Url$1);\n  ta(UriPrefix, groups.domain, Url$1);\n  ta(UriPrefix, qsAccepting, Url$1);\n  tt(UriPrefix, SLASH, Url$1);\n\n  // URL, followed by an opening bracket\n  const UrlOpenbrace = tt(Url$1, OPENBRACE); // URL followed by {\n  const UrlOpenbracket = tt(Url$1, OPENBRACKET); // URL followed by [\n  const UrlOpenanglebracket = tt(Url$1, OPENANGLEBRACKET); // URL followed by <\n  const UrlOpenparen = tt(Url$1, OPENPAREN); // URL followed by (\n\n  tt(UrlNonaccept, OPENBRACE, UrlOpenbrace);\n  tt(UrlNonaccept, OPENBRACKET, UrlOpenbracket);\n  tt(UrlNonaccept, OPENANGLEBRACKET, UrlOpenanglebracket);\n  tt(UrlNonaccept, OPENPAREN, UrlOpenparen);\n\n  // Closing bracket component. This character WILL be included in the URL\n  tt(UrlOpenbrace, CLOSEBRACE, Url$1);\n  tt(UrlOpenbracket, CLOSEBRACKET, Url$1);\n  tt(UrlOpenanglebracket, CLOSEANGLEBRACKET, Url$1);\n  tt(UrlOpenparen, CLOSEPAREN, Url$1);\n  tt(UrlOpenbrace, CLOSEBRACE, Url$1);\n\n  // URL that beings with an opening bracket, followed by a symbols.\n  // Note that the final state can still be `UrlOpenbrace` (if the URL only\n  // has a single opening bracket for some reason).\n  const UrlOpenbraceQ = makeState(Url); // URL followed by { and some symbols that the URL can end it\n  const UrlOpenbracketQ = makeState(Url); // URL followed by [ and some symbols that the URL can end it\n  const UrlOpenanglebracketQ = makeState(Url); // URL followed by < and some symbols that the URL can end it\n  const UrlOpenparenQ = makeState(Url); // URL followed by ( and some symbols that the URL can end it\n  ta(UrlOpenbrace, qsAccepting, UrlOpenbraceQ);\n  ta(UrlOpenbracket, qsAccepting, UrlOpenbracketQ);\n  ta(UrlOpenanglebracket, qsAccepting, UrlOpenanglebracketQ);\n  ta(UrlOpenparen, qsAccepting, UrlOpenparenQ);\n  const UrlOpenbraceSyms = makeState(); // UrlOpenbrace followed by some symbols it cannot end it\n  const UrlOpenbracketSyms = makeState(); // UrlOpenbracketQ followed by some symbols it cannot end it\n  const UrlOpenanglebracketSyms = makeState(); // UrlOpenanglebracketQ followed by some symbols it cannot end it\n  const UrlOpenparenSyms = makeState(); // UrlOpenparenQ followed by some symbols it cannot end it\n  ta(UrlOpenbrace, qsNonAccepting);\n  ta(UrlOpenbracket, qsNonAccepting);\n  ta(UrlOpenanglebracket, qsNonAccepting);\n  ta(UrlOpenparen, qsNonAccepting);\n\n  // URL that begins with an opening bracket, followed by some symbols\n  ta(UrlOpenbraceQ, qsAccepting, UrlOpenbraceQ);\n  ta(UrlOpenbracketQ, qsAccepting, UrlOpenbracketQ);\n  ta(UrlOpenanglebracketQ, qsAccepting, UrlOpenanglebracketQ);\n  ta(UrlOpenparenQ, qsAccepting, UrlOpenparenQ);\n  ta(UrlOpenbraceQ, qsNonAccepting, UrlOpenbraceQ);\n  ta(UrlOpenbracketQ, qsNonAccepting, UrlOpenbracketQ);\n  ta(UrlOpenanglebracketQ, qsNonAccepting, UrlOpenanglebracketQ);\n  ta(UrlOpenparenQ, qsNonAccepting, UrlOpenparenQ);\n  ta(UrlOpenbraceSyms, qsAccepting, UrlOpenbraceSyms);\n  ta(UrlOpenbracketSyms, qsAccepting, UrlOpenbracketQ);\n  ta(UrlOpenanglebracketSyms, qsAccepting, UrlOpenanglebracketQ);\n  ta(UrlOpenparenSyms, qsAccepting, UrlOpenparenQ);\n  ta(UrlOpenbraceSyms, qsNonAccepting, UrlOpenbraceSyms);\n  ta(UrlOpenbracketSyms, qsNonAccepting, UrlOpenbracketSyms);\n  ta(UrlOpenanglebracketSyms, qsNonAccepting, UrlOpenanglebracketSyms);\n  ta(UrlOpenparenSyms, qsNonAccepting, UrlOpenparenSyms);\n\n  // Close brace/bracket to become regular URL\n  tt(UrlOpenbracketQ, CLOSEBRACKET, Url$1);\n  tt(UrlOpenanglebracketQ, CLOSEANGLEBRACKET, Url$1);\n  tt(UrlOpenparenQ, CLOSEPAREN, Url$1);\n  tt(UrlOpenbraceQ, CLOSEBRACE, Url$1);\n  tt(UrlOpenbracketSyms, CLOSEBRACKET, Url$1);\n  tt(UrlOpenanglebracketSyms, CLOSEANGLEBRACKET, Url$1);\n  tt(UrlOpenparenSyms, CLOSEPAREN, Url$1);\n  tt(UrlOpenbraceSyms, CLOSEPAREN, Url$1);\n  tt(Start, LOCALHOST, DomainDotTld); // localhost is a valid URL state\n  tt(Start, NL$1, Nl); // single new line\n\n  return {\n    start: Start,\n    tokens: tk\n  };\n}\n\n/**\n * Run the parser state machine on a list of scanned string-based tokens to\n * create a list of multi tokens, each of which represents a URL, email address,\n * plain text, etc.\n *\n * @param {State<MultiToken>} start parser start state\n * @param {string} input the original input used to generate the given tokens\n * @param {Token[]} tokens list of scanned tokens\n * @returns {MultiToken[]}\n */\nfunction run(start, input, tokens) {\n  let len = tokens.length;\n  let cursor = 0;\n  let multis = [];\n  let textTokens = [];\n  while (cursor < len) {\n    let state = start;\n    let secondState = null;\n    let nextState = null;\n    let multiLength = 0;\n    let latestAccepting = null;\n    let sinceAccepts = -1;\n    while (cursor < len && !(secondState = state.go(tokens[cursor].t))) {\n      // Starting tokens with nowhere to jump to.\n      // Consider these to be just plain text\n      textTokens.push(tokens[cursor++]);\n    }\n    while (cursor < len && (nextState = secondState || state.go(tokens[cursor].t))) {\n      // Get the next state\n      secondState = null;\n      state = nextState;\n\n      // Keep track of the latest accepting state\n      if (state.accepts()) {\n        sinceAccepts = 0;\n        latestAccepting = state;\n      } else if (sinceAccepts >= 0) {\n        sinceAccepts++;\n      }\n      cursor++;\n      multiLength++;\n    }\n    if (sinceAccepts < 0) {\n      // No accepting state was found, part of a regular text token add\n      // the first text token to the text tokens array and try again from\n      // the next\n      cursor -= multiLength;\n      if (cursor < len) {\n        textTokens.push(tokens[cursor]);\n        cursor++;\n      }\n    } else {\n      // Accepting state!\n      // First close off the textTokens (if available)\n      if (textTokens.length > 0) {\n        multis.push(initMultiToken(Text, input, textTokens));\n        textTokens = [];\n      }\n\n      // Roll back to the latest accepting state\n      cursor -= sinceAccepts;\n      multiLength -= sinceAccepts;\n\n      // Create a new multitoken\n      const Multi = latestAccepting.t;\n      const subtokens = tokens.slice(cursor - multiLength, cursor);\n      multis.push(initMultiToken(Multi, input, subtokens));\n    }\n  }\n\n  // Finally close off the textTokens (if available)\n  if (textTokens.length > 0) {\n    multis.push(initMultiToken(Text, input, textTokens));\n  }\n  return multis;\n}\n\n/**\n * Utility function for instantiating a new multitoken with all the relevant\n * fields during parsing.\n * @param {new (value: string, tokens: Token[]) => MultiToken} Multi class to instantiate\n * @param {string} input original input string\n * @param {Token[]} tokens consecutive tokens scanned from input string\n * @returns {MultiToken}\n */\nfunction initMultiToken(Multi, input, tokens) {\n  const startIdx = tokens[0].s;\n  const endIdx = tokens[tokens.length - 1].e;\n  const value = input.slice(startIdx, endIdx);\n  return new Multi(value, tokens);\n}\n\nconst warn = typeof console !== 'undefined' && console && console.warn || (() => {});\nconst warnAdvice = 'until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.';\n\n// Side-effect initialization state\nconst INIT = {\n  scanner: null,\n  parser: null,\n  tokenQueue: [],\n  pluginQueue: [],\n  customSchemes: [],\n  initialized: false\n};\n\n/**\n * @typedef {{\n * \tstart: State<string>,\n * \ttokens: { groups: Collections<string> } & typeof tk\n * }} ScannerInit\n */\n\n/**\n * @typedef {{\n * \tstart: State<MultiToken>,\n * \ttokens: typeof multi\n * }} ParserInit\n */\n\n/**\n * @typedef {(arg: { scanner: ScannerInit }) => void} TokenPlugin\n */\n\n/**\n * @typedef {(arg: { scanner: ScannerInit, parser: ParserInit }) => void} Plugin\n */\n\n/**\n * De-register all plugins and reset the internal state-machine. Used for\n * testing; not required in practice.\n * @private\n */\nfunction linkify_es_reset() {\n  State.groups = {};\n  INIT.scanner = null;\n  INIT.parser = null;\n  INIT.tokenQueue = [];\n  INIT.pluginQueue = [];\n  INIT.customSchemes = [];\n  INIT.initialized = false;\n}\n\n/**\n * Register a token plugin to allow the scanner to recognize additional token\n * types before the parser state machine is constructed from the results.\n * @param {string} name of plugin to register\n * @param {TokenPlugin} plugin function that accepts the scanner state machine\n * and available scanner tokens and collections and extends the state machine to\n * recognize additional tokens or groups.\n */\nfunction registerTokenPlugin(name, plugin) {\n  if (typeof plugin !== 'function') {\n    throw new Error(`linkifyjs: Invalid token plugin ${plugin} (expects function)`);\n  }\n  for (let i = 0; i < INIT.tokenQueue.length; i++) {\n    if (name === INIT.tokenQueue[i][0]) {\n      warn(`linkifyjs: token plugin \"${name}\" already registered - will be overwritten`);\n      INIT.tokenQueue[i] = [name, plugin];\n      return;\n    }\n  }\n  INIT.tokenQueue.push([name, plugin]);\n  if (INIT.initialized) {\n    warn(`linkifyjs: already initialized - will not register token plugin \"${name}\" ${warnAdvice}`);\n  }\n}\n\n/**\n * Register a linkify plugin\n * @param {string} name of plugin to register\n * @param {Plugin} plugin function that accepts the parser state machine and\n * extends the parser to recognize additional link types\n */\nfunction registerPlugin(name, plugin) {\n  if (typeof plugin !== 'function') {\n    throw new Error(`linkifyjs: Invalid plugin ${plugin} (expects function)`);\n  }\n  for (let i = 0; i < INIT.pluginQueue.length; i++) {\n    if (name === INIT.pluginQueue[i][0]) {\n      warn(`linkifyjs: plugin \"${name}\" already registered - will be overwritten`);\n      INIT.pluginQueue[i] = [name, plugin];\n      return;\n    }\n  }\n  INIT.pluginQueue.push([name, plugin]);\n  if (INIT.initialized) {\n    warn(`linkifyjs: already initialized - will not register plugin \"${name}\" ${warnAdvice}`);\n  }\n}\n\n/**\n * Detect URLs with the following additional protocol. Anything with format\n * \"protocol://...\" will be considered a link. If `optionalSlashSlash` is set to\n * `true`, anything with format \"protocol:...\" will be considered a link.\n * @param {string} protocol\n * @param {boolean} [optionalSlashSlash]\n */\nfunction registerCustomProtocol(scheme, optionalSlashSlash) {\n  if (optionalSlashSlash === void 0) {\n    optionalSlashSlash = false;\n  }\n  if (INIT.initialized) {\n    warn(`linkifyjs: already initialized - will not register custom scheme \"${scheme}\" ${warnAdvice}`);\n  }\n  if (!/^[0-9a-z]+(-[0-9a-z]+)*$/.test(scheme)) {\n    throw new Error('linkifyjs: incorrect scheme format.\\n 1. Must only contain digits, lowercase ASCII letters or \"-\"\\n 2. Cannot start or end with \"-\"\\n 3. \"-\" cannot repeat');\n  }\n  INIT.customSchemes.push([scheme, optionalSlashSlash]);\n}\n\n/**\n * Initialize the linkify state machine. Called automatically the first time\n * linkify is called on a string, but may be called manually as well.\n */\nfunction init() {\n  // Initialize scanner state machine and plugins\n  INIT.scanner = init$2(INIT.customSchemes);\n  for (let i = 0; i < INIT.tokenQueue.length; i++) {\n    INIT.tokenQueue[i][1]({\n      scanner: INIT.scanner\n    });\n  }\n\n  // Initialize parser state machine and plugins\n  INIT.parser = init$1(INIT.scanner.tokens);\n  for (let i = 0; i < INIT.pluginQueue.length; i++) {\n    INIT.pluginQueue[i][1]({\n      scanner: INIT.scanner,\n      parser: INIT.parser\n    });\n  }\n  INIT.initialized = true;\n}\n\n/**\n * Parse a string into tokens that represent linkable and non-linkable sub-components\n * @param {string} str\n * @return {MultiToken[]} tokens\n */\nfunction tokenize(str) {\n  if (!INIT.initialized) {\n    init();\n  }\n  return run(INIT.parser.start, str, run$1(INIT.scanner.start, str));\n}\n\n/**\n * Find a list of linkable items in the given string.\n * @param {string} str string to find links in\n * @param {string | Opts} [type] either formatting options or specific type of\n * links to find, e.g., 'url' or 'email'\n * @param {Opts} [opts] formatting options for final output. Cannot be specified\n * if opts already provided in `type` argument\n*/\nfunction find(str, type, opts) {\n  if (type === void 0) {\n    type = null;\n  }\n  if (opts === void 0) {\n    opts = null;\n  }\n  if (type && typeof type === 'object') {\n    if (opts) {\n      throw Error(`linkifyjs: Invalid link type ${type}; must be a string`);\n    }\n    opts = type;\n    type = null;\n  }\n  const options = new Options(opts);\n  const tokens = tokenize(str);\n  const filtered = [];\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    if (token.isLink && (!type || token.t === type)) {\n      filtered.push(token.toFormattedObject(options));\n    }\n  }\n  return filtered;\n}\n\n/**\n * Is the given string valid linkable text of some sort. Note that this does not\n * trim the text for you.\n *\n * Optionally pass in a second `type` param, which is the type of link to test\n * for.\n *\n * For example,\n *\n *     linkify.test(str, 'email');\n *\n * Returns `true` if str is a valid email.\n * @param {string} str string to test for links\n * @param {string} [type] optional specific link type to look for\n * @returns boolean true/false\n */\nfunction test(str, type) {\n  if (type === void 0) {\n    type = null;\n  }\n  const tokens = tokenize(str);\n  return tokens.length === 1 && tokens[0].isLink && (!type || tokens[0].t === type);\n}\n\n\n\n// CONCATENATED MODULE: ./node_modules/linkify-html/dist/linkify-html.es.js\n/* unused harmony export default */\n\n\n/**\n * generated from https://raw.githubusercontent.com/w3c/html/26b5126f96f736f796b9e29718138919dd513744/entities.json\n * do not edit\n */\nvar HTML5NamedCharRefs = {\n  // We don't need the complete named character reference because linkifyHtml\n  // does not modify the escape sequences. We do need &nbsp; so that\n  // whitespace is parsed properly. Other types of whitespace should already\n  // be accounted for. &gt; &lt; and &quot; are also frequently relevant ones\n  amp: \"&\",\n  gt: \">\",\n  lt: \"<\",\n  nbsp: \" \",\n  quot: \"\\\"\"\n};\nvar HEXCHARCODE = /^#[xX]([A-Fa-f0-9]+)$/;\nvar CHARCODE = /^#([0-9]+)$/;\nvar NAMED = /^([A-Za-z0-9]+)$/;\nvar EntityParser = /** @class */function () {\n  function EntityParser(named) {\n    this.named = named;\n  }\n  EntityParser.prototype.parse = function (entity) {\n    if (!entity) {\n      return;\n    }\n    var matches = entity.match(HEXCHARCODE);\n    if (matches) {\n      return String.fromCharCode(parseInt(matches[1], 16));\n    }\n    matches = entity.match(CHARCODE);\n    if (matches) {\n      return String.fromCharCode(parseInt(matches[1], 10));\n    }\n    matches = entity.match(NAMED);\n    if (matches) {\n      return this.named[matches[1]] || \"&\" + matches[1] + \";\";\n    }\n  };\n  return EntityParser;\n}();\nvar WSP = /[\\t\\n\\f ]/;\nvar ALPHA = /[A-Za-z]/;\nvar CRLF = /\\r\\n?/g;\nfunction isSpace(char) {\n  return WSP.test(char);\n}\nfunction isAlpha(char) {\n  return ALPHA.test(char);\n}\nfunction preprocessInput(input) {\n  return input.replace(CRLF, '\\n');\n}\nvar EventedTokenizer = /** @class */function () {\n  function EventedTokenizer(delegate, entityParser, mode) {\n    if (mode === void 0) {\n      mode = 'precompile';\n    }\n    this.delegate = delegate;\n    this.entityParser = entityParser;\n    this.mode = mode;\n    this.state = \"beforeData\" /* beforeData */;\n    this.line = -1;\n    this.column = -1;\n    this.input = '';\n    this.index = -1;\n    this.tagNameBuffer = '';\n    this.states = {\n      beforeData: function () {\n        var char = this.peek();\n        if (char === '<' && !this.isIgnoredEndTag()) {\n          this.transitionTo(\"tagOpen\" /* tagOpen */);\n          this.markTagStart();\n          this.consume();\n        } else {\n          if (this.mode === 'precompile' && char === '\\n') {\n            var tag = this.tagNameBuffer.toLowerCase();\n            if (tag === 'pre' || tag === 'textarea') {\n              this.consume();\n            }\n          }\n          this.transitionTo(\"data\" /* data */);\n          this.delegate.beginData();\n        }\n      },\n      data: function () {\n        var char = this.peek();\n        var tag = this.tagNameBuffer;\n        if (char === '<' && !this.isIgnoredEndTag()) {\n          this.delegate.finishData();\n          this.transitionTo(\"tagOpen\" /* tagOpen */);\n          this.markTagStart();\n          this.consume();\n        } else if (char === '&' && tag !== 'script' && tag !== 'style') {\n          this.consume();\n          this.delegate.appendToData(this.consumeCharRef() || '&');\n        } else {\n          this.consume();\n          this.delegate.appendToData(char);\n        }\n      },\n      tagOpen: function () {\n        var char = this.consume();\n        if (char === '!') {\n          this.transitionTo(\"markupDeclarationOpen\" /* markupDeclarationOpen */);\n        } else if (char === '/') {\n          this.transitionTo(\"endTagOpen\" /* endTagOpen */);\n        } else if (char === '@' || char === ':' || isAlpha(char)) {\n          this.transitionTo(\"tagName\" /* tagName */);\n          this.tagNameBuffer = '';\n          this.delegate.beginStartTag();\n          this.appendToTagName(char);\n        }\n      },\n      markupDeclarationOpen: function () {\n        var char = this.consume();\n        if (char === '-' && this.peek() === '-') {\n          this.consume();\n          this.transitionTo(\"commentStart\" /* commentStart */);\n          this.delegate.beginComment();\n        } else {\n          var maybeDoctype = char.toUpperCase() + this.input.substring(this.index, this.index + 6).toUpperCase();\n          if (maybeDoctype === 'DOCTYPE') {\n            this.consume();\n            this.consume();\n            this.consume();\n            this.consume();\n            this.consume();\n            this.consume();\n            this.transitionTo(\"doctype\" /* doctype */);\n            if (this.delegate.beginDoctype) this.delegate.beginDoctype();\n          }\n        }\n      },\n      doctype: function () {\n        var char = this.consume();\n        if (isSpace(char)) {\n          this.transitionTo(\"beforeDoctypeName\" /* beforeDoctypeName */);\n        }\n      },\n\n      beforeDoctypeName: function () {\n        var char = this.consume();\n        if (isSpace(char)) {\n          return;\n        } else {\n          this.transitionTo(\"doctypeName\" /* doctypeName */);\n          if (this.delegate.appendToDoctypeName) this.delegate.appendToDoctypeName(char.toLowerCase());\n        }\n      },\n      doctypeName: function () {\n        var char = this.consume();\n        if (isSpace(char)) {\n          this.transitionTo(\"afterDoctypeName\" /* afterDoctypeName */);\n        } else if (char === '>') {\n          if (this.delegate.endDoctype) this.delegate.endDoctype();\n          this.transitionTo(\"beforeData\" /* beforeData */);\n        } else {\n          if (this.delegate.appendToDoctypeName) this.delegate.appendToDoctypeName(char.toLowerCase());\n        }\n      },\n      afterDoctypeName: function () {\n        var char = this.consume();\n        if (isSpace(char)) {\n          return;\n        } else if (char === '>') {\n          if (this.delegate.endDoctype) this.delegate.endDoctype();\n          this.transitionTo(\"beforeData\" /* beforeData */);\n        } else {\n          var nextSixChars = char.toUpperCase() + this.input.substring(this.index, this.index + 5).toUpperCase();\n          var isPublic = nextSixChars.toUpperCase() === 'PUBLIC';\n          var isSystem = nextSixChars.toUpperCase() === 'SYSTEM';\n          if (isPublic || isSystem) {\n            this.consume();\n            this.consume();\n            this.consume();\n            this.consume();\n            this.consume();\n            this.consume();\n          }\n          if (isPublic) {\n            this.transitionTo(\"afterDoctypePublicKeyword\" /* afterDoctypePublicKeyword */);\n          } else if (isSystem) {\n            this.transitionTo(\"afterDoctypeSystemKeyword\" /* afterDoctypeSystemKeyword */);\n          }\n        }\n      },\n\n      afterDoctypePublicKeyword: function () {\n        var char = this.peek();\n        if (isSpace(char)) {\n          this.transitionTo(\"beforeDoctypePublicIdentifier\" /* beforeDoctypePublicIdentifier */);\n          this.consume();\n        } else if (char === '\"') {\n          this.transitionTo(\"doctypePublicIdentifierDoubleQuoted\" /* doctypePublicIdentifierDoubleQuoted */);\n          this.consume();\n        } else if (char === \"'\") {\n          this.transitionTo(\"doctypePublicIdentifierSingleQuoted\" /* doctypePublicIdentifierSingleQuoted */);\n          this.consume();\n        } else if (char === '>') {\n          this.consume();\n          if (this.delegate.endDoctype) this.delegate.endDoctype();\n          this.transitionTo(\"beforeData\" /* beforeData */);\n        }\n      },\n\n      doctypePublicIdentifierDoubleQuoted: function () {\n        var char = this.consume();\n        if (char === '\"') {\n          this.transitionTo(\"afterDoctypePublicIdentifier\" /* afterDoctypePublicIdentifier */);\n        } else if (char === '>') {\n          if (this.delegate.endDoctype) this.delegate.endDoctype();\n          this.transitionTo(\"beforeData\" /* beforeData */);\n        } else {\n          if (this.delegate.appendToDoctypePublicIdentifier) this.delegate.appendToDoctypePublicIdentifier(char);\n        }\n      },\n      doctypePublicIdentifierSingleQuoted: function () {\n        var char = this.consume();\n        if (char === \"'\") {\n          this.transitionTo(\"afterDoctypePublicIdentifier\" /* afterDoctypePublicIdentifier */);\n        } else if (char === '>') {\n          if (this.delegate.endDoctype) this.delegate.endDoctype();\n          this.transitionTo(\"beforeData\" /* beforeData */);\n        } else {\n          if (this.delegate.appendToDoctypePublicIdentifier) this.delegate.appendToDoctypePublicIdentifier(char);\n        }\n      },\n      afterDoctypePublicIdentifier: function () {\n        var char = this.consume();\n        if (isSpace(char)) {\n          this.transitionTo(\"betweenDoctypePublicAndSystemIdentifiers\" /* betweenDoctypePublicAndSystemIdentifiers */);\n        } else if (char === '>') {\n          if (this.delegate.endDoctype) this.delegate.endDoctype();\n          this.transitionTo(\"beforeData\" /* beforeData */);\n        } else if (char === '\"') {\n          this.transitionTo(\"doctypeSystemIdentifierDoubleQuoted\" /* doctypeSystemIdentifierDoubleQuoted */);\n        } else if (char === \"'\") {\n          this.transitionTo(\"doctypeSystemIdentifierSingleQuoted\" /* doctypeSystemIdentifierSingleQuoted */);\n        }\n      },\n\n      betweenDoctypePublicAndSystemIdentifiers: function () {\n        var char = this.consume();\n        if (isSpace(char)) {\n          return;\n        } else if (char === '>') {\n          if (this.delegate.endDoctype) this.delegate.endDoctype();\n          this.transitionTo(\"beforeData\" /* beforeData */);\n        } else if (char === '\"') {\n          this.transitionTo(\"doctypeSystemIdentifierDoubleQuoted\" /* doctypeSystemIdentifierDoubleQuoted */);\n        } else if (char === \"'\") {\n          this.transitionTo(\"doctypeSystemIdentifierSingleQuoted\" /* doctypeSystemIdentifierSingleQuoted */);\n        }\n      },\n\n      doctypeSystemIdentifierDoubleQuoted: function () {\n        var char = this.consume();\n        if (char === '\"') {\n          this.transitionTo(\"afterDoctypeSystemIdentifier\" /* afterDoctypeSystemIdentifier */);\n        } else if (char === '>') {\n          if (this.delegate.endDoctype) this.delegate.endDoctype();\n          this.transitionTo(\"beforeData\" /* beforeData */);\n        } else {\n          if (this.delegate.appendToDoctypeSystemIdentifier) this.delegate.appendToDoctypeSystemIdentifier(char);\n        }\n      },\n      doctypeSystemIdentifierSingleQuoted: function () {\n        var char = this.consume();\n        if (char === \"'\") {\n          this.transitionTo(\"afterDoctypeSystemIdentifier\" /* afterDoctypeSystemIdentifier */);\n        } else if (char === '>') {\n          if (this.delegate.endDoctype) this.delegate.endDoctype();\n          this.transitionTo(\"beforeData\" /* beforeData */);\n        } else {\n          if (this.delegate.appendToDoctypeSystemIdentifier) this.delegate.appendToDoctypeSystemIdentifier(char);\n        }\n      },\n      afterDoctypeSystemIdentifier: function () {\n        var char = this.consume();\n        if (isSpace(char)) {\n          return;\n        } else if (char === '>') {\n          if (this.delegate.endDoctype) this.delegate.endDoctype();\n          this.transitionTo(\"beforeData\" /* beforeData */);\n        }\n      },\n\n      commentStart: function () {\n        var char = this.consume();\n        if (char === '-') {\n          this.transitionTo(\"commentStartDash\" /* commentStartDash */);\n        } else if (char === '>') {\n          this.delegate.finishComment();\n          this.transitionTo(\"beforeData\" /* beforeData */);\n        } else {\n          this.delegate.appendToCommentData(char);\n          this.transitionTo(\"comment\" /* comment */);\n        }\n      },\n\n      commentStartDash: function () {\n        var char = this.consume();\n        if (char === '-') {\n          this.transitionTo(\"commentEnd\" /* commentEnd */);\n        } else if (char === '>') {\n          this.delegate.finishComment();\n          this.transitionTo(\"beforeData\" /* beforeData */);\n        } else {\n          this.delegate.appendToCommentData('-');\n          this.transitionTo(\"comment\" /* comment */);\n        }\n      },\n\n      comment: function () {\n        var char = this.consume();\n        if (char === '-') {\n          this.transitionTo(\"commentEndDash\" /* commentEndDash */);\n        } else {\n          this.delegate.appendToCommentData(char);\n        }\n      },\n      commentEndDash: function () {\n        var char = this.consume();\n        if (char === '-') {\n          this.transitionTo(\"commentEnd\" /* commentEnd */);\n        } else {\n          this.delegate.appendToCommentData('-' + char);\n          this.transitionTo(\"comment\" /* comment */);\n        }\n      },\n\n      commentEnd: function () {\n        var char = this.consume();\n        if (char === '>') {\n          this.delegate.finishComment();\n          this.transitionTo(\"beforeData\" /* beforeData */);\n        } else {\n          this.delegate.appendToCommentData('--' + char);\n          this.transitionTo(\"comment\" /* comment */);\n        }\n      },\n\n      tagName: function () {\n        var char = this.consume();\n        if (isSpace(char)) {\n          this.transitionTo(\"beforeAttributeName\" /* beforeAttributeName */);\n        } else if (char === '/') {\n          this.transitionTo(\"selfClosingStartTag\" /* selfClosingStartTag */);\n        } else if (char === '>') {\n          this.delegate.finishTag();\n          this.transitionTo(\"beforeData\" /* beforeData */);\n        } else {\n          this.appendToTagName(char);\n        }\n      },\n      endTagName: function () {\n        var char = this.consume();\n        if (isSpace(char)) {\n          this.transitionTo(\"beforeAttributeName\" /* beforeAttributeName */);\n          this.tagNameBuffer = '';\n        } else if (char === '/') {\n          this.transitionTo(\"selfClosingStartTag\" /* selfClosingStartTag */);\n          this.tagNameBuffer = '';\n        } else if (char === '>') {\n          this.delegate.finishTag();\n          this.transitionTo(\"beforeData\" /* beforeData */);\n          this.tagNameBuffer = '';\n        } else {\n          this.appendToTagName(char);\n        }\n      },\n      beforeAttributeName: function () {\n        var char = this.peek();\n        if (isSpace(char)) {\n          this.consume();\n          return;\n        } else if (char === '/') {\n          this.transitionTo(\"selfClosingStartTag\" /* selfClosingStartTag */);\n          this.consume();\n        } else if (char === '>') {\n          this.consume();\n          this.delegate.finishTag();\n          this.transitionTo(\"beforeData\" /* beforeData */);\n        } else if (char === '=') {\n          this.delegate.reportSyntaxError('attribute name cannot start with equals sign');\n          this.transitionTo(\"attributeName\" /* attributeName */);\n          this.delegate.beginAttribute();\n          this.consume();\n          this.delegate.appendToAttributeName(char);\n        } else {\n          this.transitionTo(\"attributeName\" /* attributeName */);\n          this.delegate.beginAttribute();\n        }\n      },\n      attributeName: function () {\n        var char = this.peek();\n        if (isSpace(char)) {\n          this.transitionTo(\"afterAttributeName\" /* afterAttributeName */);\n          this.consume();\n        } else if (char === '/') {\n          this.delegate.beginAttributeValue(false);\n          this.delegate.finishAttributeValue();\n          this.consume();\n          this.transitionTo(\"selfClosingStartTag\" /* selfClosingStartTag */);\n        } else if (char === '=') {\n          this.transitionTo(\"beforeAttributeValue\" /* beforeAttributeValue */);\n          this.consume();\n        } else if (char === '>') {\n          this.delegate.beginAttributeValue(false);\n          this.delegate.finishAttributeValue();\n          this.consume();\n          this.delegate.finishTag();\n          this.transitionTo(\"beforeData\" /* beforeData */);\n        } else if (char === '\"' || char === \"'\" || char === '<') {\n          this.delegate.reportSyntaxError(char + ' is not a valid character within attribute names');\n          this.consume();\n          this.delegate.appendToAttributeName(char);\n        } else {\n          this.consume();\n          this.delegate.appendToAttributeName(char);\n        }\n      },\n      afterAttributeName: function () {\n        var char = this.peek();\n        if (isSpace(char)) {\n          this.consume();\n          return;\n        } else if (char === '/') {\n          this.delegate.beginAttributeValue(false);\n          this.delegate.finishAttributeValue();\n          this.consume();\n          this.transitionTo(\"selfClosingStartTag\" /* selfClosingStartTag */);\n        } else if (char === '=') {\n          this.consume();\n          this.transitionTo(\"beforeAttributeValue\" /* beforeAttributeValue */);\n        } else if (char === '>') {\n          this.delegate.beginAttributeValue(false);\n          this.delegate.finishAttributeValue();\n          this.consume();\n          this.delegate.finishTag();\n          this.transitionTo(\"beforeData\" /* beforeData */);\n        } else {\n          this.delegate.beginAttributeValue(false);\n          this.delegate.finishAttributeValue();\n          this.transitionTo(\"attributeName\" /* attributeName */);\n          this.delegate.beginAttribute();\n          this.consume();\n          this.delegate.appendToAttributeName(char);\n        }\n      },\n      beforeAttributeValue: function () {\n        var char = this.peek();\n        if (isSpace(char)) {\n          this.consume();\n        } else if (char === '\"') {\n          this.transitionTo(\"attributeValueDoubleQuoted\" /* attributeValueDoubleQuoted */);\n          this.delegate.beginAttributeValue(true);\n          this.consume();\n        } else if (char === \"'\") {\n          this.transitionTo(\"attributeValueSingleQuoted\" /* attributeValueSingleQuoted */);\n          this.delegate.beginAttributeValue(true);\n          this.consume();\n        } else if (char === '>') {\n          this.delegate.beginAttributeValue(false);\n          this.delegate.finishAttributeValue();\n          this.consume();\n          this.delegate.finishTag();\n          this.transitionTo(\"beforeData\" /* beforeData */);\n        } else {\n          this.transitionTo(\"attributeValueUnquoted\" /* attributeValueUnquoted */);\n          this.delegate.beginAttributeValue(false);\n          this.consume();\n          this.delegate.appendToAttributeValue(char);\n        }\n      },\n      attributeValueDoubleQuoted: function () {\n        var char = this.consume();\n        if (char === '\"') {\n          this.delegate.finishAttributeValue();\n          this.transitionTo(\"afterAttributeValueQuoted\" /* afterAttributeValueQuoted */);\n        } else if (char === '&') {\n          this.delegate.appendToAttributeValue(this.consumeCharRef() || '&');\n        } else {\n          this.delegate.appendToAttributeValue(char);\n        }\n      },\n      attributeValueSingleQuoted: function () {\n        var char = this.consume();\n        if (char === \"'\") {\n          this.delegate.finishAttributeValue();\n          this.transitionTo(\"afterAttributeValueQuoted\" /* afterAttributeValueQuoted */);\n        } else if (char === '&') {\n          this.delegate.appendToAttributeValue(this.consumeCharRef() || '&');\n        } else {\n          this.delegate.appendToAttributeValue(char);\n        }\n      },\n      attributeValueUnquoted: function () {\n        var char = this.peek();\n        if (isSpace(char)) {\n          this.delegate.finishAttributeValue();\n          this.consume();\n          this.transitionTo(\"beforeAttributeName\" /* beforeAttributeName */);\n        } else if (char === '/') {\n          this.delegate.finishAttributeValue();\n          this.consume();\n          this.transitionTo(\"selfClosingStartTag\" /* selfClosingStartTag */);\n        } else if (char === '&') {\n          this.consume();\n          this.delegate.appendToAttributeValue(this.consumeCharRef() || '&');\n        } else if (char === '>') {\n          this.delegate.finishAttributeValue();\n          this.consume();\n          this.delegate.finishTag();\n          this.transitionTo(\"beforeData\" /* beforeData */);\n        } else {\n          this.consume();\n          this.delegate.appendToAttributeValue(char);\n        }\n      },\n      afterAttributeValueQuoted: function () {\n        var char = this.peek();\n        if (isSpace(char)) {\n          this.consume();\n          this.transitionTo(\"beforeAttributeName\" /* beforeAttributeName */);\n        } else if (char === '/') {\n          this.consume();\n          this.transitionTo(\"selfClosingStartTag\" /* selfClosingStartTag */);\n        } else if (char === '>') {\n          this.consume();\n          this.delegate.finishTag();\n          this.transitionTo(\"beforeData\" /* beforeData */);\n        } else {\n          this.transitionTo(\"beforeAttributeName\" /* beforeAttributeName */);\n        }\n      },\n\n      selfClosingStartTag: function () {\n        var char = this.peek();\n        if (char === '>') {\n          this.consume();\n          this.delegate.markTagAsSelfClosing();\n          this.delegate.finishTag();\n          this.transitionTo(\"beforeData\" /* beforeData */);\n        } else {\n          this.transitionTo(\"beforeAttributeName\" /* beforeAttributeName */);\n        }\n      },\n\n      endTagOpen: function () {\n        var char = this.consume();\n        if (char === '@' || char === ':' || isAlpha(char)) {\n          this.transitionTo(\"endTagName\" /* endTagName */);\n          this.tagNameBuffer = '';\n          this.delegate.beginEndTag();\n          this.appendToTagName(char);\n        }\n      }\n    };\n    this.reset();\n  }\n  EventedTokenizer.prototype.reset = function () {\n    this.transitionTo(\"beforeData\" /* beforeData */);\n    this.input = '';\n    this.tagNameBuffer = '';\n    this.index = 0;\n    this.line = 1;\n    this.column = 0;\n    this.delegate.reset();\n  };\n  EventedTokenizer.prototype.transitionTo = function (state) {\n    this.state = state;\n  };\n  EventedTokenizer.prototype.tokenize = function (input) {\n    this.reset();\n    this.tokenizePart(input);\n    this.tokenizeEOF();\n  };\n  EventedTokenizer.prototype.tokenizePart = function (input) {\n    this.input += preprocessInput(input);\n    while (this.index < this.input.length) {\n      var handler = this.states[this.state];\n      if (handler !== undefined) {\n        handler.call(this);\n      } else {\n        throw new Error(\"unhandled state \" + this.state);\n      }\n    }\n  };\n  EventedTokenizer.prototype.tokenizeEOF = function () {\n    this.flushData();\n  };\n  EventedTokenizer.prototype.flushData = function () {\n    if (this.state === 'data') {\n      this.delegate.finishData();\n      this.transitionTo(\"beforeData\" /* beforeData */);\n    }\n  };\n\n  EventedTokenizer.prototype.peek = function () {\n    return this.input.charAt(this.index);\n  };\n  EventedTokenizer.prototype.consume = function () {\n    var char = this.peek();\n    this.index++;\n    if (char === '\\n') {\n      this.line++;\n      this.column = 0;\n    } else {\n      this.column++;\n    }\n    return char;\n  };\n  EventedTokenizer.prototype.consumeCharRef = function () {\n    var endIndex = this.input.indexOf(';', this.index);\n    if (endIndex === -1) {\n      return;\n    }\n    var entity = this.input.slice(this.index, endIndex);\n    var chars = this.entityParser.parse(entity);\n    if (chars) {\n      var count = entity.length;\n      // consume the entity chars\n      while (count) {\n        this.consume();\n        count--;\n      }\n      // consume the `;`\n      this.consume();\n      return chars;\n    }\n  };\n  EventedTokenizer.prototype.markTagStart = function () {\n    this.delegate.tagOpen();\n  };\n  EventedTokenizer.prototype.appendToTagName = function (char) {\n    this.tagNameBuffer += char;\n    this.delegate.appendToTagName(char);\n  };\n  EventedTokenizer.prototype.isIgnoredEndTag = function () {\n    var tag = this.tagNameBuffer;\n    return tag === 'title' && this.input.substring(this.index, this.index + 8) !== '</title>' || tag === 'style' && this.input.substring(this.index, this.index + 8) !== '</style>' || tag === 'script' && this.input.substring(this.index, this.index + 9) !== '<\/script>';\n  };\n  return EventedTokenizer;\n}();\nvar Tokenizer = /** @class */function () {\n  function Tokenizer(entityParser, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    this.options = options;\n    this.token = null;\n    this.startLine = 1;\n    this.startColumn = 0;\n    this.tokens = [];\n    this.tokenizer = new EventedTokenizer(this, entityParser, options.mode);\n    this._currentAttribute = undefined;\n  }\n  Tokenizer.prototype.tokenize = function (input) {\n    this.tokens = [];\n    this.tokenizer.tokenize(input);\n    return this.tokens;\n  };\n  Tokenizer.prototype.tokenizePart = function (input) {\n    this.tokens = [];\n    this.tokenizer.tokenizePart(input);\n    return this.tokens;\n  };\n  Tokenizer.prototype.tokenizeEOF = function () {\n    this.tokens = [];\n    this.tokenizer.tokenizeEOF();\n    return this.tokens[0];\n  };\n  Tokenizer.prototype.reset = function () {\n    this.token = null;\n    this.startLine = 1;\n    this.startColumn = 0;\n  };\n  Tokenizer.prototype.current = function () {\n    var token = this.token;\n    if (token === null) {\n      throw new Error('token was unexpectedly null');\n    }\n    if (arguments.length === 0) {\n      return token;\n    }\n    for (var i = 0; i < arguments.length; i++) {\n      if (token.type === arguments[i]) {\n        return token;\n      }\n    }\n    throw new Error(\"token type was unexpectedly \" + token.type);\n  };\n  Tokenizer.prototype.push = function (token) {\n    this.token = token;\n    this.tokens.push(token);\n  };\n  Tokenizer.prototype.currentAttribute = function () {\n    return this._currentAttribute;\n  };\n  Tokenizer.prototype.addLocInfo = function () {\n    if (this.options.loc) {\n      this.current().loc = {\n        start: {\n          line: this.startLine,\n          column: this.startColumn\n        },\n        end: {\n          line: this.tokenizer.line,\n          column: this.tokenizer.column\n        }\n      };\n    }\n    this.startLine = this.tokenizer.line;\n    this.startColumn = this.tokenizer.column;\n  };\n  // Data\n  Tokenizer.prototype.beginDoctype = function () {\n    this.push({\n      type: \"Doctype\" /* Doctype */,\n      name: ''\n    });\n  };\n  Tokenizer.prototype.appendToDoctypeName = function (char) {\n    this.current(\"Doctype\" /* Doctype */).name += char;\n  };\n  Tokenizer.prototype.appendToDoctypePublicIdentifier = function (char) {\n    var doctype = this.current(\"Doctype\" /* Doctype */);\n    if (doctype.publicIdentifier === undefined) {\n      doctype.publicIdentifier = char;\n    } else {\n      doctype.publicIdentifier += char;\n    }\n  };\n  Tokenizer.prototype.appendToDoctypeSystemIdentifier = function (char) {\n    var doctype = this.current(\"Doctype\" /* Doctype */);\n    if (doctype.systemIdentifier === undefined) {\n      doctype.systemIdentifier = char;\n    } else {\n      doctype.systemIdentifier += char;\n    }\n  };\n  Tokenizer.prototype.endDoctype = function () {\n    this.addLocInfo();\n  };\n  Tokenizer.prototype.beginData = function () {\n    this.push({\n      type: \"Chars\" /* Chars */,\n      chars: ''\n    });\n  };\n  Tokenizer.prototype.appendToData = function (char) {\n    this.current(\"Chars\" /* Chars */).chars += char;\n  };\n  Tokenizer.prototype.finishData = function () {\n    this.addLocInfo();\n  };\n  // Comment\n  Tokenizer.prototype.beginComment = function () {\n    this.push({\n      type: \"Comment\" /* Comment */,\n      chars: ''\n    });\n  };\n  Tokenizer.prototype.appendToCommentData = function (char) {\n    this.current(\"Comment\" /* Comment */).chars += char;\n  };\n  Tokenizer.prototype.finishComment = function () {\n    this.addLocInfo();\n  };\n  // Tags - basic\n  Tokenizer.prototype.tagOpen = function () {};\n  Tokenizer.prototype.beginStartTag = function () {\n    this.push({\n      type: \"StartTag\" /* StartTag */,\n      tagName: '',\n      attributes: [],\n      selfClosing: false\n    });\n  };\n  Tokenizer.prototype.beginEndTag = function () {\n    this.push({\n      type: \"EndTag\" /* EndTag */,\n      tagName: ''\n    });\n  };\n  Tokenizer.prototype.finishTag = function () {\n    this.addLocInfo();\n  };\n  Tokenizer.prototype.markTagAsSelfClosing = function () {\n    this.current(\"StartTag\" /* StartTag */).selfClosing = true;\n  };\n  // Tags - name\n  Tokenizer.prototype.appendToTagName = function (char) {\n    this.current(\"StartTag\" /* StartTag */, \"EndTag\" /* EndTag */).tagName += char;\n  };\n  // Tags - attributes\n  Tokenizer.prototype.beginAttribute = function () {\n    this._currentAttribute = ['', '', false];\n  };\n  Tokenizer.prototype.appendToAttributeName = function (char) {\n    this.currentAttribute()[0] += char;\n  };\n  Tokenizer.prototype.beginAttributeValue = function (isQuoted) {\n    this.currentAttribute()[2] = isQuoted;\n  };\n  Tokenizer.prototype.appendToAttributeValue = function (char) {\n    this.currentAttribute()[1] += char;\n  };\n  Tokenizer.prototype.finishAttributeValue = function () {\n    this.current(\"StartTag\" /* StartTag */).attributes.push(this._currentAttribute);\n  };\n  Tokenizer.prototype.reportSyntaxError = function (message) {\n    this.current().syntaxError = message;\n  };\n  return Tokenizer;\n}();\nfunction linkify_html_es_tokenize(input, options) {\n  var tokenizer = new Tokenizer(new EntityParser(HTML5NamedCharRefs), options);\n  return tokenizer.tokenize(input);\n}\n\nconst LinkifyResult = 'LinkifyResult';\nconst StartTag = 'StartTag';\nconst EndTag = 'EndTag';\nconst Chars = 'Chars';\nconst Comment = 'Comment';\nconst Doctype = 'Doctype';\n\n/**\n * @param {string} str html string to link\n * @param {import('linkifyjs').Opts} [opts] linkify options\n * @returns {string} resulting string\n */\nfunction linkifyHtml(str, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n  // `tokens` and `token` in this section refer to tokens generated by the\n  // HTML parser, not linkify's parser\n  const tokens = linkify_html_es_tokenize(str);\n  const linkifiedTokens = [];\n  const linkified = [];\n  const options = new Options(opts, defaultRender);\n\n  // Linkify the tokens given by the parser\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    if (token.type === StartTag) {\n      linkifiedTokens.push(token);\n\n      // Ignore all the contents of ignored tags\n      const tagName = token.tagName.toUpperCase();\n      const isIgnored = tagName === 'A' || options.ignoreTags.indexOf(tagName) >= 0;\n      if (!isIgnored) {\n        continue;\n      }\n      let preskipLen = linkifiedTokens.length;\n      skipTagTokens(tagName, tokens, ++i, linkifiedTokens);\n      i += linkifiedTokens.length - preskipLen - 1;\n    } else if (token.type !== Chars) {\n      // Skip this token, it's not important\n      linkifiedTokens.push(token);\n    } else {\n      // Valid text token, linkify it!\n      const linkifedChars = linkifyChars(token.chars, options);\n      linkifiedTokens.push.apply(linkifiedTokens, linkifedChars);\n    }\n  }\n\n  // Convert the tokens back into a string\n  for (let i = 0; i < linkifiedTokens.length; i++) {\n    const token = linkifiedTokens[i];\n    switch (token.type) {\n      case LinkifyResult:\n        linkified.push(token.rendered);\n        break;\n      case StartTag:\n        {\n          let link = '<' + token.tagName;\n          if (token.attributes.length > 0) {\n            link += ' ' + attributeArrayToStrings(token.attributes).join(' ');\n          }\n          if (token.selfClosing) {\n            link += ' /';\n          }\n          link += '>';\n          linkified.push(link);\n          break;\n        }\n      case EndTag:\n        linkified.push(`</${token.tagName}>`);\n        break;\n      case Chars:\n        linkified.push(escapeText(token.chars));\n        break;\n      case Comment:\n        linkified.push(`\x3c!--${escapeText(token.chars)}--\x3e`);\n        break;\n      case Doctype:\n        {\n          let doctype = `<!DOCTYPE ${token.name}`;\n          if (token.publicIdentifier) {\n            doctype += ` PUBLIC \"${token.publicIdentifier}\"`;\n          }\n          if (token.systemIdentifier) {\n            doctype += ` \"${token.systemIdentifier}\"`;\n          }\n          doctype += '>';\n          linkified.push(doctype);\n          break;\n        }\n    }\n  }\n  return linkified.join('');\n}\n\n/**\n\t`tokens` and `token` in this section referes to tokens returned by\n\t`linkify.tokenize`. `linkified` will contain HTML Parser-style tokens\n\t@param {string}\n\t@param {import('linkifyjs').Options}\n*/\nfunction linkifyChars(str, options) {\n  const tokens = tokenize(str);\n  const result = [];\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    if (token.t === 'nl' && options.get('nl2br')) {\n      result.push({\n        type: StartTag,\n        tagName: 'br',\n        attributes: [],\n        selfClosing: true\n      });\n    } else if (!token.isLink || !options.check(token)) {\n      result.push({\n        type: Chars,\n        chars: token.toString()\n      });\n    } else {\n      result.push({\n        type: LinkifyResult,\n        rendered: options.render(token)\n      });\n    }\n  }\n  return result;\n}\n\n/**\n\tReturns a list of tokens skipped until the closing tag of tagName.\n\n\t* `tagName` is the closing tag which will prompt us to stop skipping\n\t* `tokens` is the array of tokens generated by HTML5Tokenizer which\n\t* `i` is the index immediately after the opening tag to skip\n\t* `skippedTokens` is an array which skipped tokens are being pushed into\n\n\tCaveats\n\n\t* Assumes that i is the first token after the given opening tagName\n\t* The closing tag will be skipped, but nothing after it\n\t* Will track whether there is a nested tag of the same type\n*/\nfunction skipTagTokens(tagName, tokens, i, skippedTokens) {\n  // number of tokens of this type on the [fictional] stack\n  let stackCount = 1;\n  while (i < tokens.length && stackCount > 0) {\n    let token = tokens[i];\n    if (token.type === StartTag && token.tagName.toUpperCase() === tagName) {\n      // Nested tag of the same type, \"add to stack\"\n      stackCount++;\n    } else if (token.type === EndTag && token.tagName.toUpperCase() === tagName) {\n      // Closing tag\n      stackCount--;\n    }\n    skippedTokens.push(token);\n    i++;\n  }\n\n  // Note that if stackCount > 0 here, the HTML is probably invalid\n  return skippedTokens;\n}\nfunction defaultRender(_ref) {\n  let {\n    tagName,\n    attributes,\n    content\n  } = _ref;\n  return `<${tagName} ${attributesToString(attributes)}>${escapeText(content)}</${tagName}>`;\n}\nfunction escapeText(text) {\n  return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n}\nfunction escapeAttr(attr) {\n  return attr.replace(/\"/g, '&quot;');\n}\nfunction attributesToString(attributes) {\n  const result = [];\n  for (const attr in attributes) {\n    const val = attributes[attr] + '';\n    result.push(`${attr}=\"${escapeAttr(val)}\"`);\n  }\n  return result.join(' ');\n}\nfunction attributeArrayToStrings(attrs) {\n  const attrStrs = [];\n  for (let i = 0; i < attrs.length; i++) {\n    const name = attrs[i][0];\n    const value = attrs[i][1] + '';\n    attrStrs.push(`${name}=\"${escapeAttr(value)}\"`);\n  }\n  return attrStrs;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGlua2lmeWpzL2Rpc3QvbGlua2lmeS5lcy5qcz9kYjFmIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9saW5raWZ5LWh0bWwvZGlzdC9saW5raWZ5LWh0bWwuZXMuanM/MmI5NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUSElTIEZJTEUgSVMgQVVUT01BVElDQUxMWSBHRU5FUkFURUQgRE8gTk9UIEVESVQgRElSRUNUTFlcbi8vIFNlZSB1cGRhdGUtdGxkcy5qcyBmb3IgZW5jb2RpbmcvZGVjb2RpbmcgZm9ybWF0XG4vLyBodHRwczovL2RhdGEuaWFuYS5vcmcvVExEL3RsZHMtYWxwaGEtYnktZG9tYWluLnR4dFxuY29uc3QgZW5jb2RlZFRsZHMgPSAnYWFhMXJwM2JhcnRoNGIwb3R0M3ZpZTRjMWxlMm9nYWRvNXVkaGFiaTdjMGFkZW15NWNlbnR1cmU2b3VudGFudDBzOW8xdG9yNGQwczF1bHQ0ZTBnMXJvMnRuYTRmMGwxcmljYTVnMGFraGFuNWVuY3k1aTBnMXJidXMzZm9yY2U1dGVsNWtkbjNsMGZhcm9tZW83aWJhYmE0cGF5NGxmaW5hbno2c3RhdGU1eTJzYWNlM3RvbTVtMGF6b240ZXJpY2FuZXhwcmVzczdmYW1pbHkxMXgyZmFtM2ljYTNzdGVyZGFtOG5hbHl0aWNzN2Ryb2lkNXF1YW40ejJvMGwycGFydG1lbnRzOHAwbGU0cTB1YXJlbGxlOHIwYWIxbWNvNGNoaTNteTJwYTJ0MGUzczBkYTJpYTJzb2NpYXRlczl0MGhsZXRhNXRvcm5leTd1MGN0aW9uNWRpMGJsZTNvM3Nwb3N0NXRob3IzbzBzNHZpYW5jYTZ3MHMyeDBhMnowdXJlNWJhMGJ5MmlkdTNuYW1leDNuYXJlcHVibGljMTFkMWsycjBjZWxvbmE1bGF5Y2FyZDRzNWVmb290NWdhaW5zNnNlYmFsbDVrZXRiYWxsOHVoYXVzNXllcm41YjBjMXQxdmEzY2cxbjJkMWUwYXRzMnV0eTRlcjJudGxleTVybGluNHN0MGJ1eTV0MmYxZzFoMGFydGk1aTBibGUzZDFrZTJuZzBvM28xejJqMWxhY2swZnJpZGF5OW9ja2J1c3RlcjhnMW9tYmVyZzd1ZTNtMHMxdzJuMHBwYXJpYmFzOW8wYXRzM2VocmluZ2VyOGZhMm0xbmQybzBrMGluZzVzY2gydGlrMm9uNHQxdXRpcXVlNngycjBhZGVzY282aWRnZXN0b25lOW9hZHdheTVrZXIzdGhlcjV1c3NlbHM3czF0MXVpbGQwZXJzNnNpbmVzczZ5MXp6M3YxdzF5MXowaDNjYTBiMWZlMmwwbDF2aW5rbGVpbjltMGVyYTNwMm5vbjNwZXRvd241aXRhbDBvbmU4cjBhdmFuNGRzMmUwZXIwczRzMnNhMWUxaDFpbm80dDBlcmluZzVob2xpYzdiYTFuMXJlMnMyYzFkMWVudGVyNG8xcm4zZjBhMWQyZzFoMGFuZWwybmVsNHJpdHk0c2UydDJlYXAzaW50YWk1cmlzdG1hczZvbWU0dXJjaDVpMHByaWFuaTZyY2xlNHNjbzN0YWRlbDRpMGMyeTBlYXRzN2sxbDBhaW1zNGVhbmluZzZpY2sybmljMXF1ZTZvdGhpbmc1dWQzdWIwbWVkNm0xbjFvMGFjaDNkZXMzZmZlZTRsbGVnZTRvZ25lNW0wY2FzdDRtYmFuazR1bml0eTZwYW55MnJlM3V0ZXI1c2VjNG5kb3Mzc3RydWN0aW9uOHVsdGluZzd0YWN0M3JhY3RvcnM5b2tpbmcwY2hhbm5lbDExbDFwMnJzaWNhNXVudHJ5NHBvbjBzNHJzZXM2cGEycjBlZGl0MGNhcmQ0dW5pb245aWNrZXQ1b3duM3MxdWlzZTBzNnUwaXNpbmVsbGE5djF3MXgxeTBtcnUzb3UzejJkYWJ1cjNkMW5jZTN0YTFlMWluZzNzdW40eTJjbGszZHMyZTBhbDBlcjJzM2dyZWU0bGl2ZXJ5NWwxb2l0dGU1dGEzbW9jcmF0Nm50YWwyaXN0NXNpMGduNHYyaGwyaWFtb25kczZldDJnaXRhbDVyZWN0MG9yeTdzY291bnQzdmVyNWgyeTJqMWsxbTFucDJvMGNzMXRvcjRnMW1haW5zNXQxd25sb2FkN3JpdmU0dHYydWJhaTNubG9wNHBvbnQ0cmJhbjV2YWcycjJ6MmVhcnRoM3QyYzBvMmRla2EzdTBjYXRpb244ZTFnMW1haWwzZXJjazVuZXJneTRnaW5lZXIwaW5nOXRlcnByaXNlczEwcHNvbjRxdWlwbWVudDhyMGljc3NvbjZuaTNzMHExdGF0ZTV0MGlzYWxhdDd1MHJvdmlzaW9uOHMydmVudHM1eGNoYW5nZTZwZXJ0M29zZWQ0cmVzczV0cmFzcGFjZTEwZmFnZTJpbDFyd2luZHM2dGgzbWlseTRuMHMycm0wZXJzNXNoaW9uNHQzZWRleDNlZGJhY2s2cnJhcmkzZXJvNmkwYXQyZGVsaXR5NW8ybG0ybmFsMW5jZTFpYWw3cmUwc3RvbmU2bWRhbGU2c2gwaW5nNXQwbmVzczZqMWsxbGlja3IzZ2h0czRyMm9yaXN0NHdlcnM1eTJtMW8wbzBkMG5ldHdvcms4dGJhbGw2cmQxZXgyc2FsZTR1bTN1bmRhdGlvbjh4MnIwZWUxc2VuaXVzN2wxb2dhbnM0bnRkb29yNGllcjd0cjJ1aml0c3U1bjBkMnJuaXR1cmU3dGJvbDV5aTNnYTBsMGxlcnkzbzF1cDRtZTBzM3AxcmRlbjR5MmIwaXozZDBuMmUwYTFudDBpbmc1b3JnZTVmMWcwZWUzaDFpMGZ0MHMzdmVzMmluZzVsMGFzczNlMW9iYWwybzRtMGFpbDNiaDJvMXgybjFvZGFkZHk1bGQwcG9pbnQ2ZjJvMGR5ZWFyNWcwbGU0cDF0MXYycDFxMXIwYWluZ2VyNXBoaWNzNXRpczRlZW4zaXBlM29jZXJ5NHVwNHMxdDF1MGFyZGlhbjZjY2kzZ2UyaWRlMnRhcnM1cnUzdzF5MmhhaXIybWJ1cmc1bmdvdXQ1dXMzYm8yZGZjMGJhbms3ZWFsdGgwY2FyZThscDFzaW5raTZyZTFtZXM1Z3R2M2lwaG9wNHNhbWl0c3U3dGFjaGk1djJrMHQybTFuMW9ja2V5NGxkaW5nczVpZGF5NW1lZGVwb3Q1Z29vZHM1czBlbnNlN25kYTNyc2Uzc3BpdGFsNXQwaW5nNXQwZWxlczJzM21haWw1dXNlM3cycjFzYmMzdDF1MGdoZXM1eWF0dDN1bmRhaTdpYm0yY2JjMmUxdTJkMWUwZWUzZm0ya2FubzRsMW0wYW1hdDRkYjJtbzBiaWxpZW45bjBjMWR1c3RyaWVzOGZpbml0aTVvMmcxazFzdGl0dXRlNnVyYW5jZTRlNHQwZXJuYXRpb25hbDEwdWl0NHZlc3RtZW50czEwbzFwaXJhbmdhN3ExcjBpc2g0czBtYWlsaTV0MGFuYnVsN3QwYXUydjNqYWd1YXI0dmEzY2IyZTBlcDJ0enQzd2Vscnk2aW8ybGwybTBwMm5qMm8wYnMxdXJnNHQxeTJwMG1vcmdhbjZyczN1ZWdvczRuaXBlcjdrYXVmZW41ZGRpM2UwcnJ5aG90ZWxzNmxvZ2lzdGljczlwcm9wZXJ0aWVzMTRmaDJnMWgxaTBhMWRzMm0xbmRlcjJsZTR0Y2hlbjV3aTNtMW4xb2VsbjNtYXRzdTVzaGVyNXAwbWcybjJyMGQxZWQzdW9rZ3JvdXA4dzF5MG90bzR6MmxhMGNhaXhhNW1ib3JnaGluaThlcjNuY2FzdGVyNWlhM2Qwcm92ZXI2eGVzczVzYWxsZTV0MGlubzNyb2JlNXcweWVyNWIxYzFkczJlYXNlM2NsZXJjNWZyYWs0Z2FsMm8yeHVzNGdidDNpMGRsMmZlMGluc3VyYW5jZTlzdHlsZTdnaHRpbmc2a2UybGx5M21pdGVkNG8ybmNvbG40ZGUyazJwc3kzdmUxaW5nNWsxbGMxcDJvYW4wczNja2VyM3VzM2wxbmRvbjR0dGUxbzN2ZTNwbDBmaW5hbmNpYWwxMXIxczF0MGQwYTN1MG5kYmVjazZ4ZTF1cnk1djF5Mm1hMGN5czNkcmlkNGlmMXNvbjRrZXVwNG4wYWdlbWVudDdnbzNwMXJrZXQwaW5nM3M0cmlvdHQ1c2hhbGxzN3NlcmF0aTZ0dGVsNWJhMmMwa2luc2V5N2QxZTBkMGlhM2V0Mmxib3VybmU3bWUxb3JpYWw2bjB1MnJja21zZDdnMWgxaWFtaTNjcm9zb2Z0N2wxbmkxdDJ0MHN1YmlzaGk5azFsMGIxczJtMGEybjFvMGJpMGxlNGRhMmUxaTFtMW5hc2gzZXkyc3RlcjVybW9uM3RnYWdlNnNjb3c0dG8wcmN5Y2xlczl2MGllNHAxcTFyMXMwZDJ0MG4xcjJ1MHNldW0zaWMzdHVhbDV2MXcxeDF5MXoybmEwYjFnb3lhNG1lMnR1cmE0dnkzYmEyYzFlMGMxdDBiYW5rNGZsaXg0d29yazV1c3RhcjV3MHMyeHQwZGlyZWN0N3VzNGYwbDJnMG8yaGsyaTBjbzJrZTFvbjNuamEzc3NhbjF5NWwxbzBraWEzcnRod2VzdGVybm11dHVhbDE0b240dzBydXozdHY0cDFyMGExdzJ0dDJ1MXljMnoyb2JpMXNlcnZlcjdmZmljZTVraW5hd2E2bGF5YW4wZ3JvdXA5ZG5hdnk1bG8zbTBlZ2E0bmUxZzFsMGluZTVvbzJwZW4zcmFjbGUzbmdlNGcwYW5pYzVpZ2luczZzYWthNHRzdWthNHQydmgzcGEwZ2UybmFzb25pYzdyaXMyczF0bmVyczRzMXkzc3NhZ2Vuczd5MmNjdzNlMHQyZjBpemVyNWcxaDBhcm1hY3k2ZDFpbGlwczVvbmUydG8wZ3JhcGh5NnM0eXNpbzVpY3MxdGV0MnVyZXM2ZDFuMGcxazJvbmVlcjV6emE0azFsMGFjZTJ5MHN0YXRpb245dW1iaW5nNXMzbTFuMGMyb2hsMmtlcjNsaXRpZTVybjJzdDNyMGFtZXJpY2E2eGkzZXNzM2ltZTNvMGQwdWN0aW9uczhmMWdyZXNzaXZlOG1vMnBlcnRpZXMzeTV0ZWN0aW9uOHUwZGVudGlhbDlzMXQxdWIydzBjMnkycWExcG9uM3VlYmVjM3N0NXJhY2luZzRkaW80ZTBhZDFsZXN0YXRlNnRvcjJ5NGNpcGVzNWQwc3RvbmU1dW1icmVsbGE5aGFiM2lzZTBuM3QybGlhbmNlNm4wdDBhbHM1cGFpcjNvcnQzdWJsaWNhbjhzdDBhdXJhbnQ4dmlldzBzNXhyb3RoNmljaDBhcmRsaTZvaDNsMW8xcDJvMGNoZXIza3MzZGVvM2dlcnM0b20zczB2cDN1MGdieTNocjJuMncwZTJ5dWt5dTZzYTBhcmxhbmQ2ZmUwdHk0a3VyYTRsZTFvbjNtc2NsdWI0dW5nNW5kdmlrMGNvcm9tYW50MTJvZmk0cDFybDJzMXZlMnhvM2IwaTFzMmMwYTFiMWhhZWZmbGVyN21pZHQ0b2xhcnNoaXBzOG9sM3VsZTN3YXJ6NWllbmNlNW90M2QxZTBhcmNoM3QyY3VyZTFpdHk2ZWsybGVjdDRuZXIzcnZpY2VzNnZlbjN3MXgweTNmcjJnMWgwYW5ncmlsYTZycDJ3MmVsbDNpYTFrc2hhNW9lczJwMHBpbmc1dWppM3cwdGltZTdpMGxrMm5hMWdsZXM1dGUzajFrMGkwbjJ5MHBlNGwwaW5nNG0wYXJ0M2lsZTRuMGNmM28wY2NlcjNpYWw0ZnRiYW5rNHdhcmU2aHUybGFyMnV0aW9uczduZzF5MnkycGEwY2Uzb3J0MnQzcjBsMnMxdDBhZGEycGxlczRyMXRlYmFuazRmYXJtN2MwZ3JvdXA2b2NraG9sbTZyYWdlM2UzcmVhbTR1ZGlvMnkzeWxlNHUwY2tzM3BwbGllczN5Mm9ydDVyZjFnZXJ5NXp1a2k1djF3YXRjaDRpc3M0eDF5MGRuZXk0c3RlbXM2ejJ0YWIxaXBlaTRsazJvYmFvNHJnZXQ0dGFtb3RvcnM2cjJ0b280eDBpM2MwaTJkMGsyZWFtMmNoMG5vbG9neThsMW1hc2VrNW5uaXM0dmEzZjFnMWgwZDFlYXRlcjJyZTZpYWEyY2tldHM1ZW5kYTRmZmFueTVwczJyZXMyb2w0ajBtYXh4NHgyazBtYXh4NWwxbTBhbGw0bjFvMGRheTNreW8zb2xzM3AxcmF5M3NoaWJhNXRhbDN1cnMzd24yeW90YTNzM3IwYWRlMWluZzRpbmluZzV2ZWwwY2hhbm5lbDdlcnMwaW5zdXJhbmNlMTZ1c3QzdjJ0MXViZTJpMW5lczNzaHU0djBzMncxejJ1YTFiYW5rM3MyZzFrMW5pY29tM3ZlcnNpdHk4bzJvbDJwczJzMXkxejJ2YTBjYXRpb25zN25hMWd1YXJkN2MxZTBnYXMzbnR1cmVzNnJpc2lnbjVtw7ZnZW5zYmVyYXRlcjJ1bmcxNHNpY2hlcnVuZzEwdDJnMWkwYWplczRkZW8zZzFraW5nNGxsYXM0bjFwMXJnaW40c2ExaW9uNHZhMW8zbGFhbmRlcmVuOW4xb2RrYTNsa3N3YWdlbjd2bzN0ZTFpbmczbzJ5YWdlNXUwZWxvczZ3YWxlczJtYXJ0NHRlcjRuZzBnb3U1dGNoMGVzNmVhdGhlcjBjaGFubmVsMTJiY2FtM2VyMnNpdGU1ZDBkaW5nNWlibzJyM2YxaG9zd2hvNmllbjJraTJsbGlhbWhpbGw5bjBkb3dzNGUxbmVyczZtZTJvbHRlcnNrbHV3ZXIxMW9kc2lkZTZyazBzMmxkM3cyczF0YzFmM3hib3gzZXJveDRmaW5pdHk2aWh1YW40bjJ4eDJ5ejN5YWNodHM0aG9vM21heHVuNW5kZXg1ZTFvZG9iYXNoaTdnYTJrb2hhbWE2dTB0dWJlNnQxdW4zemEwcHBvczRyYTNlcm8zaXAybTFvbmUzdWVyaWNoNncyJztcbi8vIEludGVybmF0aW9uYWxpemVkIGRvbWFpbiBuYW1lcyBjb250YWluaW5nIG5vbi1BU0NJSVxuY29uc3QgZW5jb2RlZFV0bGRzID0gJ861zrsxz4Uy0LHQszHQtdC7M9C00LXRgtC4NNC10Y4y0LrQsNGC0L7Qu9C40Lo20L7QvDPQvNC60LQy0L7QvTHRgdC60LLQsDbQvtC90LvQsNC50L010YDQszPRgNGD0YEy0YQy0YHQsNC50YIz0YDQsTPRg9C60YAz0pvQsNC3M9Ww1aHVtTPXmdep16jXkNecNden15XXnTPYp9io2YjYuNio2Yo12KrYtdin2YTYp9iqNtix2KfZhdmD2Yg12YTYp9ix2K/ZhjTYqNit2LHZitmGNdis2LLYp9im2LE12LPYudmI2K/ZitipNti52YTZitin2YY12YXYutix2Kg12YXYp9ix2KfYqjXbjNix2KfZhjXYqNin2LHYqjLYstin2LE02YrYqtmDM9q+2KfYsdiqNdiq2YjZhtizNNiz2YjYr9in2YYz2LHZitipNdi02KjZg9ipNNi52LHYp9mCMtioMtmF2KfZhjTZgdmE2LPYt9mK2YY22YLYt9ixM9mD2KfYq9mI2YTZitmDNtmI2YUz2YXYtdixMtmE2YrYs9mK2Kc12YjYsdmK2KrYp9mG2YrYpzfZgti5NNmH2YXYsdin2Yc12b7Yp9qp2LPYqtin2YY32oDYp9ix2Ko04KSV4KWJ4KSuM+CkqOClh+CknzPgpK3gpL7gpLDgpKQw4KSu4KWNM+Cli+CkpDXgpLjgpILgpJfgpKDgpKg14Kas4Ka+4KaC4Kay4Ka+NeCmreCmvuCmsOCmpDLgp7DgpqQ04Kit4Ki+4Kiw4KikNOCqreCqvuCqsOCqpDTgrK3grL7grLDgrKQ04K6H4K6o4K+N4K6k4K6/4K6v4K6+NuCusuCumeCvjeCuleCviDbgrprgrr/grpngr43grpXgrqrgr43grqrgr4LgrrDgr40xMeCwreCwvuCwsOCwpOCxjTXgsq3gsr7gsrDgsqQ04LSt4LS+4LSw4LSk4LSCNeC2veC2guC2muC3jzTguITguK3guKEz4LmE4LiX4LiiM+C6peC6suC6pzPhg5Lhg5Qy44G/44KT44GqM+OCouODnuOCvuODszTjgq/jg6njgqbjg4k044Kw44O844Kw44OrNOOCs+ODoDLjgrnjg4jjgqIz44K744O844OrM+ODleOCoeODg+OCt+ODp+ODszbjg53jgqTjg7Pjg4g05LiW55WMMuS4reS/oTHlm70x5ZyLMeaWh+e9kTPkuprpqazpgIoz5LyB5LiaMuS9m+WxsTLkv6Hmga8y5YGl5bq3MuWFq+WNpjLlhazlj7gx55uKMuWPsOa5vjHngaMy5ZWG5Z+OMeW6lzHmoIcy5ZiJ6YeMMOWkp+mFkuW6lzXlnKjnur8y5aSn5ou/MuWkqeS4u+aVmTPlqLHkuZAy5a626Zu7MuW5v+S4nDLlvq7ljZoy5oWI5ZaEMuaIkeeIseS9oDPmiYvmnLoy5oub6IGYMuaUv+WKoTHlupwy5paw5Yqg5Z2hMumXuzLml7blsJoy5pu457GNMuacuuaehDLmt6HpqazplKEz5ri45oiPMua+s+mWgDLngrnnnIsy56e75YqoMue7hOe7h+acuuaehDTnvZHlnYAx5bqXMeermTHnu5wy6IGU6YCaMuiwt+atjDLotK3niaky6YCa6LKpMumbhuWbojLpm7voqIrnm4jnp5E06aOe5Yip5rWmM+mjn+WTgTLppJDljoUy6aaZ5qC86YeM5ouJM+a4rzLri7frhLcx7Lu0MuyCvOyEsTLtlZzqta0yJztcblxuLyoqXG4gKiBAdGVtcGxhdGUgQVxuICogQHRlbXBsYXRlIEJcbiAqIEBwYXJhbSB7QX0gdGFyZ2V0XG4gKiBAcGFyYW0ge0J9IHByb3BlcnRpZXNcbiAqIEByZXR1cm4ge0EgJiBCfVxuICovXG5jb25zdCBhc3NpZ24gPSAodGFyZ2V0LCBwcm9wZXJ0aWVzKSA9PiB7XG4gIGZvciAoY29uc3Qga2V5IGluIHByb3BlcnRpZXMpIHtcbiAgICB0YXJnZXRba2V5XSA9IHByb3BlcnRpZXNba2V5XTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuLyoqXG4gKiBGaW5pdGUgU3RhdGUgTWFjaGluZSBnZW5lcmF0aW9uIHV0aWxpdGllc1xuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0eXBlZGVmIHt7IFtncm91cDogc3RyaW5nXTogVFtdIH19IENvbGxlY3Rpb25zXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7eyBbZ3JvdXA6IHN0cmluZ106IHRydWUgfX0gRmxhZ3NcbiAqL1xuXG4vLyBLZXlzIGluIHNjYW5uZXIgQ29sbGVjdGlvbnMgaW5zdGFuY2VzXG5jb25zdCBudW1lcmljID0gJ251bWVyaWMnO1xuY29uc3QgYXNjaWkgPSAnYXNjaWknO1xuY29uc3QgYWxwaGEgPSAnYWxwaGEnO1xuY29uc3QgYXNjaWludW1lcmljID0gJ2FzY2lpbnVtZXJpYyc7XG5jb25zdCBhbHBoYW51bWVyaWMgPSAnYWxwaGFudW1lcmljJztcbmNvbnN0IGRvbWFpbiA9ICdkb21haW4nO1xuY29uc3QgZW1vamkgPSAnZW1vamknO1xuY29uc3Qgc2NoZW1lID0gJ3NjaGVtZSc7XG5jb25zdCBzbGFzaHNjaGVtZSA9ICdzbGFzaHNjaGVtZSc7XG5jb25zdCB3aGl0ZXNwYWNlID0gJ3doaXRlc3BhY2UnO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtDb2xsZWN0aW9uczxUPn0gZ3JvdXBzIHRvIHJlZ2lzdGVyIGluXG4gKiBAcmV0dXJucyB7VFtdfSBDdXJyZW50IGxpc3Qgb2YgdG9rZW5zIGluIHRoZSBnaXZlbiBjb2xsZWN0aW9uXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyR3JvdXAobmFtZSwgZ3JvdXBzKSB7XG4gIGlmICghKG5hbWUgaW4gZ3JvdXBzKSkge1xuICAgIGdyb3Vwc1tuYW1lXSA9IFtdO1xuICB9XG4gIHJldHVybiBncm91cHNbbmFtZV07XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VH0gdCB0b2tlbiB0byBhZGRcbiAqIEBwYXJhbSB7Q29sbGVjdGlvbnM8VD59IGdyb3Vwc1xuICogQHBhcmFtIHtGbGFnc30gZmxhZ3NcbiAqL1xuZnVuY3Rpb24gYWRkVG9Hcm91cHModCwgZmxhZ3MsIGdyb3Vwcykge1xuICBpZiAoZmxhZ3NbbnVtZXJpY10pIHtcbiAgICBmbGFnc1thc2NpaW51bWVyaWNdID0gdHJ1ZTtcbiAgICBmbGFnc1thbHBoYW51bWVyaWNdID0gdHJ1ZTtcbiAgfVxuICBpZiAoZmxhZ3NbYXNjaWldKSB7XG4gICAgZmxhZ3NbYXNjaWludW1lcmljXSA9IHRydWU7XG4gICAgZmxhZ3NbYWxwaGFdID0gdHJ1ZTtcbiAgfVxuICBpZiAoZmxhZ3NbYXNjaWludW1lcmljXSkge1xuICAgIGZsYWdzW2FscGhhbnVtZXJpY10gPSB0cnVlO1xuICB9XG4gIGlmIChmbGFnc1thbHBoYV0pIHtcbiAgICBmbGFnc1thbHBoYW51bWVyaWNdID0gdHJ1ZTtcbiAgfVxuICBpZiAoZmxhZ3NbYWxwaGFudW1lcmljXSkge1xuICAgIGZsYWdzW2RvbWFpbl0gPSB0cnVlO1xuICB9XG4gIGlmIChmbGFnc1tlbW9qaV0pIHtcbiAgICBmbGFnc1tkb21haW5dID0gdHJ1ZTtcbiAgfVxuICBmb3IgKGNvbnN0IGsgaW4gZmxhZ3MpIHtcbiAgICBjb25zdCBncm91cCA9IHJlZ2lzdGVyR3JvdXAoaywgZ3JvdXBzKTtcbiAgICBpZiAoZ3JvdXAuaW5kZXhPZih0KSA8IDApIHtcbiAgICAgIGdyb3VwLnB1c2godCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VH0gdCB0b2tlbiB0byBjaGVja1xuICogQHBhcmFtIHtDb2xsZWN0aW9uczxUPn0gZ3JvdXBzXG4gKiBAcmV0dXJucyB7RmxhZ3N9IGdyb3VwIGZsYWdzIHRoYXQgY29udGFpbiB0aGlzIHRva2VuXG4gKi9cbmZ1bmN0aW9uIGZsYWdzRm9yVG9rZW4odCwgZ3JvdXBzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBmb3IgKGNvbnN0IGMgaW4gZ3JvdXBzKSB7XG4gICAgaWYgKGdyb3Vwc1tjXS5pbmRleE9mKHQpID49IDApIHtcbiAgICAgIHJlc3VsdFtjXSA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0eXBlZGVmIHtudWxsIHwgVCB9IFRyYW5zaXRpb25cbiAqL1xuXG4vKipcbiAqIERlZmluZSBhIGJhc2ljIHN0YXRlIG1hY2hpbmUgc3RhdGUuIGogaXMgdGhlIGxpc3Qgb2YgY2hhcmFjdGVyIHRyYW5zaXRpb25zLFxuICoganIgaXMgdGhlIGxpc3Qgb2YgcmVnZXgtbWF0Y2ggdHJhbnNpdGlvbnMsIGpkIGlzIHRoZSBkZWZhdWx0IHN0YXRlIHRvXG4gKiB0cmFuc2l0aW9uIHRvIHQgaXMgdGhlIGFjY2VwdGluZyB0b2tlbiB0eXBlLCBpZiBhbnkuIElmIHRoaXMgaXMgdGhlIHRlcm1pbmFsXG4gKiBzdGF0ZSwgdGhlbiBpdCBkb2VzIG5vdCBlbWl0IGEgdG9rZW4uXG4gKlxuICogVGhlIHRlbXBsYXRlIHR5cGUgVCByZXByZXNlbnRzIHRoZSB0eXBlIG9mIHRoZSB0b2tlbiB0aGlzIHN0YXRlIGFjY2VwdHMuIFRoaXNcbiAqIHNob3VsZCBiZSBhIHN0cmluZyAoc3VjaCBhcyBvZiB0aGUgdG9rZW4gZXhwb3J0cyBpbiBgdGV4dC5qc2ApIG9yIGFcbiAqIE11bHRpVG9rZW4gc3ViY2xhc3MgKGZyb20gYG11bHRpLmpzYClcbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUfSBbdG9rZW5dIFRva2VuIHRoYXQgdGhpcyBzdGF0ZSBlbWl0c1xuICovXG5mdW5jdGlvbiBTdGF0ZSh0b2tlbikge1xuICBpZiAodG9rZW4gPT09IHZvaWQgMCkge1xuICAgIHRva2VuID0gbnVsbDtcbiAgfVxuICAvLyB0aGlzLm4gPSBudWxsOyAvLyBERUJVRzogU3RhdGUgbmFtZVxuICAvKiogQHR5cGUge3sgW2lucHV0OiBzdHJpbmddOiBTdGF0ZTxUPiB9fSBqICovXG4gIHRoaXMuaiA9IHt9OyAvLyBJTVBMRU1FTlRBVElPTiAxXG4gIC8vIHRoaXMuaiA9IFtdOyAvLyBJTVBMRU1FTlRBVElPTiAyXG4gIC8qKiBAdHlwZSB7W1JlZ0V4cCwgU3RhdGU8VD5dW119IGpyICovXG4gIHRoaXMuanIgPSBbXTtcbiAgLyoqIEB0eXBlIHs/U3RhdGU8VD59IGpkICovXG4gIHRoaXMuamQgPSBudWxsO1xuICAvKiogQHR5cGUgez9UfSB0ICovXG4gIHRoaXMudCA9IHRva2VuO1xufVxuXG4vKipcbiAqIFNjYW5uZXIgdG9rZW4gZ3JvdXBzXG4gKiBAdHlwZSBDb2xsZWN0aW9uczxzdHJpbmc+XG4gKi9cblN0YXRlLmdyb3VwcyA9IHt9O1xuU3RhdGUucHJvdG90eXBlID0ge1xuICBhY2NlcHRzKCkge1xuICAgIHJldHVybiAhIXRoaXMudDtcbiAgfSxcbiAgLyoqXG4gICAqIEZvbGxvdyBhbiBleGlzdGluZyB0cmFuc2l0aW9uIGZyb20gdGhlIGdpdmVuIGlucHV0IHRvIHRoZSBuZXh0IHN0YXRlLlxuICAgKiBEb2VzIG5vdCBtdXRhdGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCBjaGFyYWN0ZXIgb3IgdG9rZW4gdHlwZSB0byB0cmFuc2l0aW9uIG9uXG4gICAqIEByZXR1cm5zIHs/U3RhdGU8VD59IHRoZSBuZXh0IHN0YXRlLCBpZiBhbnlcbiAgICovXG4gIGdvKGlucHV0KSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzO1xuICAgIGNvbnN0IG5leHRTdGF0ZSA9IHN0YXRlLmpbaW5wdXRdO1xuICAgIGlmIChuZXh0U3RhdGUpIHtcbiAgICAgIHJldHVybiBuZXh0U3RhdGU7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGUuanIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHJlZ2V4ID0gc3RhdGUuanJbaV1bMF07XG4gICAgICBjb25zdCBuZXh0U3RhdGUgPSBzdGF0ZS5qcltpXVsxXTsgLy8gbm90ZTogbWlnaHQgYmUgZW1wdHkgdG8gcHJldmVudCBkZWZhdWx0IGp1bXBcbiAgICAgIGlmIChuZXh0U3RhdGUgJiYgcmVnZXgudGVzdChpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIG5leHRTdGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gTm93aGVyZSBsZWZ0IHRvIGp1bXAhIFJldHVybiBkZWZhdWx0LCBpZiBhbnlcbiAgICByZXR1cm4gc3RhdGUuamQ7XG4gIH0sXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBzdGF0ZSBoYXMgYSB0cmFuc2l0aW9uIGZvciB0aGUgZ2l2ZW4gaW5wdXQuIFNldCB0aGUgc2Vjb25kXG4gICAqIGFyZ3VtZW50IHRvIHRydWUgdG8gb25seSBsb29rIGZvciBhbiBleGFjdCBtYXRjaCAoYW5kIG5vdCBhIGRlZmF1bHQgb3JcbiAgICogcmVndWxhci1leHByZXNzaW9uLWJhc2VkIHRyYW5zaXRpb24pXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGV4YWN0T25seVxuICAgKi9cbiAgaGFzKGlucHV0LCBleGFjdE9ubHkpIHtcbiAgICBpZiAoZXhhY3RPbmx5ID09PSB2b2lkIDApIHtcbiAgICAgIGV4YWN0T25seSA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZXhhY3RPbmx5ID8gaW5wdXQgaW4gdGhpcy5qIDogISF0aGlzLmdvKGlucHV0KTtcbiAgfSxcbiAgLyoqXG4gICAqIFNob3J0IGZvciBcInRyYW5zaXRpb24gYWxsXCI7IGNyZWF0ZSBhIHRyYW5zaXRpb24gZnJvbSB0aGUgYXJyYXkgb2YgaXRlbXNcbiAgICogaW4gdGhlIGdpdmVuIGxpc3QgdG8gdGhlIHNhbWUgZmluYWwgcmVzdWx0aW5nIHN0YXRlLlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHN0cmluZ1tdfSBpbnB1dHMgR3JvdXAgb2YgaW5wdXRzIHRvIHRyYW5zaXRpb24gb25cbiAgICogQHBhcmFtIHtUcmFuc2l0aW9uPFQ+IHwgU3RhdGU8VD59IFtuZXh0XSBUcmFuc2l0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtGbGFnc30gW2ZsYWdzXSBDb2xsZWN0aW9ucyBmbGFncyB0byBhZGQgdG9rZW4gdG9cbiAgICogQHBhcmFtIHtDb2xsZWN0aW9uczxUPn0gW2dyb3Vwc10gTWFzdGVyIGxpc3Qgb2YgdG9rZW4gZ3JvdXBzXG4gICAqL1xuICB0YShpbnB1dHMsIG5leHQsIGZsYWdzLCBncm91cHMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy50dChpbnB1dHNbaV0sIG5leHQsIGZsYWdzLCBncm91cHMpO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIFNob3J0IGZvciBcInRha2UgcmVnZXhwIHRyYW5zaXRpb25cIjsgZGVmaW5lcyBhIHRyYW5zaXRpb24gZm9yIHRoaXMgc3RhdGVcbiAgICogd2hlbiBpdCBlbmNvdW50ZXJzIGEgdG9rZW4gd2hpY2ggbWF0Y2hlcyB0aGUgZ2l2ZW4gcmVndWxhciBleHByZXNzaW9uXG4gICAqIEBwYXJhbSB7UmVnRXhwfSByZWdleHAgUmVndWxhciBleHByZXNzaW9uIHRyYW5zaXRpb24gKHBvcHVsYXRlIGZpcnN0KVxuICAgKiBAcGFyYW0ge1QgfCBTdGF0ZTxUPn0gW25leHRdIFRyYW5zaXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0ZsYWdzfSBbZmxhZ3NdIENvbGxlY3Rpb25zIGZsYWdzIHRvIGFkZCB0b2tlbiB0b1xuICAgKiBAcGFyYW0ge0NvbGxlY3Rpb25zPFQ+fSBbZ3JvdXBzXSBNYXN0ZXIgbGlzdCBvZiB0b2tlbiBncm91cHNcbiAgICogQHJldHVybnMge1N0YXRlPFQ+fSB0YWtlbiBhZnRlciB0aGUgZ2l2ZW4gaW5wdXRcbiAgICovXG4gIHRyKHJlZ2V4cCwgbmV4dCwgZmxhZ3MsIGdyb3Vwcykge1xuICAgIGdyb3VwcyA9IGdyb3VwcyB8fCBTdGF0ZS5ncm91cHM7XG4gICAgbGV0IG5leHRTdGF0ZTtcbiAgICBpZiAobmV4dCAmJiBuZXh0LmopIHtcbiAgICAgIG5leHRTdGF0ZSA9IG5leHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRva2VuIHdpdGggbWF5YmUgdG9rZW4gZ3JvdXBzXG4gICAgICBuZXh0U3RhdGUgPSBuZXcgU3RhdGUobmV4dCk7XG4gICAgICBpZiAoZmxhZ3MgJiYgZ3JvdXBzKSB7XG4gICAgICAgIGFkZFRvR3JvdXBzKG5leHQsIGZsYWdzLCBncm91cHMpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmpyLnB1c2goW3JlZ2V4cCwgbmV4dFN0YXRlXSk7XG4gICAgcmV0dXJuIG5leHRTdGF0ZTtcbiAgfSxcbiAgLyoqXG4gICAqIFNob3J0IGZvciBcInRha2UgdHJhbnNpdGlvbnNcIiwgd2lsbCB0YWtlIGFzIG1hbnkgc2VxdWVudGlhbCB0cmFuc2l0aW9ucyBhc1xuICAgKiB0aGUgbGVuZ3RoIG9mIHRoZSBnaXZlbiBpbnB1dCBhbmQgcmV0dXJucyB0aGVcbiAgICogcmVzdWx0aW5nIGZpbmFsIHN0YXRlLlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHN0cmluZ1tdfSBpbnB1dFxuICAgKiBAcGFyYW0ge1QgfCBTdGF0ZTxUPn0gW25leHRdIFRyYW5zaXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0ZsYWdzfSBbZmxhZ3NdIENvbGxlY3Rpb25zIGZsYWdzIHRvIGFkZCB0b2tlbiB0b1xuICAgKiBAcGFyYW0ge0NvbGxlY3Rpb25zPFQ+fSBbZ3JvdXBzXSBNYXN0ZXIgbGlzdCBvZiB0b2tlbiBncm91cHNcbiAgICogQHJldHVybnMge1N0YXRlPFQ+fSB0YWtlbiBhZnRlciB0aGUgZ2l2ZW4gaW5wdXRcbiAgICovXG4gIHRzKGlucHV0LCBuZXh0LCBmbGFncywgZ3JvdXBzKSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcztcbiAgICBjb25zdCBsZW4gPSBpbnB1dC5sZW5ndGg7XG4gICAgaWYgKCFsZW4pIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcbiAgICAgIHN0YXRlID0gc3RhdGUudHQoaW5wdXRbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGUudHQoaW5wdXRbbGVuIC0gMV0sIG5leHQsIGZsYWdzLCBncm91cHMpO1xuICB9LFxuICAvKipcbiAgICogU2hvcnQgZm9yIFwidGFrZSB0cmFuc2l0aW9uXCIsIHRoaXMgaXMgYSBtZXRob2QgZm9yIGJ1aWxkaW5nL3dvcmtpbmcgd2l0aFxuICAgKiBzdGF0ZSBtYWNoaW5lcy5cbiAgICpcbiAgICogSWYgYSBzdGF0ZSBhbHJlYWR5IGV4aXN0cyBmb3IgdGhlIGdpdmVuIGlucHV0LCByZXR1cm5zIGl0LlxuICAgKlxuICAgKiBJZiBhIHRva2VuIGlzIHNwZWNpZmllZCwgdGhhdCBzdGF0ZSB3aWxsIGVtaXQgdGhhdCB0b2tlbiB3aGVuIHJlYWNoZWQgYnlcbiAgICogdGhlIGxpbmtpZnkgZW5naW5lLlxuICAgKlxuICAgKiBJZiBubyBzdGF0ZSBleGlzdHMsIGl0IHdpbGwgYmUgaW5pdGlhbGl6ZWQgd2l0aCBzb21lIGRlZmF1bHQgdHJhbnNpdGlvbnNcbiAgICogdGhhdCByZXNlbWJsZSBleGlzdGluZyBkZWZhdWx0IHRyYW5zaXRpb25zLlxuICAgKlxuICAgKiBJZiBhIHN0YXRlIGlzIGdpdmVuIGZvciB0aGUgc2Vjb25kIGFyZ3VtZW50LCB0aGF0IHN0YXRlIHdpbGwgYmVcbiAgICogdHJhbnNpdGlvbmVkIHRvIG9uIHRoZSBnaXZlbiBpbnB1dCByZWdhcmRsZXNzIG9mIHdoYXQgdGhhdCBpbnB1dFxuICAgKiBwcmV2aW91c2x5IGRpZC5cbiAgICpcbiAgICogU3BlY2lmeSBhIHRva2VuIGdyb3VwIGZsYWdzIHRvIGRlZmluZSBncm91cHMgdGhhdCB0aGlzIHRva2VuIGJlbG9uZ3MgdG8uXG4gICAqIFRoZSB0b2tlbiB3aWxsIGJlIGFkZGVkIHRvIGNvcnJlc3BvbmRpbmcgZW50aXJlcyBpbiB0aGUgZ2l2ZW4gZ3JvdXBzXG4gICAqIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0IGNoYXJhY3RlciwgdG9rZW4gdHlwZSB0byB0cmFuc2l0aW9uIG9uXG4gICAqIEBwYXJhbSB7VCB8IFN0YXRlPFQ+fSBbbmV4dF0gVHJhbnNpdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7RmxhZ3N9IFtmbGFnc10gQ29sbGVjdGlvbnMgZmxhZ3MgdG8gYWRkIHRva2VuIHRvXG4gICAqIEBwYXJhbSB7Q29sbGVjdGlvbnM8VD59IFtncm91cHNdIE1hc3RlciBsaXN0IG9mIGdyb3Vwc1xuICAgKiBAcmV0dXJucyB7U3RhdGU8VD59IHRha2VuIGFmdGVyIHRoZSBnaXZlbiBpbnB1dFxuICAgKi9cbiAgdHQoaW5wdXQsIG5leHQsIGZsYWdzLCBncm91cHMpIHtcbiAgICBncm91cHMgPSBncm91cHMgfHwgU3RhdGUuZ3JvdXBzO1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcztcblxuICAgIC8vIENoZWNrIGlmIGV4aXN0aW5nIHN0YXRlIGdpdmVuLCBqdXN0IGEgYmFzaWMgdHJhbnNpdGlvblxuICAgIGlmIChuZXh0ICYmIG5leHQuaikge1xuICAgICAgc3RhdGUualtpbnB1dF0gPSBuZXh0O1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfVxuICAgIGNvbnN0IHQgPSBuZXh0O1xuXG4gICAgLy8gVGFrZSB0aGUgdHJhbnNpdGlvbiB3aXRoIHRoZSB1c3VhbCBkZWZhdWx0IG1lY2hhbmlzbXMgYW5kIHVzZSB0aGF0IGFzXG4gICAgLy8gYSB0ZW1wbGF0ZSBmb3IgY3JlYXRpbmcgdGhlIG5leHQgc3RhdGVcbiAgICBsZXQgbmV4dFN0YXRlLFxuICAgICAgdGVtcGxhdGVTdGF0ZSA9IHN0YXRlLmdvKGlucHV0KTtcbiAgICBpZiAodGVtcGxhdGVTdGF0ZSkge1xuICAgICAgbmV4dFN0YXRlID0gbmV3IFN0YXRlKCk7XG4gICAgICBhc3NpZ24obmV4dFN0YXRlLmosIHRlbXBsYXRlU3RhdGUuaik7XG4gICAgICBuZXh0U3RhdGUuanIucHVzaC5hcHBseShuZXh0U3RhdGUuanIsIHRlbXBsYXRlU3RhdGUuanIpO1xuICAgICAgbmV4dFN0YXRlLmpkID0gdGVtcGxhdGVTdGF0ZS5qZDtcbiAgICAgIG5leHRTdGF0ZS50ID0gdGVtcGxhdGVTdGF0ZS50O1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0U3RhdGUgPSBuZXcgU3RhdGUoKTtcbiAgICB9XG4gICAgaWYgKHQpIHtcbiAgICAgIC8vIEVuc3VyZSBuZXdseSB0b2tlbiBpcyBpbiB0aGUgc2FtZSBncm91cHMgYXMgdGhlIG9sZCB0b2tlblxuICAgICAgaWYgKGdyb3Vwcykge1xuICAgICAgICBpZiAobmV4dFN0YXRlLnQgJiYgdHlwZW9mIG5leHRTdGF0ZS50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGNvbnN0IGFsbEZsYWdzID0gYXNzaWduKGZsYWdzRm9yVG9rZW4obmV4dFN0YXRlLnQsIGdyb3VwcyksIGZsYWdzKTtcbiAgICAgICAgICBhZGRUb0dyb3Vwcyh0LCBhbGxGbGFncywgZ3JvdXBzKTtcbiAgICAgICAgfSBlbHNlIGlmIChmbGFncykge1xuICAgICAgICAgIGFkZFRvR3JvdXBzKHQsIGZsYWdzLCBncm91cHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBuZXh0U3RhdGUudCA9IHQ7IC8vIG92ZXJ3cml0ZSBhbnl0aGluZyB0aGF0IHdhcyBwcmV2aW91c2x5IHRoZXJlXG4gICAgfVxuXG4gICAgc3RhdGUualtpbnB1dF0gPSBuZXh0U3RhdGU7XG4gICAgcmV0dXJuIG5leHRTdGF0ZTtcbiAgfVxufTtcblxuLy8gSGVscGVyIGZ1bmN0aW9ucyB0byBpbXByb3ZlIG1pbmlmaWNhdGlvbiAobm90IGV4cG9ydGVkIG91dHNpZGUgbGlua2lmeWpzIG1vZHVsZSlcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtTdGF0ZTxUPn0gc3RhdGVcbiAqIEBwYXJhbSB7c3RyaW5nIHwgc3RyaW5nW119IGlucHV0XG4gKiBAcGFyYW0ge0ZsYWdzfSBbZmxhZ3NdXG4gKiBAcGFyYW0ge0NvbGxlY3Rpb25zPFQ+fSBbZ3JvdXBzXVxuICovXG5jb25zdCB0YSA9IChzdGF0ZSwgaW5wdXQsIG5leHQsIGZsYWdzLCBncm91cHMpID0+IHN0YXRlLnRhKGlucHV0LCBuZXh0LCBmbGFncywgZ3JvdXBzKTtcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtTdGF0ZTxUPn0gc3RhdGVcbiAqIEBwYXJhbSB7UmVnRXhwfSByZWdleHBcbiAqIEBwYXJhbSB7VCB8IFN0YXRlPFQ+fSBbbmV4dF1cbiAqIEBwYXJhbSB7RmxhZ3N9IFtmbGFnc11cbiAqIEBwYXJhbSB7Q29sbGVjdGlvbnM8VD59IFtncm91cHNdXG4gKi9cbmNvbnN0IHRyID0gKHN0YXRlLCByZWdleHAsIG5leHQsIGZsYWdzLCBncm91cHMpID0+IHN0YXRlLnRyKHJlZ2V4cCwgbmV4dCwgZmxhZ3MsIGdyb3Vwcyk7XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7U3RhdGU8VD59IHN0YXRlXG4gKiBAcGFyYW0ge3N0cmluZyB8IHN0cmluZ1tdfSBpbnB1dFxuICogQHBhcmFtIHtUIHwgU3RhdGU8VD59IFtuZXh0XVxuICogQHBhcmFtIHtGbGFnc30gW2ZsYWdzXVxuICogQHBhcmFtIHtDb2xsZWN0aW9uczxUPn0gW2dyb3Vwc11cbiAqL1xuY29uc3QgdHMgPSAoc3RhdGUsIGlucHV0LCBuZXh0LCBmbGFncywgZ3JvdXBzKSA9PiBzdGF0ZS50cyhpbnB1dCwgbmV4dCwgZmxhZ3MsIGdyb3Vwcyk7XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7U3RhdGU8VD59IHN0YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRcbiAqIEBwYXJhbSB7VCB8IFN0YXRlPFQ+fSBbbmV4dF1cbiAqIEBwYXJhbSB7Q29sbGVjdGlvbnM8VD59IFtncm91cHNdXG4gKiBAcGFyYW0ge0ZsYWdzfSBbZmxhZ3NdXG4gKi9cbmNvbnN0IHR0ID0gKHN0YXRlLCBpbnB1dCwgbmV4dCwgZmxhZ3MsIGdyb3VwcykgPT4gc3RhdGUudHQoaW5wdXQsIG5leHQsIGZsYWdzLCBncm91cHMpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5UZXh0IFRva2Vuc1xuSWRlbnRpZmllcnMgZm9yIHRva2VuIG91dHB1dHMgZnJvbSB0aGUgcmVnZXhwIHNjYW5uZXJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLy8gQSB2YWxpZCB3ZWIgZG9tYWluIHRva2VuXG5jb25zdCBXT1JEID0gJ1dPUkQnOyAvLyBvbmx5IGNvbnRhaW5zIGEtelxuY29uc3QgVVdPUkQgPSAnVVdPUkQnOyAvLyBjb250YWlucyBsZXR0ZXJzIG90aGVyIHRoYW4gYS16LCB1c2VkIGZvciBJRE5cblxuLy8gU3BlY2lhbCBjYXNlIG9mIHdvcmRcbmNvbnN0IExPQ0FMSE9TVCA9ICdMT0NBTEhPU1QnO1xuXG4vLyBWYWxpZCB0b3AtbGV2ZWwgZG9tYWluLCBzcGVjaWFsIGNhc2Ugb2YgV09SRCAoc2VlIHRsZHMuanMpXG5jb25zdCBUTEQgPSAnVExEJztcblxuLy8gVmFsaWQgSUROIFRMRCwgc3BlY2lhbCBjYXNlIG9mIFVXT1JEIChzZWUgdGxkcy5qcylcbmNvbnN0IFVUTEQgPSAnVVRMRCc7XG5cbi8vIFRoZSBzY2hlbWUgcG9ydGlvbiBvZiBhIHdlYiBVUkkgcHJvdG9jb2wuIFN1cHBvcnRlZCB0eXBlcyBpbmNsdWRlOiBgbWFpbHRvYCxcbi8vIGBmaWxlYCwgYW5kIHVzZXItZGVmaW5lZCBjdXN0b20gcHJvdG9jb2xzLiBMaW1pdGVkIHRvIHNjaGVtZXMgdGhhdCBjb250YWluXG4vLyBvbmx5IGxldHRlcnNcbmNvbnN0IFNDSEVNRSA9ICdTQ0hFTUUnO1xuXG4vLyBTaW1pbGFyIHRvIFNDSEVNRSwgZXhjZXB0IG1ha2VzIGRpc3RpbmN0aW9uIGZvciBzY2hlbWVzIHRoYXQgbXVzdCBhbHdheXMgYmVcbi8vIGZvbGxvd2VkIGJ5IGA6Ly9gLCBub3QganVzdCBgOmAuIFN1cHBvcnRlZCB0eXBlcyBpbmNsdWRlIGBodHRwYCwgYGh0dHBzYCxcbi8vIGBmdHBgLCBgZnRwc2BcbmNvbnN0IFNMQVNIX1NDSEVNRSA9ICdTTEFTSF9TQ0hFTUUnO1xuXG4vLyBBbnkgc2VxdWVuY2Ugb2YgZGlnaXRzIDAtOVxuY29uc3QgTlVNID0gJ05VTSc7XG5cbi8vIEFueSBudW1iZXIgb2YgY29uc2VjdXRpdmUgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHRoYXQgYXJlIG5vdCBuZXdsaW5lXG5jb25zdCBXUyA9ICdXUyc7XG5cbi8vIE5ldyBsaW5lICh1bml4IHN0eWxlKVxuY29uc3QgTkwkMSA9ICdOTCc7IC8vIFxcblxuXG4vLyBPcGVuaW5nL2Nsb3NpbmcgYnJhY2tldCBjbGFzc2VzXG5jb25zdCBPUEVOQlJBQ0UgPSAnT1BFTkJSQUNFJzsgLy8ge1xuY29uc3QgT1BFTkJSQUNLRVQgPSAnT1BFTkJSQUNLRVQnOyAvLyBbXG5jb25zdCBPUEVOQU5HTEVCUkFDS0VUID0gJ09QRU5BTkdMRUJSQUNLRVQnOyAvLyA8XG5jb25zdCBPUEVOUEFSRU4gPSAnT1BFTlBBUkVOJzsgLy8gKFxuY29uc3QgQ0xPU0VCUkFDRSA9ICdDTE9TRUJSQUNFJzsgLy8gfVxuY29uc3QgQ0xPU0VCUkFDS0VUID0gJ0NMT1NFQlJBQ0tFVCc7IC8vIF1cbmNvbnN0IENMT1NFQU5HTEVCUkFDS0VUID0gJ0NMT1NFQU5HTEVCUkFDS0VUJzsgLy8gPlxuY29uc3QgQ0xPU0VQQVJFTiA9ICdDTE9TRVBBUkVOJzsgLy8gKVxuXG4vLyBWYXJpb3VzIHN5bWJvbHNcbmNvbnN0IEFNUEVSU0FORCA9ICdBTVBFUlNBTkQnOyAvLyAmXG5jb25zdCBBUE9TVFJPUEhFID0gJ0FQT1NUUk9QSEUnOyAvLyAnXG5jb25zdCBBU1RFUklTSyA9ICdBU1RFUklTSyc7IC8vICpcbmNvbnN0IEFUID0gJ0FUJzsgLy8gQFxuY29uc3QgQkFDS1NMQVNIID0gJ0JBQ0tTTEFTSCc7IC8vIFxcXG5jb25zdCBCQUNLVElDSyA9ICdCQUNLVElDSyc7IC8vIGBcbmNvbnN0IENBUkVUID0gJ0NBUkVUJzsgLy8gXlxuY29uc3QgQ09MT04gPSAnQ09MT04nOyAvLyA6XG5jb25zdCBDT01NQSA9ICdDT01NQSc7IC8vICxcbmNvbnN0IERPTExBUiA9ICdET0xMQVInOyAvLyAkXG5jb25zdCBET1QgPSAnRE9UJzsgLy8gLlxuY29uc3QgRVFVQUxTID0gJ0VRVUFMUyc7IC8vID1cbmNvbnN0IEVYQ0xBTUFUSU9OID0gJ0VYQ0xBTUFUSU9OJzsgLy8gIVxuY29uc3QgSFlQSEVOID0gJ0hZUEhFTic7IC8vIC1cbmNvbnN0IFBFUkNFTlQgPSAnUEVSQ0VOVCc7IC8vICVcbmNvbnN0IFBJUEUgPSAnUElQRSc7IC8vIHxcbmNvbnN0IFBMVVMgPSAnUExVUyc7IC8vICtcbmNvbnN0IFBPVU5EID0gJ1BPVU5EJzsgLy8gI1xuY29uc3QgUVVFUlkgPSAnUVVFUlknOyAvLyA/XG5jb25zdCBRVU9URSA9ICdRVU9URSc7IC8vIFwiXG5cbmNvbnN0IFNFTUkgPSAnU0VNSSc7IC8vIDtcbmNvbnN0IFNMQVNIID0gJ1NMQVNIJzsgLy8gL1xuY29uc3QgVElMREUgPSAnVElMREUnOyAvLyB+XG5jb25zdCBVTkRFUlNDT1JFID0gJ1VOREVSU0NPUkUnOyAvLyBfXG5cbi8vIEVtb2ppIHN5bWJvbFxuY29uc3QgRU1PSkkkMSA9ICdFTU9KSSc7XG5cbi8vIERlZmF1bHQgdG9rZW4gLSBhbnl0aGluZyB0aGF0IGlzIG5vdCBvbmUgb2YgdGhlIGFib3ZlXG5jb25zdCBTWU0gPSAnU1lNJztcblxudmFyIHRrID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRfX3Byb3RvX186IG51bGwsXG5cdFdPUkQ6IFdPUkQsXG5cdFVXT1JEOiBVV09SRCxcblx0TE9DQUxIT1NUOiBMT0NBTEhPU1QsXG5cdFRMRDogVExELFxuXHRVVExEOiBVVExELFxuXHRTQ0hFTUU6IFNDSEVNRSxcblx0U0xBU0hfU0NIRU1FOiBTTEFTSF9TQ0hFTUUsXG5cdE5VTTogTlVNLFxuXHRXUzogV1MsXG5cdE5MOiBOTCQxLFxuXHRPUEVOQlJBQ0U6IE9QRU5CUkFDRSxcblx0T1BFTkJSQUNLRVQ6IE9QRU5CUkFDS0VULFxuXHRPUEVOQU5HTEVCUkFDS0VUOiBPUEVOQU5HTEVCUkFDS0VULFxuXHRPUEVOUEFSRU46IE9QRU5QQVJFTixcblx0Q0xPU0VCUkFDRTogQ0xPU0VCUkFDRSxcblx0Q0xPU0VCUkFDS0VUOiBDTE9TRUJSQUNLRVQsXG5cdENMT1NFQU5HTEVCUkFDS0VUOiBDTE9TRUFOR0xFQlJBQ0tFVCxcblx0Q0xPU0VQQVJFTjogQ0xPU0VQQVJFTixcblx0QU1QRVJTQU5EOiBBTVBFUlNBTkQsXG5cdEFQT1NUUk9QSEU6IEFQT1NUUk9QSEUsXG5cdEFTVEVSSVNLOiBBU1RFUklTSyxcblx0QVQ6IEFULFxuXHRCQUNLU0xBU0g6IEJBQ0tTTEFTSCxcblx0QkFDS1RJQ0s6IEJBQ0tUSUNLLFxuXHRDQVJFVDogQ0FSRVQsXG5cdENPTE9OOiBDT0xPTixcblx0Q09NTUE6IENPTU1BLFxuXHRET0xMQVI6IERPTExBUixcblx0RE9UOiBET1QsXG5cdEVRVUFMUzogRVFVQUxTLFxuXHRFWENMQU1BVElPTjogRVhDTEFNQVRJT04sXG5cdEhZUEhFTjogSFlQSEVOLFxuXHRQRVJDRU5UOiBQRVJDRU5ULFxuXHRQSVBFOiBQSVBFLFxuXHRQTFVTOiBQTFVTLFxuXHRQT1VORDogUE9VTkQsXG5cdFFVRVJZOiBRVUVSWSxcblx0UVVPVEU6IFFVT1RFLFxuXHRTRU1JOiBTRU1JLFxuXHRTTEFTSDogU0xBU0gsXG5cdFRJTERFOiBUSUxERSxcblx0VU5ERVJTQ09SRTogVU5ERVJTQ09SRSxcblx0RU1PSkk6IEVNT0pJJDEsXG5cdFNZTTogU1lNXG59KTtcblxuLy8gTm90ZSB0aGF0IHRoZXNlIHR3byBVbmljb2RlIG9uZXMgZXhwYW5kIGludG8gYSByZWFsbHkgYmlnIG9uZSB3aXRoIEJhYmVsXG5jb25zdCBBU0NJSV9MRVRURVIgPSAvW2Etel0vO1xuY29uc3QgTEVUVEVSID0gL1xccHtMfS91OyAvLyBBbnkgVW5pY29kZSBjaGFyYWN0ZXIgd2l0aCBsZXR0ZXIgZGF0YSB0eXBlXG5jb25zdCBFTU9KSSA9IC9cXHB7RW1vaml9L3U7IC8vIEFueSBVbmljb2RlIGVtb2ppIGNoYXJhY3RlclxuY29uc3QgRU1PSklfVkFSSUFUSU9OJDEgPSAvXFx1ZmUwZi87XG5jb25zdCBESUdJVCA9IC9cXGQvO1xuY29uc3QgU1BBQ0UgPSAvXFxzLztcblxudmFyIHJlZ2V4cCA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0X19wcm90b19fOiBudWxsLFxuXHRBU0NJSV9MRVRURVI6IEFTQ0lJX0xFVFRFUixcblx0TEVUVEVSOiBMRVRURVIsXG5cdEVNT0pJOiBFTU9KSSxcblx0RU1PSklfVkFSSUFUSU9OOiBFTU9KSV9WQVJJQVRJT04kMSxcblx0RElHSVQ6IERJR0lULFxuXHRTUEFDRTogU1BBQ0Vcbn0pO1xuXG4vKipcblx0VGhlIHNjYW5uZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIHRoYXQgdGFrZXMgYSBzdHJpbmcgb2YgdGV4dCBhcyBpbnB1dCwgYW5kXG5cdG91dHB1dHMgYW4gYXJyYXkgb2YgdG9rZW5zIGluc3RhbmNlcyB0aGF0IGNhbiBiZSB1c2VkIGZvciBlYXN5IFVSTCBwYXJzaW5nLlxuKi9cbmNvbnN0IE5MID0gJ1xcbic7IC8vIE5ldyBsaW5lIGNoYXJhY3RlclxuY29uc3QgRU1PSklfVkFSSUFUSU9OID0gJ1xcdWZlMGYnOyAvLyBWYXJpYXRpb24gc2VsZWN0b3IsIGZvbGxvd3MgaGVhcnQgYW5kIG90aGVyc1xuY29uc3QgRU1PSklfSk9JTkVSID0gJ1xcdTIwMGQnOyAvLyB6ZXJvLXdpZHRoIGpvaW5lclxuXG5sZXQgdGxkcyA9IG51bGwsXG4gIHV0bGRzID0gbnVsbDsgLy8gZG9uJ3QgY2hhbmdlIHNvIG9ubHkgaGF2ZSB0byBiZSBjb21wdXRlZCBvbmNlXG5cbi8qKlxuICogU2Nhbm5lciBvdXRwdXQgdG9rZW46XG4gKiAtIGB0YCBpcyB0aGUgdG9rZW4gbmFtZSAoZS5nLiwgJ05VTScsICdFTU9KSScsICdUTEQnKVxuICogLSBgdmAgaXMgdGhlIHZhbHVlIG9mIHRoZSB0b2tlbiAoZS5nLiwgJzEyMycsICfinaTvuI8nLCAnY29tJylcbiAqIC0gYHNgIGlzIHRoZSBzdGFydCBpbmRleCBvZiB0aGUgdG9rZW4gaW4gdGhlIG9yaWdpbmFsIHN0cmluZ1xuICogLSBgZWAgaXMgdGhlIGVuZCBpbmRleCBvZiB0aGUgdG9rZW4gaW4gdGhlIG9yaWdpbmFsIHN0cmluZ1xuICogQHR5cGVkZWYge3t0OiBzdHJpbmcsIHY6IHN0cmluZywgczogbnVtYmVyLCBlOiBudW1iZXJ9fSBUb2tlblxuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0eXBlZGVmIHt7IFtjb2xsZWN0aW9uOiBzdHJpbmddOiBUW10gfX0gQ29sbGVjdGlvbnNcbiAqL1xuXG4vKipcbiAqIEluaXRpYWxpemUgdGhlIHNjYW5uZXIgY2hhcmFjdGVyLWJhc2VkIHN0YXRlIG1hY2hpbmUgZm9yIHRoZSBnaXZlbiBzdGFydFxuICogc3RhdGVcbiAqIEBwYXJhbSB7W3N0cmluZywgYm9vbGVhbl1bXX0gY3VzdG9tU2NoZW1lcyBMaXN0IG9mIGN1c3RvbSBzY2hlbWVzLCB3aGVyZSBlYWNoXG4gKiBpdGVtIGlzIGEgbGVuZ3RoLTIgdHVwbGUgd2l0aCB0aGUgZmlyc3QgZWxlbWVudCBzZXQgdG8gdGhlIHN0cmluZyBzY2hlbWUsIGFuZFxuICogdGhlIHNlY29uZCBlbGVtZW50IHNldCB0byBgdHJ1ZWAgaWYgdGhlIGA6Ly9gIGFmdGVyIHRoZSBzY2hlbWUgaXMgb3B0aW9uYWxcbiAqL1xuZnVuY3Rpb24gaW5pdCQyKGN1c3RvbVNjaGVtZXMpIHtcbiAgaWYgKGN1c3RvbVNjaGVtZXMgPT09IHZvaWQgMCkge1xuICAgIGN1c3RvbVNjaGVtZXMgPSBbXTtcbiAgfVxuICAvLyBGcmVxdWVudGx5IHVzZWQgc3RhdGVzIChuYW1lIGFyZ3VtZW50IHJlbW92ZWQgZHVyaW5nIG1pbmlmaWNhdGlvbilcbiAgLyoqIEB0eXBlIENvbGxlY3Rpb25zPHN0cmluZz4gKi9cbiAgY29uc3QgZ3JvdXBzID0ge307IC8vIG9mIHRva2Vuc1xuICBTdGF0ZS5ncm91cHMgPSBncm91cHM7XG4gIC8qKiBAdHlwZSBTdGF0ZTxzdHJpbmc+ICovXG4gIGNvbnN0IFN0YXJ0ID0gbmV3IFN0YXRlKCk7XG4gIGlmICh0bGRzID09IG51bGwpIHtcbiAgICB0bGRzID0gZGVjb2RlVGxkcyhlbmNvZGVkVGxkcyk7XG4gIH1cbiAgaWYgKHV0bGRzID09IG51bGwpIHtcbiAgICB1dGxkcyA9IGRlY29kZVRsZHMoZW5jb2RlZFV0bGRzKTtcbiAgfVxuXG4gIC8vIFN0YXRlcyBmb3Igc3BlY2lhbCBVUkwgc3ltYm9scyB0aGF0IGFjY2VwdCBpbW1lZGlhdGVseSBhZnRlciBzdGFydFxuICB0dChTdGFydCwgXCInXCIsIEFQT1NUUk9QSEUpO1xuICB0dChTdGFydCwgJ3snLCBPUEVOQlJBQ0UpO1xuICB0dChTdGFydCwgJ1snLCBPUEVOQlJBQ0tFVCk7XG4gIHR0KFN0YXJ0LCAnPCcsIE9QRU5BTkdMRUJSQUNLRVQpO1xuICB0dChTdGFydCwgJygnLCBPUEVOUEFSRU4pO1xuICB0dChTdGFydCwgJ30nLCBDTE9TRUJSQUNFKTtcbiAgdHQoU3RhcnQsICddJywgQ0xPU0VCUkFDS0VUKTtcbiAgdHQoU3RhcnQsICc+JywgQ0xPU0VBTkdMRUJSQUNLRVQpO1xuICB0dChTdGFydCwgJyknLCBDTE9TRVBBUkVOKTtcbiAgdHQoU3RhcnQsICcmJywgQU1QRVJTQU5EKTtcbiAgdHQoU3RhcnQsICcqJywgQVNURVJJU0spO1xuICB0dChTdGFydCwgJ0AnLCBBVCk7XG4gIHR0KFN0YXJ0LCAnYCcsIEJBQ0tUSUNLKTtcbiAgdHQoU3RhcnQsICdeJywgQ0FSRVQpO1xuICB0dChTdGFydCwgJzonLCBDT0xPTik7XG4gIHR0KFN0YXJ0LCAnLCcsIENPTU1BKTtcbiAgdHQoU3RhcnQsICckJywgRE9MTEFSKTtcbiAgdHQoU3RhcnQsICcuJywgRE9UKTtcbiAgdHQoU3RhcnQsICc9JywgRVFVQUxTKTtcbiAgdHQoU3RhcnQsICchJywgRVhDTEFNQVRJT04pO1xuICB0dChTdGFydCwgJy0nLCBIWVBIRU4pO1xuICB0dChTdGFydCwgJyUnLCBQRVJDRU5UKTtcbiAgdHQoU3RhcnQsICd8JywgUElQRSk7XG4gIHR0KFN0YXJ0LCAnKycsIFBMVVMpO1xuICB0dChTdGFydCwgJyMnLCBQT1VORCk7XG4gIHR0KFN0YXJ0LCAnPycsIFFVRVJZKTtcbiAgdHQoU3RhcnQsICdcIicsIFFVT1RFKTtcbiAgdHQoU3RhcnQsICcvJywgU0xBU0gpO1xuICB0dChTdGFydCwgJzsnLCBTRU1JKTtcbiAgdHQoU3RhcnQsICd+JywgVElMREUpO1xuICB0dChTdGFydCwgJ18nLCBVTkRFUlNDT1JFKTtcbiAgdHQoU3RhcnQsICdcXFxcJywgQkFDS1NMQVNIKTtcbiAgY29uc3QgTnVtID0gdHIoU3RhcnQsIERJR0lULCBOVU0sIHtcbiAgICBbbnVtZXJpY106IHRydWVcbiAgfSk7XG4gIHRyKE51bSwgRElHSVQsIE51bSk7XG5cbiAgLy8gU3RhdGUgd2hpY2ggZW1pdHMgYSB3b3JkIHRva2VuXG4gIGNvbnN0IFdvcmQgPSB0cihTdGFydCwgQVNDSUlfTEVUVEVSLCBXT1JELCB7XG4gICAgW2FzY2lpXTogdHJ1ZVxuICB9KTtcbiAgdHIoV29yZCwgQVNDSUlfTEVUVEVSLCBXb3JkKTtcblxuICAvLyBTYW1lIGFzIHByZXZpb3VzLCBidXQgc3BlY2lmaWMgdG8gbm9uLWZzbS5hc2NpaSBhbHBoYWJldCB3b3Jkc1xuICBjb25zdCBVV29yZCA9IHRyKFN0YXJ0LCBMRVRURVIsIFVXT1JELCB7XG4gICAgW2FscGhhXTogdHJ1ZVxuICB9KTtcbiAgdHIoVVdvcmQsIEFTQ0lJX0xFVFRFUik7IC8vIE5vbi1hY2NlcHRpbmdcbiAgdHIoVVdvcmQsIExFVFRFUiwgVVdvcmQpO1xuXG4gIC8vIFdoaXRlc3BhY2UganVtcHNcbiAgLy8gVG9rZW5zIG9mIG9ubHkgbm9uLW5ld2xpbmUgd2hpdGVzcGFjZSBhcmUgYXJiaXRyYXJpbHkgbG9uZ1xuICAvLyBJZiBhbnkgd2hpdGVzcGFjZSBleGNlcHQgbmV3bGluZSwgbW9yZSB3aGl0ZXNwYWNlIVxuICBjb25zdCBXcyA9IHRyKFN0YXJ0LCBTUEFDRSwgV1MsIHtcbiAgICBbd2hpdGVzcGFjZV06IHRydWVcbiAgfSk7XG4gIHR0KFN0YXJ0LCBOTCwgTkwkMSwge1xuICAgIFt3aGl0ZXNwYWNlXTogdHJ1ZVxuICB9KTtcbiAgdHQoV3MsIE5MKTsgLy8gbm9uLWFjY2VwdGluZyBzdGF0ZSB0byBhdm9pZCBtaXhpbmcgd2hpdGVzcGFjZXNcbiAgdHIoV3MsIFNQQUNFLCBXcyk7XG5cbiAgLy8gRW1vamkgdG9rZW5zLiBUaGV5IGFyZSBub3QgZ3JvdXBlZCBieSB0aGUgc2Nhbm5lciBleGNlcHQgaW4gY2FzZXMgd2hlcmUgYVxuICAvLyB6ZXJvLXdpZHRoIGpvaW5lciBpcyBwcmVzZW50XG4gIGNvbnN0IEVtb2ppID0gdHIoU3RhcnQsIEVNT0pJLCBFTU9KSSQxLCB7XG4gICAgW2Vtb2ppXTogdHJ1ZVxuICB9KTtcbiAgdHIoRW1vamksIEVNT0pJLCBFbW9qaSk7XG4gIHR0KEVtb2ppLCBFTU9KSV9WQVJJQVRJT04sIEVtb2ppKTtcbiAgLy8gdHQoU3RhcnQsIEVNT0pJX1ZBUklBVElPTiwgRW1vamkpOyAvLyBUaGlzIG9uZSBpcyBza2V0Y2h5XG5cbiAgY29uc3QgRW1vamlKb2luZXIgPSB0dChFbW9qaSwgRU1PSklfSk9JTkVSKTtcbiAgdHIoRW1vamlKb2luZXIsIEVNT0pJLCBFbW9qaSk7XG4gIC8vIHR0KEVtb2ppSm9pbmVyLCBFTU9KSV9WQVJJQVRJT04sIEVtb2ppKTsgLy8gYWxzbyBza2V0Y2h5XG5cbiAgLy8gR2VuZXJhdGVzIHN0YXRlcyBmb3IgdG9wLWxldmVsIGRvbWFpbnNcbiAgLy8gTm90ZSB0aGF0IHRoaXMgaXMgbW9zdCBhY2N1cmF0ZSB3aGVuIHRsZHMgYXJlIGluIGFscGhhYmV0aWNhbCBvcmRlclxuICBjb25zdCB3b3JkanIgPSBbW0FTQ0lJX0xFVFRFUiwgV29yZF1dO1xuICBjb25zdCB1d29yZGpyID0gW1tBU0NJSV9MRVRURVIsIG51bGxdLCBbTEVUVEVSLCBVV29yZF1dO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRsZHMubGVuZ3RoOyBpKyspIHtcbiAgICBmYXN0dHMoU3RhcnQsIHRsZHNbaV0sIFRMRCwgV09SRCwgd29yZGpyKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHV0bGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgZmFzdHRzKFN0YXJ0LCB1dGxkc1tpXSwgVVRMRCwgVVdPUkQsIHV3b3JkanIpO1xuICB9XG4gIGFkZFRvR3JvdXBzKFRMRCwge1xuICAgIHRsZDogdHJ1ZSxcbiAgICBhc2NpaTogdHJ1ZVxuICB9LCBncm91cHMpO1xuICBhZGRUb0dyb3VwcyhVVExELCB7XG4gICAgdXRsZDogdHJ1ZSxcbiAgICBhbHBoYTogdHJ1ZVxuICB9LCBncm91cHMpO1xuXG4gIC8vIENvbGxlY3QgdGhlIHN0YXRlcyBnZW5lcmF0ZWQgYnkgZGlmZmVyZW50IHByb3RvY29scy4gTk9URTogSWYgYW55IG5ldyBUTERzXG4gIC8vIGdldCBhZGRlZCB0aGF0IGFyZSBhbHNvIHByb3RvY29scywgc2V0IHRoZSB0b2tlbiB0byBiZSB0aGUgc2FtZSBhcyB0aGVcbiAgLy8gcHJvdG9jb2wgdG8gZW5zdXJlIHBhcnNpbmcgd29ya3MgYXMgZXhwZWN0ZWQuXG4gIGZhc3R0cyhTdGFydCwgJ2ZpbGUnLCBTQ0hFTUUsIFdPUkQsIHdvcmRqcik7XG4gIGZhc3R0cyhTdGFydCwgJ21haWx0bycsIFNDSEVNRSwgV09SRCwgd29yZGpyKTtcbiAgZmFzdHRzKFN0YXJ0LCAnaHR0cCcsIFNMQVNIX1NDSEVNRSwgV09SRCwgd29yZGpyKTtcbiAgZmFzdHRzKFN0YXJ0LCAnaHR0cHMnLCBTTEFTSF9TQ0hFTUUsIFdPUkQsIHdvcmRqcik7XG4gIGZhc3R0cyhTdGFydCwgJ2Z0cCcsIFNMQVNIX1NDSEVNRSwgV09SRCwgd29yZGpyKTtcbiAgZmFzdHRzKFN0YXJ0LCAnZnRwcycsIFNMQVNIX1NDSEVNRSwgV09SRCwgd29yZGpyKTtcbiAgYWRkVG9Hcm91cHMoU0NIRU1FLCB7XG4gICAgc2NoZW1lOiB0cnVlLFxuICAgIGFzY2lpOiB0cnVlXG4gIH0sIGdyb3Vwcyk7XG4gIGFkZFRvR3JvdXBzKFNMQVNIX1NDSEVNRSwge1xuICAgIHNsYXNoc2NoZW1lOiB0cnVlLFxuICAgIGFzY2lpOiB0cnVlXG4gIH0sIGdyb3Vwcyk7XG5cbiAgLy8gUmVnaXN0ZXIgY3VzdG9tIHNjaGVtZXMuIEFzc3VtZXMgZWFjaCBzY2hlbWUgaXMgYXNjaWludW1lcmljIHdpdGggaHlwaGVuc1xuICBjdXN0b21TY2hlbWVzID0gY3VzdG9tU2NoZW1lcy5zb3J0KChhLCBiKSA9PiBhWzBdID4gYlswXSA/IDEgOiAtMSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY3VzdG9tU2NoZW1lcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNjaCA9IGN1c3RvbVNjaGVtZXNbaV1bMF07XG4gICAgY29uc3Qgb3B0aW9uYWxTbGFzaFNsYXNoID0gY3VzdG9tU2NoZW1lc1tpXVsxXTtcbiAgICBjb25zdCBmbGFncyA9IG9wdGlvbmFsU2xhc2hTbGFzaCA/IHtcbiAgICAgIFtzY2hlbWVdOiB0cnVlXG4gICAgfSA6IHtcbiAgICAgIFtzbGFzaHNjaGVtZV06IHRydWVcbiAgICB9O1xuICAgIGlmIChzY2guaW5kZXhPZignLScpID49IDApIHtcbiAgICAgIGZsYWdzW2RvbWFpbl0gPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoIUFTQ0lJX0xFVFRFUi50ZXN0KHNjaCkpIHtcbiAgICAgIGZsYWdzW251bWVyaWNdID0gdHJ1ZTsgLy8gbnVtYmVycyBvbmx5XG4gICAgfSBlbHNlIGlmIChESUdJVC50ZXN0KHNjaCkpIHtcbiAgICAgIGZsYWdzW2FzY2lpbnVtZXJpY10gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmbGFnc1thc2NpaV0gPSB0cnVlO1xuICAgIH1cbiAgICB0cyhTdGFydCwgc2NoLCBzY2gsIGZsYWdzKTtcbiAgfVxuXG4gIC8vIExvY2FsaG9zdCB0b2tlblxuICB0cyhTdGFydCwgJ2xvY2FsaG9zdCcsIExPQ0FMSE9TVCwge1xuICAgIGFzY2lpOiB0cnVlXG4gIH0pO1xuXG4gIC8vIFNldCBkZWZhdWx0IHRyYW5zaXRpb24gZm9yIHN0YXJ0IHN0YXRlIChzb21lIHN5bWJvbClcbiAgU3RhcnQuamQgPSBuZXcgU3RhdGUoU1lNKTtcbiAgcmV0dXJuIHtcbiAgICBzdGFydDogU3RhcnQsXG4gICAgdG9rZW5zOiBhc3NpZ24oe1xuICAgICAgZ3JvdXBzXG4gICAgfSwgdGspXG4gIH07XG59XG5cbi8qKlxuXHRHaXZlbiBhIHN0cmluZywgcmV0dXJucyBhbiBhcnJheSBvZiBUT0tFTiBpbnN0YW5jZXMgcmVwcmVzZW50aW5nIHRoZVxuXHRjb21wb3NpdGlvbiBvZiB0aGF0IHN0cmluZy5cblxuXHRAbWV0aG9kIHJ1blxuXHRAcGFyYW0ge1N0YXRlPHN0cmluZz59IHN0YXJ0IHNjYW5uZXIgc3RhcnRpbmcgc3RhdGVcblx0QHBhcmFtIHtzdHJpbmd9IHN0ciBpbnB1dCBzdHJpbmcgdG8gc2NhblxuXHRAcmV0dXJuIHtUb2tlbltdfSBsaXN0IG9mIHRva2VucywgZWFjaCB3aXRoIGEgdHlwZSBhbmQgdmFsdWVcbiovXG5mdW5jdGlvbiBydW4kMShzdGFydCwgc3RyKSB7XG4gIC8vIFN0YXRlIG1hY2hpbmUgaXMgbm90IGNhc2Ugc2Vuc2l0aXZlLCBzbyBpbnB1dCBpcyB0b2tlbml6ZWQgaW4gbG93ZXJjYXNlZFxuICAvLyBmb3JtIChzdGlsbCByZXR1cm5zIHJlZ3VsYXIgY2FzZSkuIFVzZXMgc2VsZWN0aXZlIGB0b0xvd2VyQ2FzZWAgYmVjYXVzZVxuICAvLyBsb3dlcmNhc2luZyB0aGUgZW50aXJlIHN0cmluZyBjYXVzZXMgdGhlIGxlbmd0aCBhbmQgY2hhcmFjdGVyIHBvc2l0aW9uIHRvXG4gIC8vIHZhcnkgaW4gc29tZSBub24tRW5nbGlzaCBzdHJpbmdzIHdpdGggVjgtYmFzZWQgcnVudGltZXMuXG4gIGNvbnN0IGl0ZXJhYmxlID0gc3RyaW5nVG9BcnJheShzdHIucmVwbGFjZSgvW0EtWl0vZywgYyA9PiBjLnRvTG93ZXJDYXNlKCkpKTtcbiAgY29uc3QgY2hhckNvdW50ID0gaXRlcmFibGUubGVuZ3RoOyAvLyA8PSBsZW4gaWYgdGhlcmUgYXJlIGVtb2ppcywgZXRjXG4gIGNvbnN0IHRva2VucyA9IFtdOyAvLyByZXR1cm4gdmFsdWVcblxuICAvLyBjdXJzb3IgdGhyb3VnaCB0aGUgc3RyaW5nIGl0c2VsZiwgYWNjb3VudGluZyBmb3IgY2hhcmFjdGVycyB0aGF0IGhhdmVcbiAgLy8gd2lkdGggd2l0aCBsZW5ndGggMiBzdWNoIGFzIGVtb2ppc1xuICBsZXQgY3Vyc29yID0gMDtcblxuICAvLyBDdXJzb3IgdGhyb3VnaCB0aGUgYXJyYXktcmVwcmVzZW50YXRpb24gb2YgdGhlIHN0cmluZ1xuICBsZXQgY2hhckN1cnNvciA9IDA7XG5cbiAgLy8gVG9rZW5pemUgdGhlIHN0cmluZ1xuICB3aGlsZSAoY2hhckN1cnNvciA8IGNoYXJDb3VudCkge1xuICAgIGxldCBzdGF0ZSA9IHN0YXJ0O1xuICAgIGxldCBuZXh0U3RhdGUgPSBudWxsO1xuICAgIGxldCB0b2tlbkxlbmd0aCA9IDA7XG4gICAgbGV0IGxhdGVzdEFjY2VwdGluZyA9IG51bGw7XG4gICAgbGV0IHNpbmNlQWNjZXB0cyA9IC0xO1xuICAgIGxldCBjaGFyc1NpbmNlQWNjZXB0cyA9IC0xO1xuICAgIHdoaWxlIChjaGFyQ3Vyc29yIDwgY2hhckNvdW50ICYmIChuZXh0U3RhdGUgPSBzdGF0ZS5nbyhpdGVyYWJsZVtjaGFyQ3Vyc29yXSkpKSB7XG4gICAgICBzdGF0ZSA9IG5leHRTdGF0ZTtcblxuICAgICAgLy8gS2VlcCB0cmFjayBvZiB0aGUgbGF0ZXN0IGFjY2VwdGluZyBzdGF0ZVxuICAgICAgaWYgKHN0YXRlLmFjY2VwdHMoKSkge1xuICAgICAgICBzaW5jZUFjY2VwdHMgPSAwO1xuICAgICAgICBjaGFyc1NpbmNlQWNjZXB0cyA9IDA7XG4gICAgICAgIGxhdGVzdEFjY2VwdGluZyA9IHN0YXRlO1xuICAgICAgfSBlbHNlIGlmIChzaW5jZUFjY2VwdHMgPj0gMCkge1xuICAgICAgICBzaW5jZUFjY2VwdHMgKz0gaXRlcmFibGVbY2hhckN1cnNvcl0ubGVuZ3RoO1xuICAgICAgICBjaGFyc1NpbmNlQWNjZXB0cysrO1xuICAgICAgfVxuICAgICAgdG9rZW5MZW5ndGggKz0gaXRlcmFibGVbY2hhckN1cnNvcl0ubGVuZ3RoO1xuICAgICAgY3Vyc29yICs9IGl0ZXJhYmxlW2NoYXJDdXJzb3JdLmxlbmd0aDtcbiAgICAgIGNoYXJDdXJzb3IrKztcbiAgICB9XG5cbiAgICAvLyBSb2xsIGJhY2sgdG8gdGhlIGxhdGVzdCBhY2NlcHRpbmcgc3RhdGVcbiAgICBjdXJzb3IgLT0gc2luY2VBY2NlcHRzO1xuICAgIGNoYXJDdXJzb3IgLT0gY2hhcnNTaW5jZUFjY2VwdHM7XG4gICAgdG9rZW5MZW5ndGggLT0gc2luY2VBY2NlcHRzO1xuXG4gICAgLy8gTm8gbW9yZSBqdW1wcywganVzdCBtYWtlIGEgbmV3IHRva2VuIGZyb20gdGhlIGxhc3QgYWNjZXB0aW5nIG9uZVxuICAgIHRva2Vucy5wdXNoKHtcbiAgICAgIHQ6IGxhdGVzdEFjY2VwdGluZy50LFxuICAgICAgLy8gdG9rZW4gdHlwZS9uYW1lXG4gICAgICB2OiBzdHIuc2xpY2UoY3Vyc29yIC0gdG9rZW5MZW5ndGgsIGN1cnNvciksXG4gICAgICAvLyBzdHJpbmcgdmFsdWVcbiAgICAgIHM6IGN1cnNvciAtIHRva2VuTGVuZ3RoLFxuICAgICAgLy8gc3RhcnQgaW5kZXhcbiAgICAgIGU6IGN1cnNvciAvLyBlbmQgaW5kZXggKGV4Y2x1ZGluZylcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB0b2tlbnM7XG59XG5cbi8qKlxuICogQ29udmVydCBhIFN0cmluZyB0byBhbiBBcnJheSBvZiBjaGFyYWN0ZXJzLCB0YWtpbmcgaW50byBhY2NvdW50IHRoYXQgc29tZVxuICogY2hhcmFjdGVycyBsaWtlIGVtb2ppcyB0YWtlIHVwIHR3byBzdHJpbmcgaW5kZXhlcy5cbiAqXG4gKiBBZGFwdGVkIGZyb20gY29yZS1qcyAoTUlUIGxpY2Vuc2UpXG4gKiBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9ibG9iLzJkNjljZjVmOTlhYjNlYTM0NjNjMzk1ZGY4MWU1YTE1YjY4ZjQ5ZDkvcGFja2FnZXMvY29yZS1qcy9pbnRlcm5hbHMvc3RyaW5nLW11bHRpYnl0ZS5qc1xuICpcbiAqIEBmdW5jdGlvbiBzdHJpbmdUb0FycmF5XG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7c3RyaW5nW119XG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvQXJyYXkoc3RyKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBsZW4gPSBzdHIubGVuZ3RoO1xuICBsZXQgaW5kZXggPSAwO1xuICB3aGlsZSAoaW5kZXggPCBsZW4pIHtcbiAgICBsZXQgZmlyc3QgPSBzdHIuY2hhckNvZGVBdChpbmRleCk7XG4gICAgbGV0IHNlY29uZDtcbiAgICBsZXQgY2hhciA9IGZpcnN0IDwgMHhkODAwIHx8IGZpcnN0ID4gMHhkYmZmIHx8IGluZGV4ICsgMSA9PT0gbGVuIHx8IChzZWNvbmQgPSBzdHIuY2hhckNvZGVBdChpbmRleCArIDEpKSA8IDB4ZGMwMCB8fCBzZWNvbmQgPiAweGRmZmYgPyBzdHJbaW5kZXhdIC8vIHNpbmdsZSBjaGFyYWN0ZXJcbiAgICA6IHN0ci5zbGljZShpbmRleCwgaW5kZXggKyAyKTsgLy8gdHdvLWluZGV4IGNoYXJhY3RlcnNcbiAgICByZXN1bHQucHVzaChjaGFyKTtcbiAgICBpbmRleCArPSBjaGFyLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEZhc3QgdmVyc2lvbiBvZiB0cyBmdW5jdGlvbiBmb3Igd2hlbiB0cmFuc2l0aW9uIGRlZmF1bHRzIGFyZSB3ZWxsIGtub3duXG4gKiBAcGFyYW0ge1N0YXRlPHN0cmluZz59IHN0YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRcbiAqIEBwYXJhbSB7c3RyaW5nfSB0XG4gKiBAcGFyYW0ge3N0cmluZ30gZGVmYXVsdHRcbiAqIEBwYXJhbSB7W1JlZ0V4cCwgU3RhdGU8c3RyaW5nPl1bXX0ganJcbiAqIEByZXR1cm5zIHtTdGF0ZTxzdHJpbmc+fVxuICovXG5mdW5jdGlvbiBmYXN0dHMoc3RhdGUsIGlucHV0LCB0LCBkZWZhdWx0dCwganIpIHtcbiAgbGV0IG5leHQ7XG4gIGNvbnN0IGxlbiA9IGlucHV0Lmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcbiAgICBjb25zdCBjaGFyID0gaW5wdXRbaV07XG4gICAgaWYgKHN0YXRlLmpbY2hhcl0pIHtcbiAgICAgIG5leHQgPSBzdGF0ZS5qW2NoYXJdO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0ID0gbmV3IFN0YXRlKGRlZmF1bHR0KTtcbiAgICAgIG5leHQuanIgPSBqci5zbGljZSgpO1xuICAgICAgc3RhdGUualtjaGFyXSA9IG5leHQ7XG4gICAgfVxuICAgIHN0YXRlID0gbmV4dDtcbiAgfVxuICBuZXh0ID0gbmV3IFN0YXRlKHQpO1xuICBuZXh0LmpyID0ganIuc2xpY2UoKTtcbiAgc3RhdGUualtpbnB1dFtsZW4gLSAxXV0gPSBuZXh0O1xuICByZXR1cm4gbmV4dDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBUb3AtTGV2ZWwgRG9tYWluIG5hbWVzIGVuY29kZWQgaW4gdXBkYXRlLXRsZHMuanMgYmFja1xuICogaW50byBhIGxpc3Qgb2Ygc3RyaW5ncy5cbiAqIEBwYXJhbSB7c3RyfSBlbmNvZGVkIGVuY29kZWQgVExEcyBzdHJpbmdcbiAqIEByZXR1cm5zIHtzdHJbXX0gb3JpZ2luYWwgVExEcyBsaXN0XG4gKi9cbmZ1bmN0aW9uIGRlY29kZVRsZHMoZW5jb2RlZCkge1xuICBjb25zdCB3b3JkcyA9IFtdO1xuICBjb25zdCBzdGFjayA9IFtdO1xuICBsZXQgaSA9IDA7XG4gIGxldCBkaWdpdHMgPSAnMDEyMzQ1Njc4OSc7XG4gIHdoaWxlIChpIDwgZW5jb2RlZC5sZW5ndGgpIHtcbiAgICBsZXQgcG9wRGlnaXRDb3VudCA9IDA7XG4gICAgd2hpbGUgKGRpZ2l0cy5pbmRleE9mKGVuY29kZWRbaSArIHBvcERpZ2l0Q291bnRdKSA+PSAwKSB7XG4gICAgICBwb3BEaWdpdENvdW50Kys7IC8vIGVuY291bnRlcmVkIHNvbWUgZGlnaXRzLCBoYXZlIHRvIHBvcCB0byBnbyBvbmUgbGV2ZWwgdXAgdHJpZVxuICAgIH1cblxuICAgIGlmIChwb3BEaWdpdENvdW50ID4gMCkge1xuICAgICAgd29yZHMucHVzaChzdGFjay5qb2luKCcnKSk7IC8vIHdoYXRldmVyIHByZWNlZGVkIHRoZSBwb3AgZGlnaXRzIG11c3QgYmUgYSB3b3JkXG4gICAgICBmb3IgKGxldCBwb3BDb3VudCA9IHBhcnNlSW50KGVuY29kZWQuc3Vic3RyaW5nKGksIGkgKyBwb3BEaWdpdENvdW50KSwgMTApOyBwb3BDb3VudCA+IDA7IHBvcENvdW50LS0pIHtcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICB9XG4gICAgICBpICs9IHBvcERpZ2l0Q291bnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YWNrLnB1c2goZW5jb2RlZFtpXSk7IC8vIGRyb3AgZG93biBhIGxldmVsIGludG8gdGhlIHRyaWVcbiAgICAgIGkrKztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHdvcmRzO1xufVxuXG4vKipcbiAqIEFuIG9iamVjdCB3aGVyZSBlYWNoIGtleSBpcyBhIHZhbGlkIERPTSBFdmVudCBOYW1lIHN1Y2ggYXMgYGNsaWNrYCBvciBgZm9jdXNgXG4gKiBhbmQgZWFjaCB2YWx1ZSBpcyBhbiBldmVudCBoYW5kbGVyIGZ1bmN0aW9uLlxuICpcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50I2V2ZW50c1xuICogQHR5cGVkZWYgez97IFtldmVudDogc3RyaW5nXTogRnVuY3Rpb24gfX0gRXZlbnRMaXN0ZW5lcnNcbiAqL1xuXG4vKipcbiAqIEFsbCBmb3JtYXR0ZWQgcHJvcGVydGllcyByZXF1aXJlZCB0byByZW5kZXIgYSBsaW5rLCBpbmNsdWRpbmcgYHRhZ05hbWVgLFxuICogYGF0dHJpYnV0ZXNgLCBgY29udGVudGAgYW5kIGBldmVudExpc3RlbmVyc2AuXG4gKiBAdHlwZWRlZiB7eyB0YWdOYW1lOiBhbnksIGF0dHJpYnV0ZXM6IHtbYXR0cjogc3RyaW5nXTogYW55fSwgY29udGVudDogc3RyaW5nLFxuICogZXZlbnRMaXN0ZW5lcnM6IEV2ZW50TGlzdGVuZXJzIH19IEludGVybWVkaWF0ZVJlcHJlc2VudGF0aW9uXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZ5IGVpdGhlciBhbiBvYmplY3QgZGVzY3JpYmVkIGJ5IHRoZSB0ZW1wbGF0ZSB0eXBlIGBPYCBvciBhIGZ1bmN0aW9uLlxuICpcbiAqIFRoZSBmdW5jdGlvbiB0YWtlcyBhIHN0cmluZyB2YWx1ZSAodXN1YWxseSB0aGUgbGluaydzIGhyZWYgYXR0cmlidXRlKSwgdGhlXG4gKiBsaW5rIHR5cGUgKGAndXJsJ2AsIGAnaGFzaHRhZ2AnLCBldGMuKSBhbmQgYW4gaW50ZXJuYWwgdG9rZW4gcmVwcmVzZW50YXRpb25cbiAqIG9mIHRoZSBsaW5rLiBJdCBzaG91bGQgcmV0dXJuIGFuIG9iamVjdCBvZiB0aGUgdGVtcGxhdGUgdHlwZSBgT2BcbiAqIEB0ZW1wbGF0ZSBPXG4gKiBAdHlwZWRlZiB7TyB8ICgodmFsdWU6IHN0cmluZywgdHlwZTogc3RyaW5nLCB0b2tlbjogTXVsdGlUb2tlbikgPT4gTyl9IE9wdE9ialxuICovXG5cbi8qKlxuICogU3BlY2lmeSBlaXRoZXIgYSBmdW5jdGlvbiBkZXNjcmliZWQgYnkgdGVtcGxhdGUgdHlwZSBgRmAgb3IgYW4gb2JqZWN0LlxuICpcbiAqIEVhY2gga2V5IGluIHRoZSBvYmplY3Qgc2hvdWxkIGJlIGEgbGluayB0eXBlIChgJ3VybCdgLCBgJ2hhc2h0YWdgJywgZXRjLikuIEVhY2hcbiAqIHZhbHVlIHNob3VsZCBiZSBhIGZ1bmN0aW9uIHdpdGggdGVtcGxhdGUgdHlwZSBgRmAgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGVcbiAqIGNvcnJlc3BvbmRpbmcgbGluayB0eXBlIGlzIGVuY291bnRlcmVkLlxuICogQHRlbXBsYXRlIEZcbiAqIEB0eXBlZGVmIHtGIHwgeyBbdHlwZTogc3RyaW5nXTogRn19IE9wdEZuXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZ5IGVpdGhlciBhIHZhbHVlIHdpdGggdGVtcGxhdGUgdHlwZSBgVmAsIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGBWYCBvclxuICogYW4gb2JqZWN0IHdoZXJlIGVhY2ggdmFsdWUgcmVzb2x2ZXMgdG8gYFZgLlxuICpcbiAqIFRoZSBmdW5jdGlvbiB0YWtlcyBhIHN0cmluZyB2YWx1ZSAodXN1YWxseSB0aGUgbGluaydzIGhyZWYgYXR0cmlidXRlKSwgdGhlXG4gKiBsaW5rIHR5cGUgKGAndXJsJ2AsIGAnaGFzaHRhZ2AnLCBldGMuKSBhbmQgYW4gaW50ZXJuYWwgdG9rZW4gcmVwcmVzZW50YXRpb25cbiAqIG9mIHRoZSBsaW5rLiBJdCBzaG91bGQgcmV0dXJuIGFuIG9iamVjdCBvZiB0aGUgdGVtcGxhdGUgdHlwZSBgVmBcbiAqXG4gKiBGb3IgdGhlIG9iamVjdCwgZWFjaCBrZXkgc2hvdWxkIGJlIGEgbGluayB0eXBlIChgJ3VybCdgLCBgJ2hhc2h0YWdgJywgZXRjLikuXG4gKiBFYWNoIHZhbHVlIHNob3VsZCBlaXRoZXIgaGF2ZSB0eXBlIGBWYCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBWLiBUaGlzXG4gKiBmdW5jdGlvbiBzaW1pbGFybHkgdGFrZXMgYSBzdHJpbmcgdmFsdWUgYW5kIGEgdG9rZW4uXG4gKlxuICogRXhhbXBsZSB2YWxpZCB0eXBlcyBmb3IgYE9wdDxzdHJpbmc+YDpcbiAqXG4gKiBgYGBqc1xuICogJ2hlbGxvJ1xuICogKHZhbHVlLCB0eXBlLCB0b2tlbikgPT4gJ3dvcmxkJ1xuICogeyB1cmw6ICdoZWxsbycsIGVtYWlsOiAodmFsdWUsIHRva2VuKSA9PiAnd29ybGQnfVxuICogYGBgXG4gKiBAdGVtcGxhdGUgVlxuICogQHR5cGVkZWYge1YgfCAoKHZhbHVlOiBzdHJpbmcsIHR5cGU6IHN0cmluZywgdG9rZW46IE11bHRpVG9rZW4pID0+IFYpIHwgeyBbdHlwZTogc3RyaW5nXTogViB8ICgodmFsdWU6IHN0cmluZywgdG9rZW46IE11bHRpVG9rZW4pID0+IFYpIH19IE9wdFxuICovXG5cbi8qKlxuICogU2VlIGF2YWlsYWJsZSBvcHRpb25zOiBodHRwczovL2xpbmtpZnkuanMub3JnL2RvY3Mvb3B0aW9ucy5odG1sXG4gKiBAdHlwZWRlZiB7e1xuICogXHRkZWZhdWx0UHJvdG9jb2w/OiBzdHJpbmcsXG4gKiAgZXZlbnRzPzogT3B0T2JqPEV2ZW50TGlzdGVuZXJzPixcbiAqIFx0Zm9ybWF0PzogT3B0PHN0cmluZz4sXG4gKiBcdGZvcm1hdEhyZWY/OiBPcHQ8c3RyaW5nPixcbiAqIFx0bmwyYnI/OiBib29sZWFuLFxuICogXHR0YWdOYW1lPzogT3B0PGFueT4sXG4gKiBcdHRhcmdldD86IE9wdDxzdHJpbmc+LFxuICogXHRyZWw/OiBPcHQ8c3RyaW5nPixcbiAqIFx0dmFsaWRhdGU/OiBPcHQ8Ym9vbGVhbj4sXG4gKiBcdHRydW5jYXRlPzogT3B0PG51bWJlcj4sXG4gKiBcdGNsYXNzTmFtZT86IE9wdDxzdHJpbmc+LFxuICogXHRhdHRyaWJ1dGVzPzogT3B0T2JqPCh7IFthdHRyOiBzdHJpbmddOiBhbnkgfSk+LFxuICogIGlnbm9yZVRhZ3M/OiBzdHJpbmdbXSxcbiAqIFx0cmVuZGVyPzogT3B0Rm48KChpcjogSW50ZXJtZWRpYXRlUmVwcmVzZW50YXRpb24pID0+IGFueSk+XG4gKiB9fSBPcHRzXG4gKi9cblxuLyoqXG4gKiBAdHlwZSBSZXF1aXJlZDxPcHRzPlxuICovXG5jb25zdCBkZWZhdWx0cyA9IHtcbiAgZGVmYXVsdFByb3RvY29sOiAnaHR0cCcsXG4gIGV2ZW50czogbnVsbCxcbiAgZm9ybWF0OiBub29wLFxuICBmb3JtYXRIcmVmOiBub29wLFxuICBubDJicjogZmFsc2UsXG4gIHRhZ05hbWU6ICdhJyxcbiAgdGFyZ2V0OiBudWxsLFxuICByZWw6IG51bGwsXG4gIHZhbGlkYXRlOiB0cnVlLFxuICB0cnVuY2F0ZTogSW5maW5pdHksXG4gIGNsYXNzTmFtZTogbnVsbCxcbiAgYXR0cmlidXRlczogbnVsbCxcbiAgaWdub3JlVGFnczogW10sXG4gIHJlbmRlcjogbnVsbFxufTtcblxuLyoqXG4gKiBVdGlsaXR5IGNsYXNzIGZvciBsaW5raWZ5IGludGVyZmFjZXMgdG8gYXBwbHkgc3BlY2lmaWVkXG4gKiB7QGxpbmsgT3B0cyBmb3JtYXR0aW5nIGFuZCByZW5kZXJpbmcgb3B0aW9uc30uXG4gKlxuICogQHBhcmFtIHtPcHRzIHwgT3B0aW9uc30gW29wdHNdIE9wdGlvbiB2YWx1ZSBvdmVycmlkZXMuXG4gKiBAcGFyYW0geyhpcjogSW50ZXJtZWRpYXRlUmVwcmVzZW50YXRpb24pID0+IGFueX0gW2RlZmF1bHRSZW5kZXJdIChGb3JcbiAqICAgaW50ZXJuYWwgdXNlKSBkZWZhdWx0IHJlbmRlciBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgaG93IHRvIGdlbmVyYXRlIGFuXG4gKiAgIEhUTUwgZWxlbWVudCBiYXNlZCBvbiBhIGxpbmsgdG9rZW4ncyBkZXJpdmVkIHRhZ05hbWUsIGF0dHJpYnV0ZXMgYW5kIEhUTUwuXG4gKiAgIFNpbWlsYXIgdG8gcmVuZGVyIG9wdGlvblxuICovXG5mdW5jdGlvbiBPcHRpb25zKG9wdHMsIGRlZmF1bHRSZW5kZXIpIHtcbiAgaWYgKGRlZmF1bHRSZW5kZXIgPT09IHZvaWQgMCkge1xuICAgIGRlZmF1bHRSZW5kZXIgPSBudWxsO1xuICB9XG4gIGxldCBvID0gYXNzaWduKHt9LCBkZWZhdWx0cyk7XG4gIGlmIChvcHRzKSB7XG4gICAgbyA9IGFzc2lnbihvLCBvcHRzIGluc3RhbmNlb2YgT3B0aW9ucyA/IG9wdHMubyA6IG9wdHMpO1xuICB9XG5cbiAgLy8gRW5zdXJlIGFsbCBpZ25vcmVkIHRhZ3MgYXJlIHVwcGVyY2FzZVxuICBjb25zdCBpZ25vcmVkVGFncyA9IG8uaWdub3JlVGFncztcbiAgY29uc3QgdXBwZXJjYXNlSWdub3JlZFRhZ3MgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZ25vcmVkVGFncy5sZW5ndGg7IGkrKykge1xuICAgIHVwcGVyY2FzZUlnbm9yZWRUYWdzLnB1c2goaWdub3JlZFRhZ3NbaV0udG9VcHBlckNhc2UoKSk7XG4gIH1cbiAgLyoqIEBwcm90ZWN0ZWQgKi9cbiAgdGhpcy5vID0gbztcbiAgaWYgKGRlZmF1bHRSZW5kZXIpIHtcbiAgICB0aGlzLmRlZmF1bHRSZW5kZXIgPSBkZWZhdWx0UmVuZGVyO1xuICB9XG4gIHRoaXMuaWdub3JlVGFncyA9IHVwcGVyY2FzZUlnbm9yZWRUYWdzO1xufVxuT3B0aW9ucy5wcm90b3R5cGUgPSB7XG4gIG86IGRlZmF1bHRzLFxuICAvKipcbiAgICogQHR5cGUgc3RyaW5nW11cbiAgICovXG4gIGlnbm9yZVRhZ3M6IFtdLFxuICAvKipcbiAgICogQHBhcmFtIHtJbnRlcm1lZGlhdGVSZXByZXNlbnRhdGlvbn0gaXJcbiAgICogQHJldHVybnMge2FueX1cbiAgICovXG4gIGRlZmF1bHRSZW5kZXIoaXIpIHtcbiAgICByZXR1cm4gaXI7XG4gIH0sXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgb3IgZmFsc2UgYmFzZWQgb24gd2hldGhlciBhIHRva2VuIHNob3VsZCBiZSBkaXNwbGF5ZWQgYXMgYVxuICAgKiBsaW5rIGJhc2VkIG9uIHRoZSB1c2VyIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7TXVsdGlUb2tlbn0gdG9rZW5cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBjaGVjayh0b2tlbikge1xuICAgIHJldHVybiB0aGlzLmdldCgndmFsaWRhdGUnLCB0b2tlbi50b1N0cmluZygpLCB0b2tlbik7XG4gIH0sXG4gIC8vIFByaXZhdGUgbWV0aG9kc1xuXG4gIC8qKlxuICAgKiBSZXNvbHZlIGFuIG9wdGlvbidzIHZhbHVlIGJhc2VkIG9uIHRoZSB2YWx1ZSBvZiB0aGUgb3B0aW9uIGFuZCB0aGUgZ2l2ZW5cbiAgICogcGFyYW1zLiBJZiBvcGVyYXRvciBhbmQgdG9rZW4gYXJlIHNwZWNpZmllZCBhbmQgdGhlIHRhcmdldCBvcHRpb24gaXNcbiAgICogY2FsbGFibGUsIGF1dG9tYXRpY2FsbHkgY2FsbHMgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50LlxuICAgKiBAdGVtcGxhdGUge2tleW9mIE9wdHN9IEtcbiAgICogQHBhcmFtIHtLfSBrZXkgTmFtZSBvZiBvcHRpb24gdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3BlcmF0b3JdIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSB0YXJnZXQgb3B0aW9uIGlmIGl0J3MgYVxuICAgKiBmdW5jdGlvbi4gSWYgbm90IHNwZWNpZmllZCwgUkFXIGZ1bmN0aW9uIHZhbHVlIGdldHMgcmV0dXJuZWRcbiAgICogQHBhcmFtIHtNdWx0aVRva2VufSBbdG9rZW5dIFRoZSB0b2tlbiBmcm9tIGxpbmtpZnkudG9rZW5pemVcbiAgICogQHJldHVybnMge09wdHNbS10gfCBhbnl9XG4gICAqL1xuICBnZXQoa2V5LCBvcGVyYXRvciwgdG9rZW4pIHtcbiAgICBjb25zdCBpc0NhbGxhYmxlID0gb3BlcmF0b3IgIT0gbnVsbDtcbiAgICBsZXQgb3B0aW9uID0gdGhpcy5vW2tleV07XG4gICAgaWYgKCFvcHRpb24pIHtcbiAgICAgIHJldHVybiBvcHRpb247XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9uID09PSAnb2JqZWN0Jykge1xuICAgICAgb3B0aW9uID0gdG9rZW4udCBpbiBvcHRpb24gPyBvcHRpb25bdG9rZW4udF0gOiBkZWZhdWx0c1trZXldO1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT09ICdmdW5jdGlvbicgJiYgaXNDYWxsYWJsZSkge1xuICAgICAgICBvcHRpb24gPSBvcHRpb24ob3BlcmF0b3IsIHRva2VuKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb24gPT09ICdmdW5jdGlvbicgJiYgaXNDYWxsYWJsZSkge1xuICAgICAgb3B0aW9uID0gb3B0aW9uKG9wZXJhdG9yLCB0b2tlbi50LCB0b2tlbik7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb247XG4gIH0sXG4gIC8qKlxuICAgKiBAdGVtcGxhdGUge2tleW9mIE9wdHN9IExcbiAgICogQHBhcmFtIHtMfSBrZXkgTmFtZSBvZiBvcHRpb25zIG9iamVjdCB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcGVyYXRvcl1cbiAgICogQHBhcmFtIHtNdWx0aVRva2VufSBbdG9rZW5dXG4gICAqIEByZXR1cm5zIHtPcHRzW0xdIHwgYW55fVxuICAgKi9cbiAgZ2V0T2JqKGtleSwgb3BlcmF0b3IsIHRva2VuKSB7XG4gICAgbGV0IG9iaiA9IHRoaXMub1trZXldO1xuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nICYmIG9wZXJhdG9yICE9IG51bGwpIHtcbiAgICAgIG9iaiA9IG9iaihvcGVyYXRvciwgdG9rZW4udCwgdG9rZW4pO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9LFxuICAvKipcbiAgICogQ29udmVydCB0aGUgZ2l2ZW4gdG9rZW4gdG8gYSByZW5kZXJlZCBlbGVtZW50IHRoYXQgbWF5IGJlIGFkZGVkIHRvIHRoZVxuICAgKiBjYWxsaW5nLWludGVyZmFjZSdzIERPTVxuICAgKiBAcGFyYW0ge011bHRpVG9rZW59IHRva2VuIFRva2VuIHRvIHJlbmRlciB0byBhbiBIVE1MIGVsZW1lbnRcbiAgICogQHJldHVybnMge2FueX0gUmVuZGVyIHJlc3VsdDsgZS5nLiwgSFRNTCBzdHJpbmcsIERPTSBlbGVtZW50LCBSZWFjdFxuICAgKiAgIENvbXBvbmVudCwgZXRjLlxuICAgKi9cbiAgcmVuZGVyKHRva2VuKSB7XG4gICAgY29uc3QgaXIgPSB0b2tlbi5yZW5kZXIodGhpcyk7IC8vIGludGVybWVkaWF0ZSByZXByZXNlbnRhdGlvblxuICAgIGNvbnN0IHJlbmRlckZuID0gdGhpcy5nZXQoJ3JlbmRlcicsIG51bGwsIHRva2VuKSB8fCB0aGlzLmRlZmF1bHRSZW5kZXI7XG4gICAgcmV0dXJuIHJlbmRlckZuKGlyLCB0b2tlbi50LCB0b2tlbik7XG4gIH1cbn07XG5mdW5jdGlvbiBub29wKHZhbCkge1xuICByZXR1cm4gdmFsO1xufVxuXG52YXIgb3B0aW9ucyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0X19wcm90b19fOiBudWxsLFxuXHRkZWZhdWx0czogZGVmYXVsdHMsXG5cdE9wdGlvbnM6IE9wdGlvbnMsXG5cdGFzc2lnbjogYXNzaWduXG59KTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHRNdWx0aS1Ub2tlbnNcblx0VG9rZW5zIGNvbXBvc2VkIG9mIGFycmF5cyBvZiBUZXh0VG9rZW5zXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0ge1Rva2VuW119IHRva2Vuc1xuICovXG5mdW5jdGlvbiBNdWx0aVRva2VuKHZhbHVlLCB0b2tlbnMpIHtcbiAgdGhpcy50ID0gJ3Rva2VuJztcbiAgdGhpcy52ID0gdmFsdWU7XG4gIHRoaXMudGsgPSB0b2tlbnM7XG59XG5cbi8qKlxuICogQWJzdHJhY3QgY2xhc3MgdXNlZCBmb3IgbWFudWZhY3R1cmluZyB0b2tlbnMgb2YgdGV4dCB0b2tlbnMuIFRoYXQgaXMgcmF0aGVyXG4gKiB0aGFuIHRoZSB2YWx1ZSBmb3IgYSB0b2tlbiBiZWluZyBhIHNtYWxsIHN0cmluZyBvZiB0ZXh0LCBpdCdzIHZhbHVlIGFuIGFycmF5XG4gKiBvZiB0ZXh0IHRva2Vucy5cbiAqXG4gKiBVc2VkIGZvciBncm91cGluZyB0b2dldGhlciBVUkxzLCBlbWFpbHMsIGhhc2h0YWdzLCBhbmQgb3RoZXIgcG90ZW50aWFsXG4gKiBjcmVhdGlvbnMuXG4gKiBAY2xhc3MgTXVsdGlUb2tlblxuICogQHByb3BlcnR5IHtzdHJpbmd9IHRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB2XG4gKiBAcHJvcGVydHkge1Rva2VuW119IHRrXG4gKiBAYWJzdHJhY3RcbiAqL1xuTXVsdGlUb2tlbi5wcm90b3R5cGUgPSB7XG4gIGlzTGluazogZmFsc2UsXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHN0cmluZyB0aGlzIHRva2VuIHJlcHJlc2VudHMuXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnY7XG4gIH0sXG4gIC8qKlxuICAgKiBXaGF0IHNob3VsZCB0aGUgdmFsdWUgZm9yIHRoaXMgdG9rZW4gYmUgaW4gdGhlIGBocmVmYCBIVE1MIGF0dHJpYnV0ZT9cbiAgICogUmV0dXJucyB0aGUgYC50b1N0cmluZ2AgdmFsdWUgYnkgZGVmYXVsdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtzY2hlbWVdXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgKi9cbiAgdG9IcmVmKHNjaGVtZSkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH0sXG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnMgRm9ybWF0dGluZyBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICB0b0Zvcm1hdHRlZFN0cmluZyhvcHRpb25zKSB7XG4gICAgY29uc3QgdmFsID0gdGhpcy50b1N0cmluZygpO1xuICAgIGNvbnN0IHRydW5jYXRlID0gb3B0aW9ucy5nZXQoJ3RydW5jYXRlJywgdmFsLCB0aGlzKTtcbiAgICBjb25zdCBmb3JtYXR0ZWQgPSBvcHRpb25zLmdldCgnZm9ybWF0JywgdmFsLCB0aGlzKTtcbiAgICByZXR1cm4gdHJ1bmNhdGUgJiYgZm9ybWF0dGVkLmxlbmd0aCA+IHRydW5jYXRlID8gZm9ybWF0dGVkLnN1YnN0cmluZygwLCB0cnVuY2F0ZSkgKyAn4oCmJyA6IGZvcm1hdHRlZDtcbiAgfSxcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgdG9Gb3JtYXR0ZWRIcmVmKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5nZXQoJ2Zvcm1hdEhyZWYnLCB0aGlzLnRvSHJlZihvcHRpb25zLmdldCgnZGVmYXVsdFByb3RvY29sJykpLCB0aGlzKTtcbiAgfSxcbiAgLyoqXG4gICAqIFRoZSBzdGFydCBpbmRleCBvZiB0aGlzIHRva2VuIGluIHRoZSBvcmlnaW5hbCBpbnB1dCBzdHJpbmdcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIHN0YXJ0SW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMudGtbMF0ucztcbiAgfSxcbiAgLyoqXG4gICAqIFRoZSBlbmQgaW5kZXggb2YgdGhpcyB0b2tlbiBpbiB0aGUgb3JpZ2luYWwgaW5wdXQgc3RyaW5nICh1cCB0byB0aGlzXG4gICAqIGluZGV4IGJ1dCBub3QgaW5jbHVkaW5nIGl0KVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgZW5kSW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMudGtbdGhpcy50ay5sZW5ndGggLSAxXS5lO1xuICB9LFxuICAvKipcbiAgXHRSZXR1cm5zIGFuIG9iamVjdCAgb2YgcmVsZXZhbnQgdmFsdWVzIGZvciB0aGlzIHRva2VuLCB3aGljaCBpbmNsdWRlcyBrZXlzXG4gIFx0KiB0eXBlIC0gS2luZCBvZiB0b2tlbiAoJ3VybCcsICdlbWFpbCcsIGV0Yy4pXG4gIFx0KiB2YWx1ZSAtIE9yaWdpbmFsIHRleHRcbiAgXHQqIGhyZWYgLSBUaGUgdmFsdWUgdGhhdCBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIGFuY2hvciB0YWcncyBocmVmXG4gIFx0XHRhdHRyaWJ1dGVcbiAgXHRcdEBtZXRob2QgdG9PYmplY3RcbiAgXHRAcGFyYW0ge3N0cmluZ30gW3Byb3RvY29sXSBgJ2h0dHAnYCBieSBkZWZhdWx0XG4gICovXG4gIHRvT2JqZWN0KHByb3RvY29sKSB7XG4gICAgaWYgKHByb3RvY29sID09PSB2b2lkIDApIHtcbiAgICAgIHByb3RvY29sID0gZGVmYXVsdHMuZGVmYXVsdFByb3RvY29sO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogdGhpcy50LFxuICAgICAgdmFsdWU6IHRoaXMudG9TdHJpbmcoKSxcbiAgICAgIGlzTGluazogdGhpcy5pc0xpbmssXG4gICAgICBocmVmOiB0aGlzLnRvSHJlZihwcm90b2NvbCksXG4gICAgICBzdGFydDogdGhpcy5zdGFydEluZGV4KCksXG4gICAgICBlbmQ6IHRoaXMuZW5kSW5kZXgoKVxuICAgIH07XG4gIH0sXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnMgRm9ybWF0dGluZyBvcHRpb25cbiAgICovXG4gIHRvRm9ybWF0dGVkT2JqZWN0KG9wdGlvbnMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogdGhpcy50LFxuICAgICAgdmFsdWU6IHRoaXMudG9Gb3JtYXR0ZWRTdHJpbmcob3B0aW9ucyksXG4gICAgICBpc0xpbms6IHRoaXMuaXNMaW5rLFxuICAgICAgaHJlZjogdGhpcy50b0Zvcm1hdHRlZEhyZWYob3B0aW9ucyksXG4gICAgICBzdGFydDogdGhpcy5zdGFydEluZGV4KCksXG4gICAgICBlbmQ6IHRoaXMuZW5kSW5kZXgoKVxuICAgIH07XG4gIH0sXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoaXMgdG9rZW4gc2hvdWxkIGJlIHJlbmRlcmVkIGFzIGEgbGluayBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIG9wdGlvbnNcbiAgICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgdmFsaWRhdGUob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLmdldCgndmFsaWRhdGUnLCB0aGlzLnRvU3RyaW5nKCksIHRoaXMpO1xuICB9LFxuICAvKipcbiAgICogUmV0dXJuIGFuIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgaG93IHRoaXMgbGluayBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9ucyBGb3JtYXR0aW5uZyBvcHRpb25zXG4gICAqL1xuICByZW5kZXIob3B0aW9ucykge1xuICAgIGNvbnN0IHRva2VuID0gdGhpcztcbiAgICBjb25zdCBocmVmID0gdGhpcy50b0hyZWYob3B0aW9ucy5nZXQoJ2RlZmF1bHRQcm90b2NvbCcpKTtcbiAgICBjb25zdCBmb3JtYXR0ZWRIcmVmID0gb3B0aW9ucy5nZXQoJ2Zvcm1hdEhyZWYnLCBocmVmLCB0aGlzKTtcbiAgICBjb25zdCB0YWdOYW1lID0gb3B0aW9ucy5nZXQoJ3RhZ05hbWUnLCBocmVmLCB0b2tlbik7XG4gICAgY29uc3QgY29udGVudCA9IHRoaXMudG9Gb3JtYXR0ZWRTdHJpbmcob3B0aW9ucyk7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHt9O1xuICAgIGNvbnN0IGNsYXNzTmFtZSA9IG9wdGlvbnMuZ2V0KCdjbGFzc05hbWUnLCBocmVmLCB0b2tlbik7XG4gICAgY29uc3QgdGFyZ2V0ID0gb3B0aW9ucy5nZXQoJ3RhcmdldCcsIGhyZWYsIHRva2VuKTtcbiAgICBjb25zdCByZWwgPSBvcHRpb25zLmdldCgncmVsJywgaHJlZiwgdG9rZW4pO1xuICAgIGNvbnN0IGF0dHJzID0gb3B0aW9ucy5nZXRPYmooJ2F0dHJpYnV0ZXMnLCBocmVmLCB0b2tlbik7XG4gICAgY29uc3QgZXZlbnRMaXN0ZW5lcnMgPSBvcHRpb25zLmdldE9iaignZXZlbnRzJywgaHJlZiwgdG9rZW4pO1xuICAgIGF0dHJpYnV0ZXMuaHJlZiA9IGZvcm1hdHRlZEhyZWY7XG4gICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgYXR0cmlidXRlcy5jbGFzcyA9IGNsYXNzTmFtZTtcbiAgICB9XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgYXR0cmlidXRlcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgfVxuICAgIGlmIChyZWwpIHtcbiAgICAgIGF0dHJpYnV0ZXMucmVsID0gcmVsO1xuICAgIH1cbiAgICBpZiAoYXR0cnMpIHtcbiAgICAgIGFzc2lnbihhdHRyaWJ1dGVzLCBhdHRycyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0YWdOYW1lLFxuICAgICAgYXR0cmlidXRlcyxcbiAgICAgIGNvbnRlbnQsXG4gICAgICBldmVudExpc3RlbmVyc1xuICAgIH07XG4gIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHRva2VuIHRoYXQgY2FuIGJlIGVtaXR0ZWQgYnkgdGhlIHBhcnNlciBzdGF0ZSBtYWNoaW5lXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSByZWFkYWJsZSB0eXBlIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzIHByb3BlcnRpZXMgdG8gYXNzaWduIG9yIG92ZXJyaWRlLCBpbmNsdWRpbmcgaXNMaW5rID0gdHJ1ZSBvciBmYWxzZVxuICogQHJldHVybnMge25ldyAodmFsdWU6IHN0cmluZywgdG9rZW5zOiBUb2tlbltdKSA9PiBNdWx0aVRva2VufSBuZXcgdG9rZW4gY2xhc3NcbiAqL1xuZnVuY3Rpb24gY3JlYXRlVG9rZW5DbGFzcyh0eXBlLCBwcm9wcykge1xuICBjbGFzcyBUb2tlbiBleHRlbmRzIE11bHRpVG9rZW4ge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCB0b2tlbnMpIHtcbiAgICAgIHN1cGVyKHZhbHVlLCB0b2tlbnMpO1xuICAgICAgdGhpcy50ID0gdHlwZTtcbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBwIGluIHByb3BzKSB7XG4gICAgVG9rZW4ucHJvdG90eXBlW3BdID0gcHJvcHNbcF07XG4gIH1cbiAgVG9rZW4udCA9IHR5cGU7XG4gIHJldHVybiBUb2tlbjtcbn1cblxuLyoqXG5cdFJlcHJlc2VudHMgYSBsaXN0IG9mIHRva2VucyBtYWtpbmcgdXAgYSB2YWxpZCBlbWFpbCBhZGRyZXNzXG4qL1xuY29uc3QgRW1haWwgPSBjcmVhdGVUb2tlbkNsYXNzKCdlbWFpbCcsIHtcbiAgaXNMaW5rOiB0cnVlLFxuICB0b0hyZWYoKSB7XG4gICAgcmV0dXJuICdtYWlsdG86JyArIHRoaXMudG9TdHJpbmcoKTtcbiAgfVxufSk7XG5cbi8qKlxuXHRSZXByZXNlbnRzIHNvbWUgcGxhaW4gdGV4dFxuKi9cbmNvbnN0IFRleHQgPSBjcmVhdGVUb2tlbkNsYXNzKCd0ZXh0Jyk7XG5cbi8qKlxuXHRNdWx0aS1saW5lYnJlYWsgdG9rZW4gLSByZXByZXNlbnRzIGEgbGluZSBicmVha1xuXHRAY2xhc3MgTmxcbiovXG5jb25zdCBObCA9IGNyZWF0ZVRva2VuQ2xhc3MoJ25sJyk7XG5cbi8qKlxuXHRSZXByZXNlbnRzIGEgbGlzdCBvZiB0ZXh0IHRva2VucyBtYWtpbmcgdXAgYSB2YWxpZCBVUkxcblx0QGNsYXNzIFVybFxuKi9cbmNvbnN0IFVybCA9IGNyZWF0ZVRva2VuQ2xhc3MoJ3VybCcsIHtcbiAgaXNMaW5rOiB0cnVlLFxuICAvKipcbiAgXHRMb3dlcmNhc2VzIHJlbGV2YW50IHBhcnRzIG9mIHRoZSBkb21haW4gYW5kIGFkZHMgdGhlIHByb3RvY29sIGlmXG4gIFx0cmVxdWlyZWQuIE5vdGUgdGhhdCB0aGlzIHdpbGwgbm90IGVzY2FwZSB1bnNhZmUgSFRNTCBjaGFyYWN0ZXJzIGluIHRoZVxuICBcdFVSTC5cbiAgXHRcdEBwYXJhbSB7c3RyaW5nfSBbc2NoZW1lXSBkZWZhdWx0IHNjaGVtZSAoZS5nLiwgJ2h0dHBzJylcbiAgXHRAcmV0dXJuIHtzdHJpbmd9IHRoZSBmdWxsIGhyZWZcbiAgKi9cbiAgdG9IcmVmKHNjaGVtZSkge1xuICAgIGlmIChzY2hlbWUgPT09IHZvaWQgMCkge1xuICAgICAgc2NoZW1lID0gZGVmYXVsdHMuZGVmYXVsdFByb3RvY29sO1xuICAgIH1cbiAgICAvLyBDaGVjayBpZiBhbHJlYWR5IGhhcyBhIHByZWZpeCBzY2hlbWVcbiAgICByZXR1cm4gdGhpcy5oYXNQcm90b2NvbCgpID8gdGhpcy52IDogYCR7c2NoZW1lfTovLyR7dGhpcy52fWA7XG4gIH0sXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHRoaXMgVVJMIHRva2VuIGhhcyBhIHByb3RvY29sXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNQcm90b2NvbCgpIHtcbiAgICBjb25zdCB0b2tlbnMgPSB0aGlzLnRrO1xuICAgIHJldHVybiB0b2tlbnMubGVuZ3RoID49IDIgJiYgdG9rZW5zWzBdLnQgIT09IExPQ0FMSE9TVCAmJiB0b2tlbnNbMV0udCA9PT0gQ09MT047XG4gIH1cbn0pO1xuXG52YXIgbXVsdGkgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0TXVsdGlUb2tlbjogTXVsdGlUb2tlbixcblx0QmFzZTogTXVsdGlUb2tlbixcblx0Y3JlYXRlVG9rZW5DbGFzczogY3JlYXRlVG9rZW5DbGFzcyxcblx0RW1haWw6IEVtYWlsLFxuXHRUZXh0OiBUZXh0LFxuXHRObDogTmwsXG5cdFVybDogVXJsXG59KTtcblxuLyoqXG5cdE5vdCBleGFjdGx5IHBhcnNlciwgbW9yZSBsaWtlIHRoZSBzZWNvbmQtc3RhZ2Ugc2Nhbm5lciAoYWx0aG91Z2ggd2UgY2FuXG5cdHRoZW9yZXRpY2FsbHkgaG90c3dhcCB0aGUgY29kZSBoZXJlIHdpdGggYSByZWFsIHBhcnNlciBpbiB0aGUgZnV0dXJlLi4uIGJ1dFxuXHRmb3IgYSBsaXR0bGUgVVJMLWZpbmRpbmcgdXRpbGl0eSBhYnN0cmFjdCBzeW50YXggdHJlZXMgbWF5IGJlIGEgbGl0dGxlXG5cdG92ZXJraWxsKS5cblxuXHRVUkwgZm9ybWF0OiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VSSV9zY2hlbWVcblx0RW1haWwgZm9ybWF0OiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0VtYWlsQWRkcmVzcyAobGlua3MgdG8gUkZDIGluXG5cdHJlZmVyZW5jZSlcblxuXHRAbW9kdWxlIGxpbmtpZnlcblx0QHN1Ym1vZHVsZSBwYXJzZXJcblx0QG1haW4gcnVuXG4qL1xuY29uc3QgbWFrZVN0YXRlID0gYXJnID0+IG5ldyBTdGF0ZShhcmcpO1xuXG4vKipcbiAqIEdlbmVyYXRlIHRoZSBwYXJzZXIgbXVsdGkgdG9rZW4tYmFzZWQgc3RhdGUgbWFjaGluZVxuICogQHBhcmFtIHt7IGdyb3VwczogQ29sbGVjdGlvbnM8c3RyaW5nPiB9fSB0b2tlbnNcbiAqL1xuZnVuY3Rpb24gaW5pdCQxKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBncm91cHNcbiAgfSA9IF9yZWY7XG4gIC8vIFR5cGVzIG9mIGNoYXJhY3RlcnMgdGhlIFVSTCBjYW4gZGVmaW5pdGVseSBlbmQgaW5cbiAgY29uc3QgcXNBY2NlcHRpbmcgPSBncm91cHMuZG9tYWluLmNvbmNhdChbQU1QRVJTQU5ELCBBU1RFUklTSywgQVQsIEJBQ0tTTEFTSCwgQkFDS1RJQ0ssIENBUkVULCBET0xMQVIsIEVRVUFMUywgSFlQSEVOLCBOVU0sIFBFUkNFTlQsIFBJUEUsIFBMVVMsIFBPVU5ELCBTTEFTSCwgU1lNLCBUSUxERSwgVU5ERVJTQ09SRV0pO1xuXG4gIC8vIFR5cGVzIG9mIHRva2VucyB0aGF0IGNhbiBmb2xsb3cgYSBVUkwgYW5kIGJlIHBhcnQgb2YgdGhlIHF1ZXJ5IHN0cmluZ1xuICAvLyBidXQgY2Fubm90IGJlIHRoZSB2ZXJ5IGxhc3QgY2hhcmFjdGVyc1xuICAvLyBDaGFyYWN0ZXJzIHRoYXQgY2Fubm90IGFwcGVhciBpbiB0aGUgVVJMIGF0IGFsbCBzaG91bGQgYmUgZXhjbHVkZWRcbiAgY29uc3QgcXNOb25BY2NlcHRpbmcgPSBbQVBPU1RST1BIRSwgQ0xPU0VBTkdMRUJSQUNLRVQsIENMT1NFQlJBQ0UsIENMT1NFQlJBQ0tFVCwgQ0xPU0VQQVJFTiwgQ09MT04sIENPTU1BLCBET1QsIEVYQ0xBTUFUSU9OLCBPUEVOQU5HTEVCUkFDS0VULCBPUEVOQlJBQ0UsIE9QRU5CUkFDS0VULCBPUEVOUEFSRU4sIFFVRVJZLCBRVU9URSwgU0VNSV07XG5cbiAgLy8gRm9yIGFkZHJlc3NlcyB3aXRob3V0IHRoZSBtYWlsdG8gcHJlZml4XG4gIC8vIFRva2VucyBhbGxvd2VkIGluIHRoZSBsb2NhbHBhcnQgb2YgdGhlIGVtYWlsXG4gIGNvbnN0IGxvY2FscGFydEFjY2VwdGluZyA9IFtBTVBFUlNBTkQsIEFQT1NUUk9QSEUsIEFTVEVSSVNLLCBCQUNLU0xBU0gsIEJBQ0tUSUNLLCBDQVJFVCwgQ0xPU0VCUkFDRSwgRE9MTEFSLCBFUVVBTFMsIEhZUEhFTiwgT1BFTkJSQUNFLCBQRVJDRU5ULCBQSVBFLCBQTFVTLCBQT1VORCwgUVVFUlksIFNMQVNILCBTWU0sIFRJTERFLCBVTkRFUlNDT1JFXTtcblxuICAvLyBUaGUgdW5pdmVyc2FsIHN0YXJ0aW5nIHN0YXRlLlxuICAvKipcbiAgICogQHR5cGUgU3RhdGU8VG9rZW4+XG4gICAqL1xuICBjb25zdCBTdGFydCA9IG1ha2VTdGF0ZSgpO1xuICBjb25zdCBMb2NhbHBhcnQgPSB0dChTdGFydCwgVElMREUpOyAvLyBMb2NhbCBwYXJ0IG9mIHRoZSBlbWFpbCBhZGRyZXNzXG4gIHRhKExvY2FscGFydCwgbG9jYWxwYXJ0QWNjZXB0aW5nLCBMb2NhbHBhcnQpO1xuICB0YShMb2NhbHBhcnQsIGdyb3Vwcy5kb21haW4sIExvY2FscGFydCk7XG4gIGNvbnN0IERvbWFpbiA9IG1ha2VTdGF0ZSgpLFxuICAgIFNjaGVtZSA9IG1ha2VTdGF0ZSgpLFxuICAgIFNsYXNoU2NoZW1lID0gbWFrZVN0YXRlKCk7XG4gIHRhKFN0YXJ0LCBncm91cHMuZG9tYWluLCBEb21haW4pOyAvLyBwYXJzZWQgc3RyaW5nIGVuZHMgd2l0aCBhIHBvdGVudGlhbCBkb21haW4gbmFtZSAoQSlcbiAgdGEoU3RhcnQsIGdyb3Vwcy5zY2hlbWUsIFNjaGVtZSk7IC8vIGUuZy4sICdtYWlsdG8nXG4gIHRhKFN0YXJ0LCBncm91cHMuc2xhc2hzY2hlbWUsIFNsYXNoU2NoZW1lKTsgLy8gZS5nLiwgJ2h0dHAnXG5cbiAgdGEoRG9tYWluLCBsb2NhbHBhcnRBY2NlcHRpbmcsIExvY2FscGFydCk7XG4gIHRhKERvbWFpbiwgZ3JvdXBzLmRvbWFpbiwgRG9tYWluKTtcbiAgY29uc3QgTG9jYWxwYXJ0QXQgPSB0dChEb21haW4sIEFUKTsgLy8gTG9jYWwgcGFydCBvZiB0aGUgZW1haWwgYWRkcmVzcyBwbHVzIEBcblxuICB0dChMb2NhbHBhcnQsIEFULCBMb2NhbHBhcnRBdCk7IC8vIGNsb3NlIHRvIGFuIGVtYWlsIGFkZHJlc3Mgbm93XG5cbiAgLy8gTG9jYWwgcGFydCBvZiBhbiBlbWFpbCBhZGRyZXNzIGNhbiBiZSBlLmcuICdodHRwJyBvciAnbWFpbHRvJ1xuICB0dChTY2hlbWUsIEFULCBMb2NhbHBhcnRBdCk7XG4gIHR0KFNsYXNoU2NoZW1lLCBBVCwgTG9jYWxwYXJ0QXQpO1xuICBjb25zdCBMb2NhbHBhcnREb3QgPSB0dChMb2NhbHBhcnQsIERPVCk7IC8vIExvY2FsIHBhcnQgb2YgdGhlIGVtYWlsIGFkZHJlc3MgcGx1cyAnLicgKGxvY2FscGFydCBjYW5ub3QgZW5kIGluIC4pXG4gIHRhKExvY2FscGFydERvdCwgbG9jYWxwYXJ0QWNjZXB0aW5nLCBMb2NhbHBhcnQpO1xuICB0YShMb2NhbHBhcnREb3QsIGdyb3Vwcy5kb21haW4sIExvY2FscGFydCk7XG4gIGNvbnN0IEVtYWlsRG9tYWluID0gbWFrZVN0YXRlKCk7XG4gIHRhKExvY2FscGFydEF0LCBncm91cHMuZG9tYWluLCBFbWFpbERvbWFpbik7IC8vIHBhcnNlZCBzdHJpbmcgc3RhcnRzIHdpdGggbG9jYWwgZW1haWwgaW5mbyArIEAgd2l0aCBhIHBvdGVudGlhbCBkb21haW4gbmFtZVxuICB0YShFbWFpbERvbWFpbiwgZ3JvdXBzLmRvbWFpbiwgRW1haWxEb21haW4pO1xuICBjb25zdCBFbWFpbERvbWFpbkRvdCA9IHR0KEVtYWlsRG9tYWluLCBET1QpOyAvLyBkb21haW4gZm9sbG93ZWQgYnkgRE9UXG4gIHRhKEVtYWlsRG9tYWluRG90LCBncm91cHMuZG9tYWluLCBFbWFpbERvbWFpbik7XG4gIGNvbnN0IEVtYWlsJDEgPSBtYWtlU3RhdGUoRW1haWwpOyAvLyBQb3NzaWJsZSBlbWFpbCBhZGRyZXNzIChjb3VsZCBoYXZlIG1vcmUgdGxkcylcbiAgdGEoRW1haWxEb21haW5Eb3QsIGdyb3Vwcy50bGQsIEVtYWlsJDEpO1xuICB0YShFbWFpbERvbWFpbkRvdCwgZ3JvdXBzLnV0bGQsIEVtYWlsJDEpO1xuICB0dChMb2NhbHBhcnRBdCwgTE9DQUxIT1NULCBFbWFpbCQxKTtcblxuICAvLyBIeXBoZW4gY2FuIGp1bXAgYmFjayB0byBhIGRvbWFpbiBuYW1lXG4gIGNvbnN0IEVtYWlsRG9tYWluSHlwaGVuID0gdHQoRW1haWxEb21haW4sIEhZUEhFTik7IC8vIHBhcnNlZCBzdHJpbmcgc3RhcnRzIHdpdGggbG9jYWwgZW1haWwgaW5mbyArIEAgd2l0aCBhIHBvdGVudGlhbCBkb21haW4gbmFtZVxuICB0YShFbWFpbERvbWFpbkh5cGhlbiwgZ3JvdXBzLmRvbWFpbiwgRW1haWxEb21haW4pO1xuICB0YShFbWFpbCQxLCBncm91cHMuZG9tYWluLCBFbWFpbERvbWFpbik7XG4gIHR0KEVtYWlsJDEsIERPVCwgRW1haWxEb21haW5Eb3QpO1xuICB0dChFbWFpbCQxLCBIWVBIRU4sIEVtYWlsRG9tYWluSHlwaGVuKTtcblxuICAvLyBGaW5hbCBwb3NzaWJsZSBlbWFpbCBzdGF0ZXNcbiAgY29uc3QgRW1haWxDb2xvbiA9IHR0KEVtYWlsJDEsIENPTE9OKTsgLy8gVVJMIGZvbGxvd2VkIGJ5IGNvbG9uIChwb3RlbnRpYWwgcG9ydCBudW1iZXIgaGVyZSlcbiAgLypjb25zdCBFbWFpbENvbG9uUG9ydCA9ICovXG4gIHRhKEVtYWlsQ29sb24sIGdyb3Vwcy5udW1lcmljLCBFbWFpbCk7IC8vIFVSTCBmb2xsb3dlZCBieSBjb2xvbiBhbmQgcG9ydCBudW1uZXJcblxuICAvLyBBY2NvdW50IGZvciBkb3RzIGFuZCBoeXBoZW5zLiBIeXBoZW5zIGFyZSB1c3VhbGx5IHBhcnRzIG9mIGRvbWFpbiBuYW1lc1xuICAvLyAoYnV0IG5vdCBUTERzKVxuICBjb25zdCBEb21haW5IeXBoZW4gPSB0dChEb21haW4sIEhZUEhFTik7IC8vIGRvbWFpbiBmb2xsb3dlZCBieSBoeXBoZW5cbiAgY29uc3QgRG9tYWluRG90ID0gdHQoRG9tYWluLCBET1QpOyAvLyBkb21haW4gZm9sbG93ZWQgYnkgRE9UXG4gIHRhKERvbWFpbkh5cGhlbiwgZ3JvdXBzLmRvbWFpbiwgRG9tYWluKTtcbiAgdGEoRG9tYWluRG90LCBsb2NhbHBhcnRBY2NlcHRpbmcsIExvY2FscGFydCk7XG4gIHRhKERvbWFpbkRvdCwgZ3JvdXBzLmRvbWFpbiwgRG9tYWluKTtcbiAgY29uc3QgRG9tYWluRG90VGxkID0gbWFrZVN0YXRlKFVybCk7IC8vIFNpbXBsZXN0IHBvc3NpYmxlIFVSTCB3aXRoIG5vIHF1ZXJ5IHN0cmluZ1xuICB0YShEb21haW5Eb3QsIGdyb3Vwcy50bGQsIERvbWFpbkRvdFRsZCk7XG4gIHRhKERvbWFpbkRvdCwgZ3JvdXBzLnV0bGQsIERvbWFpbkRvdFRsZCk7XG4gIHRhKERvbWFpbkRvdFRsZCwgZ3JvdXBzLmRvbWFpbiwgRG9tYWluKTtcbiAgdGEoRG9tYWluRG90VGxkLCBsb2NhbHBhcnRBY2NlcHRpbmcsIExvY2FscGFydCk7XG4gIHR0KERvbWFpbkRvdFRsZCwgRE9ULCBEb21haW5Eb3QpO1xuICB0dChEb21haW5Eb3RUbGQsIEhZUEhFTiwgRG9tYWluSHlwaGVuKTtcbiAgdHQoRG9tYWluRG90VGxkLCBBVCwgTG9jYWxwYXJ0QXQpO1xuICBjb25zdCBEb21haW5Eb3RUbGRDb2xvbiA9IHR0KERvbWFpbkRvdFRsZCwgQ09MT04pOyAvLyBVUkwgZm9sbG93ZWQgYnkgY29sb24gKHBvdGVudGlhbCBwb3J0IG51bWJlciBoZXJlKVxuICBjb25zdCBEb21haW5Eb3RUbGRDb2xvblBvcnQgPSBtYWtlU3RhdGUoVXJsKTsgLy8gVExEIGZvbGxvd2VkIGJ5IGEgcG9ydCBudW1iZXJcbiAgdGEoRG9tYWluRG90VGxkQ29sb24sIGdyb3Vwcy5udW1lcmljLCBEb21haW5Eb3RUbGRDb2xvblBvcnQpO1xuXG4gIC8vIExvbmcgVVJMIHdpdGggb3B0aW9uYWwgcG9ydCBhbmQgbWF5YmUgcXVlcnkgc3RyaW5nXG4gIGNvbnN0IFVybCQxID0gbWFrZVN0YXRlKFVybCk7XG5cbiAgLy8gVVJMIHdpdGggZXh0cmEgc3ltYm9scyBhdCB0aGUgZW5kLCBmb2xsb3dlZCBieSBhbiBvcGVuaW5nIGJyYWNrZXRcbiAgY29uc3QgVXJsTm9uYWNjZXB0ID0gbWFrZVN0YXRlKCk7IC8vIFVSTCBmb2xsb3dlZCBieSBzb21lIHN5bWJvbHMgKHdpbGwgbm90IGJlIHBhcnQgb2YgdGhlIGZpbmFsIFVSTClcblxuICAvLyBRdWVyeSBzdHJpbmdzXG4gIHRhKFVybCQxLCBxc0FjY2VwdGluZywgVXJsJDEpO1xuICB0YShVcmwkMSwgcXNOb25BY2NlcHRpbmcsIFVybE5vbmFjY2VwdCk7XG4gIHRhKFVybE5vbmFjY2VwdCwgcXNBY2NlcHRpbmcsIFVybCQxKTtcbiAgdGEoVXJsTm9uYWNjZXB0LCBxc05vbkFjY2VwdGluZywgVXJsTm9uYWNjZXB0KTtcblxuICAvLyBCZWNvbWUgcmVhbCBVUkxzIGFmdGVyIGBTTEFTSGAgb3IgYENPTE9OIE5VTSBTTEFTSGBcbiAgLy8gSGVyZSB3b3JrcyB3aXRoIG9yIHdpdGhvdXQgc2NoZW1lOi8vIHByZWZpeFxuICB0dChEb21haW5Eb3RUbGQsIFNMQVNILCBVcmwkMSk7XG4gIHR0KERvbWFpbkRvdFRsZENvbG9uUG9ydCwgU0xBU0gsIFVybCQxKTtcblxuICAvLyBOb3RlIHRoYXQgZG9tYWlucyB0aGF0IGJlZ2luIHdpdGggc2NoZW1lcyBhcmUgdHJlYXRlZCBzbGlnaGx5IGRpZmZlcmVudGx5XG4gIGNvbnN0IFNjaGVtZUNvbG9uID0gdHQoU2NoZW1lLCBDT0xPTik7IC8vIGUuZy4sICdtYWlsdG86J1xuICBjb25zdCBTbGFzaFNjaGVtZUNvbG9uID0gdHQoU2xhc2hTY2hlbWUsIENPTE9OKTsgLy8gZS5nLiwgJ2h0dHA6J1xuICBjb25zdCBTbGFzaFNjaGVtZUNvbG9uU2xhc2ggPSB0dChTbGFzaFNjaGVtZUNvbG9uLCBTTEFTSCk7IC8vIGUuZy4sICdodHRwOi8nXG5cbiAgY29uc3QgVXJpUHJlZml4ID0gdHQoU2xhc2hTY2hlbWVDb2xvblNsYXNoLCBTTEFTSCk7IC8vIGUuZy4sICdodHRwOi8vJ1xuXG4gIC8vIFNjaGVtZSBzdGF0ZXMgY2FuIHRyYW5zaXRpb24gdG8gZG9tYWluIHN0YXRlc1xuICB0YShTY2hlbWUsIGdyb3Vwcy5kb21haW4sIERvbWFpbik7XG4gIHR0KFNjaGVtZSwgRE9ULCBEb21haW5Eb3QpO1xuICB0dChTY2hlbWUsIEhZUEhFTiwgRG9tYWluSHlwaGVuKTtcbiAgdGEoU2xhc2hTY2hlbWUsIGdyb3Vwcy5kb21haW4sIERvbWFpbik7XG4gIHR0KFNsYXNoU2NoZW1lLCBET1QsIERvbWFpbkRvdCk7XG4gIHR0KFNsYXNoU2NoZW1lLCBIWVBIRU4sIERvbWFpbkh5cGhlbik7XG5cbiAgLy8gRm9yY2UgVVJMIHdpdGggc2NoZW1lIHByZWZpeCBmb2xsb3dlZCBieSBhbnl0aGluZyBzYW5lXG4gIHRhKFNjaGVtZUNvbG9uLCBncm91cHMuZG9tYWluLCBVcmwkMSk7XG4gIHR0KFNjaGVtZUNvbG9uLCBTTEFTSCwgVXJsJDEpO1xuICB0YShVcmlQcmVmaXgsIGdyb3Vwcy5kb21haW4sIFVybCQxKTtcbiAgdGEoVXJpUHJlZml4LCBxc0FjY2VwdGluZywgVXJsJDEpO1xuICB0dChVcmlQcmVmaXgsIFNMQVNILCBVcmwkMSk7XG5cbiAgLy8gVVJMLCBmb2xsb3dlZCBieSBhbiBvcGVuaW5nIGJyYWNrZXRcbiAgY29uc3QgVXJsT3BlbmJyYWNlID0gdHQoVXJsJDEsIE9QRU5CUkFDRSk7IC8vIFVSTCBmb2xsb3dlZCBieSB7XG4gIGNvbnN0IFVybE9wZW5icmFja2V0ID0gdHQoVXJsJDEsIE9QRU5CUkFDS0VUKTsgLy8gVVJMIGZvbGxvd2VkIGJ5IFtcbiAgY29uc3QgVXJsT3BlbmFuZ2xlYnJhY2tldCA9IHR0KFVybCQxLCBPUEVOQU5HTEVCUkFDS0VUKTsgLy8gVVJMIGZvbGxvd2VkIGJ5IDxcbiAgY29uc3QgVXJsT3BlbnBhcmVuID0gdHQoVXJsJDEsIE9QRU5QQVJFTik7IC8vIFVSTCBmb2xsb3dlZCBieSAoXG5cbiAgdHQoVXJsTm9uYWNjZXB0LCBPUEVOQlJBQ0UsIFVybE9wZW5icmFjZSk7XG4gIHR0KFVybE5vbmFjY2VwdCwgT1BFTkJSQUNLRVQsIFVybE9wZW5icmFja2V0KTtcbiAgdHQoVXJsTm9uYWNjZXB0LCBPUEVOQU5HTEVCUkFDS0VULCBVcmxPcGVuYW5nbGVicmFja2V0KTtcbiAgdHQoVXJsTm9uYWNjZXB0LCBPUEVOUEFSRU4sIFVybE9wZW5wYXJlbik7XG5cbiAgLy8gQ2xvc2luZyBicmFja2V0IGNvbXBvbmVudC4gVGhpcyBjaGFyYWN0ZXIgV0lMTCBiZSBpbmNsdWRlZCBpbiB0aGUgVVJMXG4gIHR0KFVybE9wZW5icmFjZSwgQ0xPU0VCUkFDRSwgVXJsJDEpO1xuICB0dChVcmxPcGVuYnJhY2tldCwgQ0xPU0VCUkFDS0VULCBVcmwkMSk7XG4gIHR0KFVybE9wZW5hbmdsZWJyYWNrZXQsIENMT1NFQU5HTEVCUkFDS0VULCBVcmwkMSk7XG4gIHR0KFVybE9wZW5wYXJlbiwgQ0xPU0VQQVJFTiwgVXJsJDEpO1xuICB0dChVcmxPcGVuYnJhY2UsIENMT1NFQlJBQ0UsIFVybCQxKTtcblxuICAvLyBVUkwgdGhhdCBiZWluZ3Mgd2l0aCBhbiBvcGVuaW5nIGJyYWNrZXQsIGZvbGxvd2VkIGJ5IGEgc3ltYm9scy5cbiAgLy8gTm90ZSB0aGF0IHRoZSBmaW5hbCBzdGF0ZSBjYW4gc3RpbGwgYmUgYFVybE9wZW5icmFjZWAgKGlmIHRoZSBVUkwgb25seVxuICAvLyBoYXMgYSBzaW5nbGUgb3BlbmluZyBicmFja2V0IGZvciBzb21lIHJlYXNvbikuXG4gIGNvbnN0IFVybE9wZW5icmFjZVEgPSBtYWtlU3RhdGUoVXJsKTsgLy8gVVJMIGZvbGxvd2VkIGJ5IHsgYW5kIHNvbWUgc3ltYm9scyB0aGF0IHRoZSBVUkwgY2FuIGVuZCBpdFxuICBjb25zdCBVcmxPcGVuYnJhY2tldFEgPSBtYWtlU3RhdGUoVXJsKTsgLy8gVVJMIGZvbGxvd2VkIGJ5IFsgYW5kIHNvbWUgc3ltYm9scyB0aGF0IHRoZSBVUkwgY2FuIGVuZCBpdFxuICBjb25zdCBVcmxPcGVuYW5nbGVicmFja2V0USA9IG1ha2VTdGF0ZShVcmwpOyAvLyBVUkwgZm9sbG93ZWQgYnkgPCBhbmQgc29tZSBzeW1ib2xzIHRoYXQgdGhlIFVSTCBjYW4gZW5kIGl0XG4gIGNvbnN0IFVybE9wZW5wYXJlblEgPSBtYWtlU3RhdGUoVXJsKTsgLy8gVVJMIGZvbGxvd2VkIGJ5ICggYW5kIHNvbWUgc3ltYm9scyB0aGF0IHRoZSBVUkwgY2FuIGVuZCBpdFxuICB0YShVcmxPcGVuYnJhY2UsIHFzQWNjZXB0aW5nLCBVcmxPcGVuYnJhY2VRKTtcbiAgdGEoVXJsT3BlbmJyYWNrZXQsIHFzQWNjZXB0aW5nLCBVcmxPcGVuYnJhY2tldFEpO1xuICB0YShVcmxPcGVuYW5nbGVicmFja2V0LCBxc0FjY2VwdGluZywgVXJsT3BlbmFuZ2xlYnJhY2tldFEpO1xuICB0YShVcmxPcGVucGFyZW4sIHFzQWNjZXB0aW5nLCBVcmxPcGVucGFyZW5RKTtcbiAgY29uc3QgVXJsT3BlbmJyYWNlU3ltcyA9IG1ha2VTdGF0ZSgpOyAvLyBVcmxPcGVuYnJhY2UgZm9sbG93ZWQgYnkgc29tZSBzeW1ib2xzIGl0IGNhbm5vdCBlbmQgaXRcbiAgY29uc3QgVXJsT3BlbmJyYWNrZXRTeW1zID0gbWFrZVN0YXRlKCk7IC8vIFVybE9wZW5icmFja2V0USBmb2xsb3dlZCBieSBzb21lIHN5bWJvbHMgaXQgY2Fubm90IGVuZCBpdFxuICBjb25zdCBVcmxPcGVuYW5nbGVicmFja2V0U3ltcyA9IG1ha2VTdGF0ZSgpOyAvLyBVcmxPcGVuYW5nbGVicmFja2V0USBmb2xsb3dlZCBieSBzb21lIHN5bWJvbHMgaXQgY2Fubm90IGVuZCBpdFxuICBjb25zdCBVcmxPcGVucGFyZW5TeW1zID0gbWFrZVN0YXRlKCk7IC8vIFVybE9wZW5wYXJlblEgZm9sbG93ZWQgYnkgc29tZSBzeW1ib2xzIGl0IGNhbm5vdCBlbmQgaXRcbiAgdGEoVXJsT3BlbmJyYWNlLCBxc05vbkFjY2VwdGluZyk7XG4gIHRhKFVybE9wZW5icmFja2V0LCBxc05vbkFjY2VwdGluZyk7XG4gIHRhKFVybE9wZW5hbmdsZWJyYWNrZXQsIHFzTm9uQWNjZXB0aW5nKTtcbiAgdGEoVXJsT3BlbnBhcmVuLCBxc05vbkFjY2VwdGluZyk7XG5cbiAgLy8gVVJMIHRoYXQgYmVnaW5zIHdpdGggYW4gb3BlbmluZyBicmFja2V0LCBmb2xsb3dlZCBieSBzb21lIHN5bWJvbHNcbiAgdGEoVXJsT3BlbmJyYWNlUSwgcXNBY2NlcHRpbmcsIFVybE9wZW5icmFjZVEpO1xuICB0YShVcmxPcGVuYnJhY2tldFEsIHFzQWNjZXB0aW5nLCBVcmxPcGVuYnJhY2tldFEpO1xuICB0YShVcmxPcGVuYW5nbGVicmFja2V0USwgcXNBY2NlcHRpbmcsIFVybE9wZW5hbmdsZWJyYWNrZXRRKTtcbiAgdGEoVXJsT3BlbnBhcmVuUSwgcXNBY2NlcHRpbmcsIFVybE9wZW5wYXJlblEpO1xuICB0YShVcmxPcGVuYnJhY2VRLCBxc05vbkFjY2VwdGluZywgVXJsT3BlbmJyYWNlUSk7XG4gIHRhKFVybE9wZW5icmFja2V0USwgcXNOb25BY2NlcHRpbmcsIFVybE9wZW5icmFja2V0USk7XG4gIHRhKFVybE9wZW5hbmdsZWJyYWNrZXRRLCBxc05vbkFjY2VwdGluZywgVXJsT3BlbmFuZ2xlYnJhY2tldFEpO1xuICB0YShVcmxPcGVucGFyZW5RLCBxc05vbkFjY2VwdGluZywgVXJsT3BlbnBhcmVuUSk7XG4gIHRhKFVybE9wZW5icmFjZVN5bXMsIHFzQWNjZXB0aW5nLCBVcmxPcGVuYnJhY2VTeW1zKTtcbiAgdGEoVXJsT3BlbmJyYWNrZXRTeW1zLCBxc0FjY2VwdGluZywgVXJsT3BlbmJyYWNrZXRRKTtcbiAgdGEoVXJsT3BlbmFuZ2xlYnJhY2tldFN5bXMsIHFzQWNjZXB0aW5nLCBVcmxPcGVuYW5nbGVicmFja2V0USk7XG4gIHRhKFVybE9wZW5wYXJlblN5bXMsIHFzQWNjZXB0aW5nLCBVcmxPcGVucGFyZW5RKTtcbiAgdGEoVXJsT3BlbmJyYWNlU3ltcywgcXNOb25BY2NlcHRpbmcsIFVybE9wZW5icmFjZVN5bXMpO1xuICB0YShVcmxPcGVuYnJhY2tldFN5bXMsIHFzTm9uQWNjZXB0aW5nLCBVcmxPcGVuYnJhY2tldFN5bXMpO1xuICB0YShVcmxPcGVuYW5nbGVicmFja2V0U3ltcywgcXNOb25BY2NlcHRpbmcsIFVybE9wZW5hbmdsZWJyYWNrZXRTeW1zKTtcbiAgdGEoVXJsT3BlbnBhcmVuU3ltcywgcXNOb25BY2NlcHRpbmcsIFVybE9wZW5wYXJlblN5bXMpO1xuXG4gIC8vIENsb3NlIGJyYWNlL2JyYWNrZXQgdG8gYmVjb21lIHJlZ3VsYXIgVVJMXG4gIHR0KFVybE9wZW5icmFja2V0USwgQ0xPU0VCUkFDS0VULCBVcmwkMSk7XG4gIHR0KFVybE9wZW5hbmdsZWJyYWNrZXRRLCBDTE9TRUFOR0xFQlJBQ0tFVCwgVXJsJDEpO1xuICB0dChVcmxPcGVucGFyZW5RLCBDTE9TRVBBUkVOLCBVcmwkMSk7XG4gIHR0KFVybE9wZW5icmFjZVEsIENMT1NFQlJBQ0UsIFVybCQxKTtcbiAgdHQoVXJsT3BlbmJyYWNrZXRTeW1zLCBDTE9TRUJSQUNLRVQsIFVybCQxKTtcbiAgdHQoVXJsT3BlbmFuZ2xlYnJhY2tldFN5bXMsIENMT1NFQU5HTEVCUkFDS0VULCBVcmwkMSk7XG4gIHR0KFVybE9wZW5wYXJlblN5bXMsIENMT1NFUEFSRU4sIFVybCQxKTtcbiAgdHQoVXJsT3BlbmJyYWNlU3ltcywgQ0xPU0VQQVJFTiwgVXJsJDEpO1xuICB0dChTdGFydCwgTE9DQUxIT1NULCBEb21haW5Eb3RUbGQpOyAvLyBsb2NhbGhvc3QgaXMgYSB2YWxpZCBVUkwgc3RhdGVcbiAgdHQoU3RhcnQsIE5MJDEsIE5sKTsgLy8gc2luZ2xlIG5ldyBsaW5lXG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogU3RhcnQsXG4gICAgdG9rZW5zOiB0a1xuICB9O1xufVxuXG4vKipcbiAqIFJ1biB0aGUgcGFyc2VyIHN0YXRlIG1hY2hpbmUgb24gYSBsaXN0IG9mIHNjYW5uZWQgc3RyaW5nLWJhc2VkIHRva2VucyB0b1xuICogY3JlYXRlIGEgbGlzdCBvZiBtdWx0aSB0b2tlbnMsIGVhY2ggb2Ygd2hpY2ggcmVwcmVzZW50cyBhIFVSTCwgZW1haWwgYWRkcmVzcyxcbiAqIHBsYWluIHRleHQsIGV0Yy5cbiAqXG4gKiBAcGFyYW0ge1N0YXRlPE11bHRpVG9rZW4+fSBzdGFydCBwYXJzZXIgc3RhcnQgc3RhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCB0aGUgb3JpZ2luYWwgaW5wdXQgdXNlZCB0byBnZW5lcmF0ZSB0aGUgZ2l2ZW4gdG9rZW5zXG4gKiBAcGFyYW0ge1Rva2VuW119IHRva2VucyBsaXN0IG9mIHNjYW5uZWQgdG9rZW5zXG4gKiBAcmV0dXJucyB7TXVsdGlUb2tlbltdfVxuICovXG5mdW5jdGlvbiBydW4oc3RhcnQsIGlucHV0LCB0b2tlbnMpIHtcbiAgbGV0IGxlbiA9IHRva2Vucy5sZW5ndGg7XG4gIGxldCBjdXJzb3IgPSAwO1xuICBsZXQgbXVsdGlzID0gW107XG4gIGxldCB0ZXh0VG9rZW5zID0gW107XG4gIHdoaWxlIChjdXJzb3IgPCBsZW4pIHtcbiAgICBsZXQgc3RhdGUgPSBzdGFydDtcbiAgICBsZXQgc2Vjb25kU3RhdGUgPSBudWxsO1xuICAgIGxldCBuZXh0U3RhdGUgPSBudWxsO1xuICAgIGxldCBtdWx0aUxlbmd0aCA9IDA7XG4gICAgbGV0IGxhdGVzdEFjY2VwdGluZyA9IG51bGw7XG4gICAgbGV0IHNpbmNlQWNjZXB0cyA9IC0xO1xuICAgIHdoaWxlIChjdXJzb3IgPCBsZW4gJiYgIShzZWNvbmRTdGF0ZSA9IHN0YXRlLmdvKHRva2Vuc1tjdXJzb3JdLnQpKSkge1xuICAgICAgLy8gU3RhcnRpbmcgdG9rZW5zIHdpdGggbm93aGVyZSB0byBqdW1wIHRvLlxuICAgICAgLy8gQ29uc2lkZXIgdGhlc2UgdG8gYmUganVzdCBwbGFpbiB0ZXh0XG4gICAgICB0ZXh0VG9rZW5zLnB1c2godG9rZW5zW2N1cnNvcisrXSk7XG4gICAgfVxuICAgIHdoaWxlIChjdXJzb3IgPCBsZW4gJiYgKG5leHRTdGF0ZSA9IHNlY29uZFN0YXRlIHx8IHN0YXRlLmdvKHRva2Vuc1tjdXJzb3JdLnQpKSkge1xuICAgICAgLy8gR2V0IHRoZSBuZXh0IHN0YXRlXG4gICAgICBzZWNvbmRTdGF0ZSA9IG51bGw7XG4gICAgICBzdGF0ZSA9IG5leHRTdGF0ZTtcblxuICAgICAgLy8gS2VlcCB0cmFjayBvZiB0aGUgbGF0ZXN0IGFjY2VwdGluZyBzdGF0ZVxuICAgICAgaWYgKHN0YXRlLmFjY2VwdHMoKSkge1xuICAgICAgICBzaW5jZUFjY2VwdHMgPSAwO1xuICAgICAgICBsYXRlc3RBY2NlcHRpbmcgPSBzdGF0ZTtcbiAgICAgIH0gZWxzZSBpZiAoc2luY2VBY2NlcHRzID49IDApIHtcbiAgICAgICAgc2luY2VBY2NlcHRzKys7XG4gICAgICB9XG4gICAgICBjdXJzb3IrKztcbiAgICAgIG11bHRpTGVuZ3RoKys7XG4gICAgfVxuICAgIGlmIChzaW5jZUFjY2VwdHMgPCAwKSB7XG4gICAgICAvLyBObyBhY2NlcHRpbmcgc3RhdGUgd2FzIGZvdW5kLCBwYXJ0IG9mIGEgcmVndWxhciB0ZXh0IHRva2VuIGFkZFxuICAgICAgLy8gdGhlIGZpcnN0IHRleHQgdG9rZW4gdG8gdGhlIHRleHQgdG9rZW5zIGFycmF5IGFuZCB0cnkgYWdhaW4gZnJvbVxuICAgICAgLy8gdGhlIG5leHRcbiAgICAgIGN1cnNvciAtPSBtdWx0aUxlbmd0aDtcbiAgICAgIGlmIChjdXJzb3IgPCBsZW4pIHtcbiAgICAgICAgdGV4dFRva2Vucy5wdXNoKHRva2Vuc1tjdXJzb3JdKTtcbiAgICAgICAgY3Vyc29yKys7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEFjY2VwdGluZyBzdGF0ZSFcbiAgICAgIC8vIEZpcnN0IGNsb3NlIG9mZiB0aGUgdGV4dFRva2VucyAoaWYgYXZhaWxhYmxlKVxuICAgICAgaWYgKHRleHRUb2tlbnMubGVuZ3RoID4gMCkge1xuICAgICAgICBtdWx0aXMucHVzaChpbml0TXVsdGlUb2tlbihUZXh0LCBpbnB1dCwgdGV4dFRva2VucykpO1xuICAgICAgICB0ZXh0VG9rZW5zID0gW107XG4gICAgICB9XG5cbiAgICAgIC8vIFJvbGwgYmFjayB0byB0aGUgbGF0ZXN0IGFjY2VwdGluZyBzdGF0ZVxuICAgICAgY3Vyc29yIC09IHNpbmNlQWNjZXB0cztcbiAgICAgIG11bHRpTGVuZ3RoIC09IHNpbmNlQWNjZXB0cztcblxuICAgICAgLy8gQ3JlYXRlIGEgbmV3IG11bHRpdG9rZW5cbiAgICAgIGNvbnN0IE11bHRpID0gbGF0ZXN0QWNjZXB0aW5nLnQ7XG4gICAgICBjb25zdCBzdWJ0b2tlbnMgPSB0b2tlbnMuc2xpY2UoY3Vyc29yIC0gbXVsdGlMZW5ndGgsIGN1cnNvcik7XG4gICAgICBtdWx0aXMucHVzaChpbml0TXVsdGlUb2tlbihNdWx0aSwgaW5wdXQsIHN1YnRva2VucykpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEZpbmFsbHkgY2xvc2Ugb2ZmIHRoZSB0ZXh0VG9rZW5zIChpZiBhdmFpbGFibGUpXG4gIGlmICh0ZXh0VG9rZW5zLmxlbmd0aCA+IDApIHtcbiAgICBtdWx0aXMucHVzaChpbml0TXVsdGlUb2tlbihUZXh0LCBpbnB1dCwgdGV4dFRva2VucykpO1xuICB9XG4gIHJldHVybiBtdWx0aXM7XG59XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgaW5zdGFudGlhdGluZyBhIG5ldyBtdWx0aXRva2VuIHdpdGggYWxsIHRoZSByZWxldmFudFxuICogZmllbGRzIGR1cmluZyBwYXJzaW5nLlxuICogQHBhcmFtIHtuZXcgKHZhbHVlOiBzdHJpbmcsIHRva2VuczogVG9rZW5bXSkgPT4gTXVsdGlUb2tlbn0gTXVsdGkgY2xhc3MgdG8gaW5zdGFudGlhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCBvcmlnaW5hbCBpbnB1dCBzdHJpbmdcbiAqIEBwYXJhbSB7VG9rZW5bXX0gdG9rZW5zIGNvbnNlY3V0aXZlIHRva2VucyBzY2FubmVkIGZyb20gaW5wdXQgc3RyaW5nXG4gKiBAcmV0dXJucyB7TXVsdGlUb2tlbn1cbiAqL1xuZnVuY3Rpb24gaW5pdE11bHRpVG9rZW4oTXVsdGksIGlucHV0LCB0b2tlbnMpIHtcbiAgY29uc3Qgc3RhcnRJZHggPSB0b2tlbnNbMF0ucztcbiAgY29uc3QgZW5kSWR4ID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXS5lO1xuICBjb25zdCB2YWx1ZSA9IGlucHV0LnNsaWNlKHN0YXJ0SWR4LCBlbmRJZHgpO1xuICByZXR1cm4gbmV3IE11bHRpKHZhbHVlLCB0b2tlbnMpO1xufVxuXG5jb25zdCB3YXJuID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUgJiYgY29uc29sZS53YXJuIHx8ICgoKSA9PiB7fSk7XG5jb25zdCB3YXJuQWR2aWNlID0gJ3VudGlsIG1hbnVhbCBjYWxsIG9mIGxpbmtpZnkuaW5pdCgpLiBSZWdpc3RlciBhbGwgc2NoZW1lcyBhbmQgcGx1Z2lucyBiZWZvcmUgaW52b2tpbmcgbGlua2lmeSB0aGUgZmlyc3QgdGltZS4nO1xuXG4vLyBTaWRlLWVmZmVjdCBpbml0aWFsaXphdGlvbiBzdGF0ZVxuY29uc3QgSU5JVCA9IHtcbiAgc2Nhbm5lcjogbnVsbCxcbiAgcGFyc2VyOiBudWxsLFxuICB0b2tlblF1ZXVlOiBbXSxcbiAgcGx1Z2luUXVldWU6IFtdLFxuICBjdXN0b21TY2hlbWVzOiBbXSxcbiAgaW5pdGlhbGl6ZWQ6IGZhbHNlXG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiBcdHN0YXJ0OiBTdGF0ZTxzdHJpbmc+LFxuICogXHR0b2tlbnM6IHsgZ3JvdXBzOiBDb2xsZWN0aW9uczxzdHJpbmc+IH0gJiB0eXBlb2YgdGtcbiAqIH19IFNjYW5uZXJJbml0XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogXHRzdGFydDogU3RhdGU8TXVsdGlUb2tlbj4sXG4gKiBcdHRva2VuczogdHlwZW9mIG11bHRpXG4gKiB9fSBQYXJzZXJJbml0XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7KGFyZzogeyBzY2FubmVyOiBTY2FubmVySW5pdCB9KSA9PiB2b2lkfSBUb2tlblBsdWdpblxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgeyhhcmc6IHsgc2Nhbm5lcjogU2Nhbm5lckluaXQsIHBhcnNlcjogUGFyc2VySW5pdCB9KSA9PiB2b2lkfSBQbHVnaW5cbiAqL1xuXG4vKipcbiAqIERlLXJlZ2lzdGVyIGFsbCBwbHVnaW5zIGFuZCByZXNldCB0aGUgaW50ZXJuYWwgc3RhdGUtbWFjaGluZS4gVXNlZCBmb3JcbiAqIHRlc3Rpbmc7IG5vdCByZXF1aXJlZCBpbiBwcmFjdGljZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlc2V0KCkge1xuICBTdGF0ZS5ncm91cHMgPSB7fTtcbiAgSU5JVC5zY2FubmVyID0gbnVsbDtcbiAgSU5JVC5wYXJzZXIgPSBudWxsO1xuICBJTklULnRva2VuUXVldWUgPSBbXTtcbiAgSU5JVC5wbHVnaW5RdWV1ZSA9IFtdO1xuICBJTklULmN1c3RvbVNjaGVtZXMgPSBbXTtcbiAgSU5JVC5pbml0aWFsaXplZCA9IGZhbHNlO1xufVxuXG4vKipcbiAqIFJlZ2lzdGVyIGEgdG9rZW4gcGx1Z2luIHRvIGFsbG93IHRoZSBzY2FubmVyIHRvIHJlY29nbml6ZSBhZGRpdGlvbmFsIHRva2VuXG4gKiB0eXBlcyBiZWZvcmUgdGhlIHBhcnNlciBzdGF0ZSBtYWNoaW5lIGlzIGNvbnN0cnVjdGVkIGZyb20gdGhlIHJlc3VsdHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBvZiBwbHVnaW4gdG8gcmVnaXN0ZXJcbiAqIEBwYXJhbSB7VG9rZW5QbHVnaW59IHBsdWdpbiBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgdGhlIHNjYW5uZXIgc3RhdGUgbWFjaGluZVxuICogYW5kIGF2YWlsYWJsZSBzY2FubmVyIHRva2VucyBhbmQgY29sbGVjdGlvbnMgYW5kIGV4dGVuZHMgdGhlIHN0YXRlIG1hY2hpbmUgdG9cbiAqIHJlY29nbml6ZSBhZGRpdGlvbmFsIHRva2VucyBvciBncm91cHMuXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyVG9rZW5QbHVnaW4obmFtZSwgcGx1Z2luKSB7XG4gIGlmICh0eXBlb2YgcGx1Z2luICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBsaW5raWZ5anM6IEludmFsaWQgdG9rZW4gcGx1Z2luICR7cGx1Z2lufSAoZXhwZWN0cyBmdW5jdGlvbilgKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IElOSVQudG9rZW5RdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChuYW1lID09PSBJTklULnRva2VuUXVldWVbaV1bMF0pIHtcbiAgICAgIHdhcm4oYGxpbmtpZnlqczogdG9rZW4gcGx1Z2luIFwiJHtuYW1lfVwiIGFscmVhZHkgcmVnaXN0ZXJlZCAtIHdpbGwgYmUgb3ZlcndyaXR0ZW5gKTtcbiAgICAgIElOSVQudG9rZW5RdWV1ZVtpXSA9IFtuYW1lLCBwbHVnaW5dO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBJTklULnRva2VuUXVldWUucHVzaChbbmFtZSwgcGx1Z2luXSk7XG4gIGlmIChJTklULmluaXRpYWxpemVkKSB7XG4gICAgd2FybihgbGlua2lmeWpzOiBhbHJlYWR5IGluaXRpYWxpemVkIC0gd2lsbCBub3QgcmVnaXN0ZXIgdG9rZW4gcGx1Z2luIFwiJHtuYW1lfVwiICR7d2FybkFkdmljZX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlZ2lzdGVyIGEgbGlua2lmeSBwbHVnaW5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG9mIHBsdWdpbiB0byByZWdpc3RlclxuICogQHBhcmFtIHtQbHVnaW59IHBsdWdpbiBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgdGhlIHBhcnNlciBzdGF0ZSBtYWNoaW5lIGFuZFxuICogZXh0ZW5kcyB0aGUgcGFyc2VyIHRvIHJlY29nbml6ZSBhZGRpdGlvbmFsIGxpbmsgdHlwZXNcbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJQbHVnaW4obmFtZSwgcGx1Z2luKSB7XG4gIGlmICh0eXBlb2YgcGx1Z2luICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBsaW5raWZ5anM6IEludmFsaWQgcGx1Z2luICR7cGx1Z2lufSAoZXhwZWN0cyBmdW5jdGlvbilgKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IElOSVQucGx1Z2luUXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobmFtZSA9PT0gSU5JVC5wbHVnaW5RdWV1ZVtpXVswXSkge1xuICAgICAgd2FybihgbGlua2lmeWpzOiBwbHVnaW4gXCIke25hbWV9XCIgYWxyZWFkeSByZWdpc3RlcmVkIC0gd2lsbCBiZSBvdmVyd3JpdHRlbmApO1xuICAgICAgSU5JVC5wbHVnaW5RdWV1ZVtpXSA9IFtuYW1lLCBwbHVnaW5dO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBJTklULnBsdWdpblF1ZXVlLnB1c2goW25hbWUsIHBsdWdpbl0pO1xuICBpZiAoSU5JVC5pbml0aWFsaXplZCkge1xuICAgIHdhcm4oYGxpbmtpZnlqczogYWxyZWFkeSBpbml0aWFsaXplZCAtIHdpbGwgbm90IHJlZ2lzdGVyIHBsdWdpbiBcIiR7bmFtZX1cIiAke3dhcm5BZHZpY2V9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBEZXRlY3QgVVJMcyB3aXRoIHRoZSBmb2xsb3dpbmcgYWRkaXRpb25hbCBwcm90b2NvbC4gQW55dGhpbmcgd2l0aCBmb3JtYXRcbiAqIFwicHJvdG9jb2w6Ly8uLi5cIiB3aWxsIGJlIGNvbnNpZGVyZWQgYSBsaW5rLiBJZiBgb3B0aW9uYWxTbGFzaFNsYXNoYCBpcyBzZXQgdG9cbiAqIGB0cnVlYCwgYW55dGhpbmcgd2l0aCBmb3JtYXQgXCJwcm90b2NvbDouLi5cIiB3aWxsIGJlIGNvbnNpZGVyZWQgYSBsaW5rLlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3RvY29sXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25hbFNsYXNoU2xhc2hdXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyQ3VzdG9tUHJvdG9jb2woc2NoZW1lLCBvcHRpb25hbFNsYXNoU2xhc2gpIHtcbiAgaWYgKG9wdGlvbmFsU2xhc2hTbGFzaCA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9uYWxTbGFzaFNsYXNoID0gZmFsc2U7XG4gIH1cbiAgaWYgKElOSVQuaW5pdGlhbGl6ZWQpIHtcbiAgICB3YXJuKGBsaW5raWZ5anM6IGFscmVhZHkgaW5pdGlhbGl6ZWQgLSB3aWxsIG5vdCByZWdpc3RlciBjdXN0b20gc2NoZW1lIFwiJHtzY2hlbWV9XCIgJHt3YXJuQWR2aWNlfWApO1xuICB9XG4gIGlmICghL15bMC05YS16XSsoLVswLTlhLXpdKykqJC8udGVzdChzY2hlbWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdsaW5raWZ5anM6IGluY29ycmVjdCBzY2hlbWUgZm9ybWF0LlxcbiAxLiBNdXN0IG9ubHkgY29udGFpbiBkaWdpdHMsIGxvd2VyY2FzZSBBU0NJSSBsZXR0ZXJzIG9yIFwiLVwiXFxuIDIuIENhbm5vdCBzdGFydCBvciBlbmQgd2l0aCBcIi1cIlxcbiAzLiBcIi1cIiBjYW5ub3QgcmVwZWF0Jyk7XG4gIH1cbiAgSU5JVC5jdXN0b21TY2hlbWVzLnB1c2goW3NjaGVtZSwgb3B0aW9uYWxTbGFzaFNsYXNoXSk7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgbGlua2lmeSBzdGF0ZSBtYWNoaW5lLiBDYWxsZWQgYXV0b21hdGljYWxseSB0aGUgZmlyc3QgdGltZVxuICogbGlua2lmeSBpcyBjYWxsZWQgb24gYSBzdHJpbmcsIGJ1dCBtYXkgYmUgY2FsbGVkIG1hbnVhbGx5IGFzIHdlbGwuXG4gKi9cbmZ1bmN0aW9uIGluaXQoKSB7XG4gIC8vIEluaXRpYWxpemUgc2Nhbm5lciBzdGF0ZSBtYWNoaW5lIGFuZCBwbHVnaW5zXG4gIElOSVQuc2Nhbm5lciA9IGluaXQkMihJTklULmN1c3RvbVNjaGVtZXMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IElOSVQudG9rZW5RdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIElOSVQudG9rZW5RdWV1ZVtpXVsxXSh7XG4gICAgICBzY2FubmVyOiBJTklULnNjYW5uZXJcbiAgICB9KTtcbiAgfVxuXG4gIC8vIEluaXRpYWxpemUgcGFyc2VyIHN0YXRlIG1hY2hpbmUgYW5kIHBsdWdpbnNcbiAgSU5JVC5wYXJzZXIgPSBpbml0JDEoSU5JVC5zY2FubmVyLnRva2Vucyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgSU5JVC5wbHVnaW5RdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIElOSVQucGx1Z2luUXVldWVbaV1bMV0oe1xuICAgICAgc2Nhbm5lcjogSU5JVC5zY2FubmVyLFxuICAgICAgcGFyc2VyOiBJTklULnBhcnNlclxuICAgIH0pO1xuICB9XG4gIElOSVQuaW5pdGlhbGl6ZWQgPSB0cnVlO1xufVxuXG4vKipcbiAqIFBhcnNlIGEgc3RyaW5nIGludG8gdG9rZW5zIHRoYXQgcmVwcmVzZW50IGxpbmthYmxlIGFuZCBub24tbGlua2FibGUgc3ViLWNvbXBvbmVudHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge011bHRpVG9rZW5bXX0gdG9rZW5zXG4gKi9cbmZ1bmN0aW9uIHRva2VuaXplKHN0cikge1xuICBpZiAoIUlOSVQuaW5pdGlhbGl6ZWQpIHtcbiAgICBpbml0KCk7XG4gIH1cbiAgcmV0dXJuIHJ1bihJTklULnBhcnNlci5zdGFydCwgc3RyLCBydW4kMShJTklULnNjYW5uZXIuc3RhcnQsIHN0cikpO1xufVxuXG4vKipcbiAqIEZpbmQgYSBsaXN0IG9mIGxpbmthYmxlIGl0ZW1zIGluIHRoZSBnaXZlbiBzdHJpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIHN0cmluZyB0byBmaW5kIGxpbmtzIGluXG4gKiBAcGFyYW0ge3N0cmluZyB8IE9wdHN9IFt0eXBlXSBlaXRoZXIgZm9ybWF0dGluZyBvcHRpb25zIG9yIHNwZWNpZmljIHR5cGUgb2ZcbiAqIGxpbmtzIHRvIGZpbmQsIGUuZy4sICd1cmwnIG9yICdlbWFpbCdcbiAqIEBwYXJhbSB7T3B0c30gW29wdHNdIGZvcm1hdHRpbmcgb3B0aW9ucyBmb3IgZmluYWwgb3V0cHV0LiBDYW5ub3QgYmUgc3BlY2lmaWVkXG4gKiBpZiBvcHRzIGFscmVhZHkgcHJvdmlkZWQgaW4gYHR5cGVgIGFyZ3VtZW50XG4qL1xuZnVuY3Rpb24gZmluZChzdHIsIHR5cGUsIG9wdHMpIHtcbiAgaWYgKHR5cGUgPT09IHZvaWQgMCkge1xuICAgIHR5cGUgPSBudWxsO1xuICB9XG4gIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICBvcHRzID0gbnVsbDtcbiAgfVxuICBpZiAodHlwZSAmJiB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAob3B0cykge1xuICAgICAgdGhyb3cgRXJyb3IoYGxpbmtpZnlqczogSW52YWxpZCBsaW5rIHR5cGUgJHt0eXBlfTsgbXVzdCBiZSBhIHN0cmluZ2ApO1xuICAgIH1cbiAgICBvcHRzID0gdHlwZTtcbiAgICB0eXBlID0gbnVsbDtcbiAgfVxuICBjb25zdCBvcHRpb25zID0gbmV3IE9wdGlvbnMob3B0cyk7XG4gIGNvbnN0IHRva2VucyA9IHRva2VuaXplKHN0cik7XG4gIGNvbnN0IGZpbHRlcmVkID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgaWYgKHRva2VuLmlzTGluayAmJiAoIXR5cGUgfHwgdG9rZW4udCA9PT0gdHlwZSkpIHtcbiAgICAgIGZpbHRlcmVkLnB1c2godG9rZW4udG9Gb3JtYXR0ZWRPYmplY3Qob3B0aW9ucykpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmlsdGVyZWQ7XG59XG5cbi8qKlxuICogSXMgdGhlIGdpdmVuIHN0cmluZyB2YWxpZCBsaW5rYWJsZSB0ZXh0IG9mIHNvbWUgc29ydC4gTm90ZSB0aGF0IHRoaXMgZG9lcyBub3RcbiAqIHRyaW0gdGhlIHRleHQgZm9yIHlvdS5cbiAqXG4gKiBPcHRpb25hbGx5IHBhc3MgaW4gYSBzZWNvbmQgYHR5cGVgIHBhcmFtLCB3aGljaCBpcyB0aGUgdHlwZSBvZiBsaW5rIHRvIHRlc3RcbiAqIGZvci5cbiAqXG4gKiBGb3IgZXhhbXBsZSxcbiAqXG4gKiAgICAgbGlua2lmeS50ZXN0KHN0ciwgJ2VtYWlsJyk7XG4gKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgc3RyIGlzIGEgdmFsaWQgZW1haWwuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIHN0cmluZyB0byB0ZXN0IGZvciBsaW5rc1xuICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlXSBvcHRpb25hbCBzcGVjaWZpYyBsaW5rIHR5cGUgdG8gbG9vayBmb3JcbiAqIEByZXR1cm5zIGJvb2xlYW4gdHJ1ZS9mYWxzZVxuICovXG5mdW5jdGlvbiB0ZXN0KHN0ciwgdHlwZSkge1xuICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7XG4gICAgdHlwZSA9IG51bGw7XG4gIH1cbiAgY29uc3QgdG9rZW5zID0gdG9rZW5pemUoc3RyKTtcbiAgcmV0dXJuIHRva2Vucy5sZW5ndGggPT09IDEgJiYgdG9rZW5zWzBdLmlzTGluayAmJiAoIXR5cGUgfHwgdG9rZW5zWzBdLnQgPT09IHR5cGUpO1xufVxuXG5leHBvcnQgeyBNdWx0aVRva2VuLCBPcHRpb25zLCBTdGF0ZSwgY3JlYXRlVG9rZW5DbGFzcywgZmluZCwgaW5pdCwgbXVsdGksIG9wdGlvbnMsIHJlZ2V4cCwgcmVnaXN0ZXJDdXN0b21Qcm90b2NvbCwgcmVnaXN0ZXJQbHVnaW4sIHJlZ2lzdGVyVG9rZW5QbHVnaW4sIHJlc2V0LCBzdHJpbmdUb0FycmF5LCB0ZXN0LCB0b2tlbml6ZSB9O1xuIiwiaW1wb3J0IHsgT3B0aW9ucywgdG9rZW5pemUgYXMgdG9rZW5pemUkMSB9IGZyb20gJ2xpbmtpZnlqcyc7XG5cbi8qKlxuICogZ2VuZXJhdGVkIGZyb20gaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3czYy9odG1sLzI2YjUxMjZmOTZmNzM2Zjc5NmI5ZTI5NzE4MTM4OTE5ZGQ1MTM3NDQvZW50aXRpZXMuanNvblxuICogZG8gbm90IGVkaXRcbiAqL1xudmFyIEhUTUw1TmFtZWRDaGFyUmVmcyA9IHtcbiAgLy8gV2UgZG9uJ3QgbmVlZCB0aGUgY29tcGxldGUgbmFtZWQgY2hhcmFjdGVyIHJlZmVyZW5jZSBiZWNhdXNlIGxpbmtpZnlIdG1sXG4gIC8vIGRvZXMgbm90IG1vZGlmeSB0aGUgZXNjYXBlIHNlcXVlbmNlcy4gV2UgZG8gbmVlZCAmbmJzcDsgc28gdGhhdFxuICAvLyB3aGl0ZXNwYWNlIGlzIHBhcnNlZCBwcm9wZXJseS4gT3RoZXIgdHlwZXMgb2Ygd2hpdGVzcGFjZSBzaG91bGQgYWxyZWFkeVxuICAvLyBiZSBhY2NvdW50ZWQgZm9yLiAmZ3Q7ICZsdDsgYW5kICZxdW90OyBhcmUgYWxzbyBmcmVxdWVudGx5IHJlbGV2YW50IG9uZXNcbiAgYW1wOiBcIiZcIixcbiAgZ3Q6IFwiPlwiLFxuICBsdDogXCI8XCIsXG4gIG5ic3A6IFwiwqBcIixcbiAgcXVvdDogXCJcXFwiXCJcbn07XG52YXIgSEVYQ0hBUkNPREUgPSAvXiNbeFhdKFtBLUZhLWYwLTldKykkLztcbnZhciBDSEFSQ09ERSA9IC9eIyhbMC05XSspJC87XG52YXIgTkFNRUQgPSAvXihbQS1aYS16MC05XSspJC87XG52YXIgRW50aXR5UGFyc2VyID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRW50aXR5UGFyc2VyKG5hbWVkKSB7XG4gICAgdGhpcy5uYW1lZCA9IG5hbWVkO1xuICB9XG4gIEVudGl0eVBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoZW50aXR5KSB7XG4gICAgaWYgKCFlbnRpdHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG1hdGNoZXMgPSBlbnRpdHkubWF0Y2goSEVYQ0hBUkNPREUpO1xuICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChtYXRjaGVzWzFdLCAxNikpO1xuICAgIH1cbiAgICBtYXRjaGVzID0gZW50aXR5Lm1hdGNoKENIQVJDT0RFKTtcbiAgICBpZiAobWF0Y2hlcykge1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQobWF0Y2hlc1sxXSwgMTApKTtcbiAgICB9XG4gICAgbWF0Y2hlcyA9IGVudGl0eS5tYXRjaChOQU1FRCk7XG4gICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLm5hbWVkW21hdGNoZXNbMV1dIHx8IFwiJlwiICsgbWF0Y2hlc1sxXSArIFwiO1wiO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIEVudGl0eVBhcnNlcjtcbn0oKTtcbnZhciBXU1AgPSAvW1xcdFxcblxcZiBdLztcbnZhciBBTFBIQSA9IC9bQS1aYS16XS87XG52YXIgQ1JMRiA9IC9cXHJcXG4/L2c7XG5mdW5jdGlvbiBpc1NwYWNlKGNoYXIpIHtcbiAgcmV0dXJuIFdTUC50ZXN0KGNoYXIpO1xufVxuZnVuY3Rpb24gaXNBbHBoYShjaGFyKSB7XG4gIHJldHVybiBBTFBIQS50ZXN0KGNoYXIpO1xufVxuZnVuY3Rpb24gcHJlcHJvY2Vzc0lucHV0KGlucHV0KSB7XG4gIHJldHVybiBpbnB1dC5yZXBsYWNlKENSTEYsICdcXG4nKTtcbn1cbnZhciBFdmVudGVkVG9rZW5pemVyID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRXZlbnRlZFRva2VuaXplcihkZWxlZ2F0ZSwgZW50aXR5UGFyc2VyLCBtb2RlKSB7XG4gICAgaWYgKG1vZGUgPT09IHZvaWQgMCkge1xuICAgICAgbW9kZSA9ICdwcmVjb21waWxlJztcbiAgICB9XG4gICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuICAgIHRoaXMuZW50aXR5UGFyc2VyID0gZW50aXR5UGFyc2VyO1xuICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgdGhpcy5zdGF0ZSA9IFwiYmVmb3JlRGF0YVwiIC8qIGJlZm9yZURhdGEgKi87XG4gICAgdGhpcy5saW5lID0gLTE7XG4gICAgdGhpcy5jb2x1bW4gPSAtMTtcbiAgICB0aGlzLmlucHV0ID0gJyc7XG4gICAgdGhpcy5pbmRleCA9IC0xO1xuICAgIHRoaXMudGFnTmFtZUJ1ZmZlciA9ICcnO1xuICAgIHRoaXMuc3RhdGVzID0ge1xuICAgICAgYmVmb3JlRGF0YTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2hhciA9IHRoaXMucGVlaygpO1xuICAgICAgICBpZiAoY2hhciA9PT0gJzwnICYmICF0aGlzLmlzSWdub3JlZEVuZFRhZygpKSB7XG4gICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG8oXCJ0YWdPcGVuXCIgLyogdGFnT3BlbiAqLyk7XG4gICAgICAgICAgdGhpcy5tYXJrVGFnU3RhcnQoKTtcbiAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5tb2RlID09PSAncHJlY29tcGlsZScgJiYgY2hhciA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgIHZhciB0YWcgPSB0aGlzLnRhZ05hbWVCdWZmZXIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmICh0YWcgPT09ICdwcmUnIHx8IHRhZyA9PT0gJ3RleHRhcmVhJykge1xuICAgICAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG8oXCJkYXRhXCIgLyogZGF0YSAqLyk7XG4gICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5iZWdpbkRhdGEoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNoYXIgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgdmFyIHRhZyA9IHRoaXMudGFnTmFtZUJ1ZmZlcjtcbiAgICAgICAgaWYgKGNoYXIgPT09ICc8JyAmJiAhdGhpcy5pc0lnbm9yZWRFbmRUYWcoKSkge1xuICAgICAgICAgIHRoaXMuZGVsZWdhdGUuZmluaXNoRGF0YSgpO1xuICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvKFwidGFnT3BlblwiIC8qIHRhZ09wZW4gKi8pO1xuICAgICAgICAgIHRoaXMubWFya1RhZ1N0YXJ0KCk7XG4gICAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gJyYnICYmIHRhZyAhPT0gJ3NjcmlwdCcgJiYgdGFnICE9PSAnc3R5bGUnKSB7XG4gICAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5hcHBlbmRUb0RhdGEodGhpcy5jb25zdW1lQ2hhclJlZigpIHx8ICcmJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5hcHBlbmRUb0RhdGEoY2hhcik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0YWdPcGVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaGFyID0gdGhpcy5jb25zdW1lKCk7XG4gICAgICAgIGlmIChjaGFyID09PSAnIScpIHtcbiAgICAgICAgICB0aGlzLnRyYW5zaXRpb25UbyhcIm1hcmt1cERlY2xhcmF0aW9uT3BlblwiIC8qIG1hcmt1cERlY2xhcmF0aW9uT3BlbiAqLyk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gJy8nKSB7XG4gICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG8oXCJlbmRUYWdPcGVuXCIgLyogZW5kVGFnT3BlbiAqLyk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gJ0AnIHx8IGNoYXIgPT09ICc6JyB8fCBpc0FscGhhKGNoYXIpKSB7XG4gICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG8oXCJ0YWdOYW1lXCIgLyogdGFnTmFtZSAqLyk7XG4gICAgICAgICAgdGhpcy50YWdOYW1lQnVmZmVyID0gJyc7XG4gICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5iZWdpblN0YXJ0VGFnKCk7XG4gICAgICAgICAgdGhpcy5hcHBlbmRUb1RhZ05hbWUoY2hhcik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBtYXJrdXBEZWNsYXJhdGlvbk9wZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNoYXIgPSB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgaWYgKGNoYXIgPT09ICctJyAmJiB0aGlzLnBlZWsoKSA9PT0gJy0nKSB7XG4gICAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG8oXCJjb21tZW50U3RhcnRcIiAvKiBjb21tZW50U3RhcnQgKi8pO1xuICAgICAgICAgIHRoaXMuZGVsZWdhdGUuYmVnaW5Db21tZW50KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG1heWJlRG9jdHlwZSA9IGNoYXIudG9VcHBlckNhc2UoKSArIHRoaXMuaW5wdXQuc3Vic3RyaW5nKHRoaXMuaW5kZXgsIHRoaXMuaW5kZXggKyA2KS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgIGlmIChtYXliZURvY3R5cGUgPT09ICdET0NUWVBFJykge1xuICAgICAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG8oXCJkb2N0eXBlXCIgLyogZG9jdHlwZSAqLyk7XG4gICAgICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZS5iZWdpbkRvY3R5cGUpIHRoaXMuZGVsZWdhdGUuYmVnaW5Eb2N0eXBlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZG9jdHlwZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2hhciA9IHRoaXMuY29uc3VtZSgpO1xuICAgICAgICBpZiAoaXNTcGFjZShjaGFyKSkge1xuICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvKFwiYmVmb3JlRG9jdHlwZU5hbWVcIiAvKiBiZWZvcmVEb2N0eXBlTmFtZSAqLyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGJlZm9yZURvY3R5cGVOYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaGFyID0gdGhpcy5jb25zdW1lKCk7XG4gICAgICAgIGlmIChpc1NwYWNlKGNoYXIpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvKFwiZG9jdHlwZU5hbWVcIiAvKiBkb2N0eXBlTmFtZSAqLyk7XG4gICAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUuYXBwZW5kVG9Eb2N0eXBlTmFtZSkgdGhpcy5kZWxlZ2F0ZS5hcHBlbmRUb0RvY3R5cGVOYW1lKGNoYXIudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkb2N0eXBlTmFtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2hhciA9IHRoaXMuY29uc3VtZSgpO1xuICAgICAgICBpZiAoaXNTcGFjZShjaGFyKSkge1xuICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvKFwiYWZ0ZXJEb2N0eXBlTmFtZVwiIC8qIGFmdGVyRG9jdHlwZU5hbWUgKi8pO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPT09ICc+Jykge1xuICAgICAgICAgIGlmICh0aGlzLmRlbGVnYXRlLmVuZERvY3R5cGUpIHRoaXMuZGVsZWdhdGUuZW5kRG9jdHlwZSgpO1xuICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvKFwiYmVmb3JlRGF0YVwiIC8qIGJlZm9yZURhdGEgKi8pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLmRlbGVnYXRlLmFwcGVuZFRvRG9jdHlwZU5hbWUpIHRoaXMuZGVsZWdhdGUuYXBwZW5kVG9Eb2N0eXBlTmFtZShjaGFyLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYWZ0ZXJEb2N0eXBlTmFtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2hhciA9IHRoaXMuY29uc3VtZSgpO1xuICAgICAgICBpZiAoaXNTcGFjZShjaGFyKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID09PSAnPicpIHtcbiAgICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZS5lbmREb2N0eXBlKSB0aGlzLmRlbGVnYXRlLmVuZERvY3R5cGUoKTtcbiAgICAgICAgICB0aGlzLnRyYW5zaXRpb25UbyhcImJlZm9yZURhdGFcIiAvKiBiZWZvcmVEYXRhICovKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbmV4dFNpeENoYXJzID0gY2hhci50b1VwcGVyQ2FzZSgpICsgdGhpcy5pbnB1dC5zdWJzdHJpbmcodGhpcy5pbmRleCwgdGhpcy5pbmRleCArIDUpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgdmFyIGlzUHVibGljID0gbmV4dFNpeENoYXJzLnRvVXBwZXJDYXNlKCkgPT09ICdQVUJMSUMnO1xuICAgICAgICAgIHZhciBpc1N5c3RlbSA9IG5leHRTaXhDaGFycy50b1VwcGVyQ2FzZSgpID09PSAnU1lTVEVNJztcbiAgICAgICAgICBpZiAoaXNQdWJsaWMgfHwgaXNTeXN0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzUHVibGljKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25UbyhcImFmdGVyRG9jdHlwZVB1YmxpY0tleXdvcmRcIiAvKiBhZnRlckRvY3R5cGVQdWJsaWNLZXl3b3JkICovKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzU3lzdGVtKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25UbyhcImFmdGVyRG9jdHlwZVN5c3RlbUtleXdvcmRcIiAvKiBhZnRlckRvY3R5cGVTeXN0ZW1LZXl3b3JkICovKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGFmdGVyRG9jdHlwZVB1YmxpY0tleXdvcmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNoYXIgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgaWYgKGlzU3BhY2UoY2hhcikpIHtcbiAgICAgICAgICB0aGlzLnRyYW5zaXRpb25UbyhcImJlZm9yZURvY3R5cGVQdWJsaWNJZGVudGlmaWVyXCIgLyogYmVmb3JlRG9jdHlwZVB1YmxpY0lkZW50aWZpZXIgKi8pO1xuICAgICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPT09ICdcIicpIHtcbiAgICAgICAgICB0aGlzLnRyYW5zaXRpb25UbyhcImRvY3R5cGVQdWJsaWNJZGVudGlmaWVyRG91YmxlUXVvdGVkXCIgLyogZG9jdHlwZVB1YmxpY0lkZW50aWZpZXJEb3VibGVRdW90ZWQgKi8pO1xuICAgICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPT09IFwiJ1wiKSB7XG4gICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG8oXCJkb2N0eXBlUHVibGljSWRlbnRpZmllclNpbmdsZVF1b3RlZFwiIC8qIGRvY3R5cGVQdWJsaWNJZGVudGlmaWVyU2luZ2xlUXVvdGVkICovKTtcbiAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID09PSAnPicpIHtcbiAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZS5lbmREb2N0eXBlKSB0aGlzLmRlbGVnYXRlLmVuZERvY3R5cGUoKTtcbiAgICAgICAgICB0aGlzLnRyYW5zaXRpb25UbyhcImJlZm9yZURhdGFcIiAvKiBiZWZvcmVEYXRhICovKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZG9jdHlwZVB1YmxpY0lkZW50aWZpZXJEb3VibGVRdW90ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNoYXIgPSB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgaWYgKGNoYXIgPT09ICdcIicpIHtcbiAgICAgICAgICB0aGlzLnRyYW5zaXRpb25UbyhcImFmdGVyRG9jdHlwZVB1YmxpY0lkZW50aWZpZXJcIiAvKiBhZnRlckRvY3R5cGVQdWJsaWNJZGVudGlmaWVyICovKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID09PSAnPicpIHtcbiAgICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZS5lbmREb2N0eXBlKSB0aGlzLmRlbGVnYXRlLmVuZERvY3R5cGUoKTtcbiAgICAgICAgICB0aGlzLnRyYW5zaXRpb25UbyhcImJlZm9yZURhdGFcIiAvKiBiZWZvcmVEYXRhICovKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZS5hcHBlbmRUb0RvY3R5cGVQdWJsaWNJZGVudGlmaWVyKSB0aGlzLmRlbGVnYXRlLmFwcGVuZFRvRG9jdHlwZVB1YmxpY0lkZW50aWZpZXIoY2hhcik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkb2N0eXBlUHVibGljSWRlbnRpZmllclNpbmdsZVF1b3RlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2hhciA9IHRoaXMuY29uc3VtZSgpO1xuICAgICAgICBpZiAoY2hhciA9PT0gXCInXCIpIHtcbiAgICAgICAgICB0aGlzLnRyYW5zaXRpb25UbyhcImFmdGVyRG9jdHlwZVB1YmxpY0lkZW50aWZpZXJcIiAvKiBhZnRlckRvY3R5cGVQdWJsaWNJZGVudGlmaWVyICovKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID09PSAnPicpIHtcbiAgICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZS5lbmREb2N0eXBlKSB0aGlzLmRlbGVnYXRlLmVuZERvY3R5cGUoKTtcbiAgICAgICAgICB0aGlzLnRyYW5zaXRpb25UbyhcImJlZm9yZURhdGFcIiAvKiBiZWZvcmVEYXRhICovKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZS5hcHBlbmRUb0RvY3R5cGVQdWJsaWNJZGVudGlmaWVyKSB0aGlzLmRlbGVnYXRlLmFwcGVuZFRvRG9jdHlwZVB1YmxpY0lkZW50aWZpZXIoY2hhcik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhZnRlckRvY3R5cGVQdWJsaWNJZGVudGlmaWVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaGFyID0gdGhpcy5jb25zdW1lKCk7XG4gICAgICAgIGlmIChpc1NwYWNlKGNoYXIpKSB7XG4gICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG8oXCJiZXR3ZWVuRG9jdHlwZVB1YmxpY0FuZFN5c3RlbUlkZW50aWZpZXJzXCIgLyogYmV0d2VlbkRvY3R5cGVQdWJsaWNBbmRTeXN0ZW1JZGVudGlmaWVycyAqLyk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gJz4nKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUuZW5kRG9jdHlwZSkgdGhpcy5kZWxlZ2F0ZS5lbmREb2N0eXBlKCk7XG4gICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG8oXCJiZWZvcmVEYXRhXCIgLyogYmVmb3JlRGF0YSAqLyk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gJ1wiJykge1xuICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvKFwiZG9jdHlwZVN5c3RlbUlkZW50aWZpZXJEb3VibGVRdW90ZWRcIiAvKiBkb2N0eXBlU3lzdGVtSWRlbnRpZmllckRvdWJsZVF1b3RlZCAqLyk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gXCInXCIpIHtcbiAgICAgICAgICB0aGlzLnRyYW5zaXRpb25UbyhcImRvY3R5cGVTeXN0ZW1JZGVudGlmaWVyU2luZ2xlUXVvdGVkXCIgLyogZG9jdHlwZVN5c3RlbUlkZW50aWZpZXJTaW5nbGVRdW90ZWQgKi8pO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBiZXR3ZWVuRG9jdHlwZVB1YmxpY0FuZFN5c3RlbUlkZW50aWZpZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaGFyID0gdGhpcy5jb25zdW1lKCk7XG4gICAgICAgIGlmIChpc1NwYWNlKGNoYXIpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPT09ICc+Jykge1xuICAgICAgICAgIGlmICh0aGlzLmRlbGVnYXRlLmVuZERvY3R5cGUpIHRoaXMuZGVsZWdhdGUuZW5kRG9jdHlwZSgpO1xuICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvKFwiYmVmb3JlRGF0YVwiIC8qIGJlZm9yZURhdGEgKi8pO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPT09ICdcIicpIHtcbiAgICAgICAgICB0aGlzLnRyYW5zaXRpb25UbyhcImRvY3R5cGVTeXN0ZW1JZGVudGlmaWVyRG91YmxlUXVvdGVkXCIgLyogZG9jdHlwZVN5c3RlbUlkZW50aWZpZXJEb3VibGVRdW90ZWQgKi8pO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPT09IFwiJ1wiKSB7XG4gICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG8oXCJkb2N0eXBlU3lzdGVtSWRlbnRpZmllclNpbmdsZVF1b3RlZFwiIC8qIGRvY3R5cGVTeXN0ZW1JZGVudGlmaWVyU2luZ2xlUXVvdGVkICovKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZG9jdHlwZVN5c3RlbUlkZW50aWZpZXJEb3VibGVRdW90ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNoYXIgPSB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgaWYgKGNoYXIgPT09ICdcIicpIHtcbiAgICAgICAgICB0aGlzLnRyYW5zaXRpb25UbyhcImFmdGVyRG9jdHlwZVN5c3RlbUlkZW50aWZpZXJcIiAvKiBhZnRlckRvY3R5cGVTeXN0ZW1JZGVudGlmaWVyICovKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID09PSAnPicpIHtcbiAgICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZS5lbmREb2N0eXBlKSB0aGlzLmRlbGVnYXRlLmVuZERvY3R5cGUoKTtcbiAgICAgICAgICB0aGlzLnRyYW5zaXRpb25UbyhcImJlZm9yZURhdGFcIiAvKiBiZWZvcmVEYXRhICovKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZS5hcHBlbmRUb0RvY3R5cGVTeXN0ZW1JZGVudGlmaWVyKSB0aGlzLmRlbGVnYXRlLmFwcGVuZFRvRG9jdHlwZVN5c3RlbUlkZW50aWZpZXIoY2hhcik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkb2N0eXBlU3lzdGVtSWRlbnRpZmllclNpbmdsZVF1b3RlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2hhciA9IHRoaXMuY29uc3VtZSgpO1xuICAgICAgICBpZiAoY2hhciA9PT0gXCInXCIpIHtcbiAgICAgICAgICB0aGlzLnRyYW5zaXRpb25UbyhcImFmdGVyRG9jdHlwZVN5c3RlbUlkZW50aWZpZXJcIiAvKiBhZnRlckRvY3R5cGVTeXN0ZW1JZGVudGlmaWVyICovKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID09PSAnPicpIHtcbiAgICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZS5lbmREb2N0eXBlKSB0aGlzLmRlbGVnYXRlLmVuZERvY3R5cGUoKTtcbiAgICAgICAgICB0aGlzLnRyYW5zaXRpb25UbyhcImJlZm9yZURhdGFcIiAvKiBiZWZvcmVEYXRhICovKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZS5hcHBlbmRUb0RvY3R5cGVTeXN0ZW1JZGVudGlmaWVyKSB0aGlzLmRlbGVnYXRlLmFwcGVuZFRvRG9jdHlwZVN5c3RlbUlkZW50aWZpZXIoY2hhcik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhZnRlckRvY3R5cGVTeXN0ZW1JZGVudGlmaWVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaGFyID0gdGhpcy5jb25zdW1lKCk7XG4gICAgICAgIGlmIChpc1NwYWNlKGNoYXIpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPT09ICc+Jykge1xuICAgICAgICAgIGlmICh0aGlzLmRlbGVnYXRlLmVuZERvY3R5cGUpIHRoaXMuZGVsZWdhdGUuZW5kRG9jdHlwZSgpO1xuICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvKFwiYmVmb3JlRGF0YVwiIC8qIGJlZm9yZURhdGEgKi8pO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBjb21tZW50U3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNoYXIgPSB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgaWYgKGNoYXIgPT09ICctJykge1xuICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvKFwiY29tbWVudFN0YXJ0RGFzaFwiIC8qIGNvbW1lbnRTdGFydERhc2ggKi8pO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPT09ICc+Jykge1xuICAgICAgICAgIHRoaXMuZGVsZWdhdGUuZmluaXNoQ29tbWVudCgpO1xuICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvKFwiYmVmb3JlRGF0YVwiIC8qIGJlZm9yZURhdGEgKi8pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZGVsZWdhdGUuYXBwZW5kVG9Db21tZW50RGF0YShjaGFyKTtcbiAgICAgICAgICB0aGlzLnRyYW5zaXRpb25UbyhcImNvbW1lbnRcIiAvKiBjb21tZW50ICovKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgY29tbWVudFN0YXJ0RGFzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2hhciA9IHRoaXMuY29uc3VtZSgpO1xuICAgICAgICBpZiAoY2hhciA9PT0gJy0nKSB7XG4gICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG8oXCJjb21tZW50RW5kXCIgLyogY29tbWVudEVuZCAqLyk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gJz4nKSB7XG4gICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5maW5pc2hDb21tZW50KCk7XG4gICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG8oXCJiZWZvcmVEYXRhXCIgLyogYmVmb3JlRGF0YSAqLyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5hcHBlbmRUb0NvbW1lbnREYXRhKCctJyk7XG4gICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG8oXCJjb21tZW50XCIgLyogY29tbWVudCAqLyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGNvbW1lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNoYXIgPSB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgaWYgKGNoYXIgPT09ICctJykge1xuICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvKFwiY29tbWVudEVuZERhc2hcIiAvKiBjb21tZW50RW5kRGFzaCAqLyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5hcHBlbmRUb0NvbW1lbnREYXRhKGNoYXIpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY29tbWVudEVuZERhc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNoYXIgPSB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgaWYgKGNoYXIgPT09ICctJykge1xuICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvKFwiY29tbWVudEVuZFwiIC8qIGNvbW1lbnRFbmQgKi8pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZGVsZWdhdGUuYXBwZW5kVG9Db21tZW50RGF0YSgnLScgKyBjaGFyKTtcbiAgICAgICAgICB0aGlzLnRyYW5zaXRpb25UbyhcImNvbW1lbnRcIiAvKiBjb21tZW50ICovKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgY29tbWVudEVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2hhciA9IHRoaXMuY29uc3VtZSgpO1xuICAgICAgICBpZiAoY2hhciA9PT0gJz4nKSB7XG4gICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5maW5pc2hDb21tZW50KCk7XG4gICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG8oXCJiZWZvcmVEYXRhXCIgLyogYmVmb3JlRGF0YSAqLyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5hcHBlbmRUb0NvbW1lbnREYXRhKCctLScgKyBjaGFyKTtcbiAgICAgICAgICB0aGlzLnRyYW5zaXRpb25UbyhcImNvbW1lbnRcIiAvKiBjb21tZW50ICovKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgdGFnTmFtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2hhciA9IHRoaXMuY29uc3VtZSgpO1xuICAgICAgICBpZiAoaXNTcGFjZShjaGFyKSkge1xuICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvKFwiYmVmb3JlQXR0cmlidXRlTmFtZVwiIC8qIGJlZm9yZUF0dHJpYnV0ZU5hbWUgKi8pO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPT09ICcvJykge1xuICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvKFwic2VsZkNsb3NpbmdTdGFydFRhZ1wiIC8qIHNlbGZDbG9zaW5nU3RhcnRUYWcgKi8pO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPT09ICc+Jykge1xuICAgICAgICAgIHRoaXMuZGVsZWdhdGUuZmluaXNoVGFnKCk7XG4gICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG8oXCJiZWZvcmVEYXRhXCIgLyogYmVmb3JlRGF0YSAqLyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5hcHBlbmRUb1RhZ05hbWUoY2hhcik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBlbmRUYWdOYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaGFyID0gdGhpcy5jb25zdW1lKCk7XG4gICAgICAgIGlmIChpc1NwYWNlKGNoYXIpKSB7XG4gICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG8oXCJiZWZvcmVBdHRyaWJ1dGVOYW1lXCIgLyogYmVmb3JlQXR0cmlidXRlTmFtZSAqLyk7XG4gICAgICAgICAgdGhpcy50YWdOYW1lQnVmZmVyID0gJyc7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gJy8nKSB7XG4gICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG8oXCJzZWxmQ2xvc2luZ1N0YXJ0VGFnXCIgLyogc2VsZkNsb3NpbmdTdGFydFRhZyAqLyk7XG4gICAgICAgICAgdGhpcy50YWdOYW1lQnVmZmVyID0gJyc7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gJz4nKSB7XG4gICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5maW5pc2hUYWcoKTtcbiAgICAgICAgICB0aGlzLnRyYW5zaXRpb25UbyhcImJlZm9yZURhdGFcIiAvKiBiZWZvcmVEYXRhICovKTtcbiAgICAgICAgICB0aGlzLnRhZ05hbWVCdWZmZXIgPSAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmFwcGVuZFRvVGFnTmFtZShjaGFyKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGJlZm9yZUF0dHJpYnV0ZU5hbWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNoYXIgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgaWYgKGlzU3BhY2UoY2hhcikpIHtcbiAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gJy8nKSB7XG4gICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG8oXCJzZWxmQ2xvc2luZ1N0YXJ0VGFnXCIgLyogc2VsZkNsb3NpbmdTdGFydFRhZyAqLyk7XG4gICAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gJz4nKSB7XG4gICAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5maW5pc2hUYWcoKTtcbiAgICAgICAgICB0aGlzLnRyYW5zaXRpb25UbyhcImJlZm9yZURhdGFcIiAvKiBiZWZvcmVEYXRhICovKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID09PSAnPScpIHtcbiAgICAgICAgICB0aGlzLmRlbGVnYXRlLnJlcG9ydFN5bnRheEVycm9yKCdhdHRyaWJ1dGUgbmFtZSBjYW5ub3Qgc3RhcnQgd2l0aCBlcXVhbHMgc2lnbicpO1xuICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvKFwiYXR0cmlidXRlTmFtZVwiIC8qIGF0dHJpYnV0ZU5hbWUgKi8pO1xuICAgICAgICAgIHRoaXMuZGVsZWdhdGUuYmVnaW5BdHRyaWJ1dGUoKTtcbiAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgICB0aGlzLmRlbGVnYXRlLmFwcGVuZFRvQXR0cmlidXRlTmFtZShjaGFyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnRyYW5zaXRpb25UbyhcImF0dHJpYnV0ZU5hbWVcIiAvKiBhdHRyaWJ1dGVOYW1lICovKTtcbiAgICAgICAgICB0aGlzLmRlbGVnYXRlLmJlZ2luQXR0cmlidXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhdHRyaWJ1dGVOYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaGFyID0gdGhpcy5wZWVrKCk7XG4gICAgICAgIGlmIChpc1NwYWNlKGNoYXIpKSB7XG4gICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG8oXCJhZnRlckF0dHJpYnV0ZU5hbWVcIiAvKiBhZnRlckF0dHJpYnV0ZU5hbWUgKi8pO1xuICAgICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPT09ICcvJykge1xuICAgICAgICAgIHRoaXMuZGVsZWdhdGUuYmVnaW5BdHRyaWJ1dGVWYWx1ZShmYWxzZSk7XG4gICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5maW5pc2hBdHRyaWJ1dGVWYWx1ZSgpO1xuICAgICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvKFwic2VsZkNsb3NpbmdTdGFydFRhZ1wiIC8qIHNlbGZDbG9zaW5nU3RhcnRUYWcgKi8pO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPT09ICc9Jykge1xuICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvKFwiYmVmb3JlQXR0cmlidXRlVmFsdWVcIiAvKiBiZWZvcmVBdHRyaWJ1dGVWYWx1ZSAqLyk7XG4gICAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gJz4nKSB7XG4gICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5iZWdpbkF0dHJpYnV0ZVZhbHVlKGZhbHNlKTtcbiAgICAgICAgICB0aGlzLmRlbGVnYXRlLmZpbmlzaEF0dHJpYnV0ZVZhbHVlKCk7XG4gICAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5maW5pc2hUYWcoKTtcbiAgICAgICAgICB0aGlzLnRyYW5zaXRpb25UbyhcImJlZm9yZURhdGFcIiAvKiBiZWZvcmVEYXRhICovKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID09PSAnXCInIHx8IGNoYXIgPT09IFwiJ1wiIHx8IGNoYXIgPT09ICc8Jykge1xuICAgICAgICAgIHRoaXMuZGVsZWdhdGUucmVwb3J0U3ludGF4RXJyb3IoY2hhciArICcgaXMgbm90IGEgdmFsaWQgY2hhcmFjdGVyIHdpdGhpbiBhdHRyaWJ1dGUgbmFtZXMnKTtcbiAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgICB0aGlzLmRlbGVnYXRlLmFwcGVuZFRvQXR0cmlidXRlTmFtZShjaGFyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgICB0aGlzLmRlbGVnYXRlLmFwcGVuZFRvQXR0cmlidXRlTmFtZShjaGFyKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFmdGVyQXR0cmlidXRlTmFtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2hhciA9IHRoaXMucGVlaygpO1xuICAgICAgICBpZiAoaXNTcGFjZShjaGFyKSkge1xuICAgICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID09PSAnLycpIHtcbiAgICAgICAgICB0aGlzLmRlbGVnYXRlLmJlZ2luQXR0cmlidXRlVmFsdWUoZmFsc2UpO1xuICAgICAgICAgIHRoaXMuZGVsZWdhdGUuZmluaXNoQXR0cmlidXRlVmFsdWUoKTtcbiAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgICB0aGlzLnRyYW5zaXRpb25UbyhcInNlbGZDbG9zaW5nU3RhcnRUYWdcIiAvKiBzZWxmQ2xvc2luZ1N0YXJ0VGFnICovKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID09PSAnPScpIHtcbiAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgICB0aGlzLnRyYW5zaXRpb25UbyhcImJlZm9yZUF0dHJpYnV0ZVZhbHVlXCIgLyogYmVmb3JlQXR0cmlidXRlVmFsdWUgKi8pO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPT09ICc+Jykge1xuICAgICAgICAgIHRoaXMuZGVsZWdhdGUuYmVnaW5BdHRyaWJ1dGVWYWx1ZShmYWxzZSk7XG4gICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5maW5pc2hBdHRyaWJ1dGVWYWx1ZSgpO1xuICAgICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgICAgIHRoaXMuZGVsZWdhdGUuZmluaXNoVGFnKCk7XG4gICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG8oXCJiZWZvcmVEYXRhXCIgLyogYmVmb3JlRGF0YSAqLyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5iZWdpbkF0dHJpYnV0ZVZhbHVlKGZhbHNlKTtcbiAgICAgICAgICB0aGlzLmRlbGVnYXRlLmZpbmlzaEF0dHJpYnV0ZVZhbHVlKCk7XG4gICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG8oXCJhdHRyaWJ1dGVOYW1lXCIgLyogYXR0cmlidXRlTmFtZSAqLyk7XG4gICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5iZWdpbkF0dHJpYnV0ZSgpO1xuICAgICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgICAgIHRoaXMuZGVsZWdhdGUuYXBwZW5kVG9BdHRyaWJ1dGVOYW1lKGNoYXIpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYmVmb3JlQXR0cmlidXRlVmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNoYXIgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgaWYgKGlzU3BhY2UoY2hhcikpIHtcbiAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID09PSAnXCInKSB7XG4gICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG8oXCJhdHRyaWJ1dGVWYWx1ZURvdWJsZVF1b3RlZFwiIC8qIGF0dHJpYnV0ZVZhbHVlRG91YmxlUXVvdGVkICovKTtcbiAgICAgICAgICB0aGlzLmRlbGVnYXRlLmJlZ2luQXR0cmlidXRlVmFsdWUodHJ1ZSk7XG4gICAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gXCInXCIpIHtcbiAgICAgICAgICB0aGlzLnRyYW5zaXRpb25UbyhcImF0dHJpYnV0ZVZhbHVlU2luZ2xlUXVvdGVkXCIgLyogYXR0cmlidXRlVmFsdWVTaW5nbGVRdW90ZWQgKi8pO1xuICAgICAgICAgIHRoaXMuZGVsZWdhdGUuYmVnaW5BdHRyaWJ1dGVWYWx1ZSh0cnVlKTtcbiAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID09PSAnPicpIHtcbiAgICAgICAgICB0aGlzLmRlbGVnYXRlLmJlZ2luQXR0cmlidXRlVmFsdWUoZmFsc2UpO1xuICAgICAgICAgIHRoaXMuZGVsZWdhdGUuZmluaXNoQXR0cmlidXRlVmFsdWUoKTtcbiAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgICB0aGlzLmRlbGVnYXRlLmZpbmlzaFRhZygpO1xuICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvKFwiYmVmb3JlRGF0YVwiIC8qIGJlZm9yZURhdGEgKi8pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvKFwiYXR0cmlidXRlVmFsdWVVbnF1b3RlZFwiIC8qIGF0dHJpYnV0ZVZhbHVlVW5xdW90ZWQgKi8pO1xuICAgICAgICAgIHRoaXMuZGVsZWdhdGUuYmVnaW5BdHRyaWJ1dGVWYWx1ZShmYWxzZSk7XG4gICAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5hcHBlbmRUb0F0dHJpYnV0ZVZhbHVlKGNoYXIpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYXR0cmlidXRlVmFsdWVEb3VibGVRdW90ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNoYXIgPSB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgaWYgKGNoYXIgPT09ICdcIicpIHtcbiAgICAgICAgICB0aGlzLmRlbGVnYXRlLmZpbmlzaEF0dHJpYnV0ZVZhbHVlKCk7XG4gICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG8oXCJhZnRlckF0dHJpYnV0ZVZhbHVlUXVvdGVkXCIgLyogYWZ0ZXJBdHRyaWJ1dGVWYWx1ZVF1b3RlZCAqLyk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gJyYnKSB7XG4gICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5hcHBlbmRUb0F0dHJpYnV0ZVZhbHVlKHRoaXMuY29uc3VtZUNoYXJSZWYoKSB8fCAnJicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZGVsZWdhdGUuYXBwZW5kVG9BdHRyaWJ1dGVWYWx1ZShjaGFyKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGF0dHJpYnV0ZVZhbHVlU2luZ2xlUXVvdGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaGFyID0gdGhpcy5jb25zdW1lKCk7XG4gICAgICAgIGlmIChjaGFyID09PSBcIidcIikge1xuICAgICAgICAgIHRoaXMuZGVsZWdhdGUuZmluaXNoQXR0cmlidXRlVmFsdWUoKTtcbiAgICAgICAgICB0aGlzLnRyYW5zaXRpb25UbyhcImFmdGVyQXR0cmlidXRlVmFsdWVRdW90ZWRcIiAvKiBhZnRlckF0dHJpYnV0ZVZhbHVlUXVvdGVkICovKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID09PSAnJicpIHtcbiAgICAgICAgICB0aGlzLmRlbGVnYXRlLmFwcGVuZFRvQXR0cmlidXRlVmFsdWUodGhpcy5jb25zdW1lQ2hhclJlZigpIHx8ICcmJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5hcHBlbmRUb0F0dHJpYnV0ZVZhbHVlKGNoYXIpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYXR0cmlidXRlVmFsdWVVbnF1b3RlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2hhciA9IHRoaXMucGVlaygpO1xuICAgICAgICBpZiAoaXNTcGFjZShjaGFyKSkge1xuICAgICAgICAgIHRoaXMuZGVsZWdhdGUuZmluaXNoQXR0cmlidXRlVmFsdWUoKTtcbiAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgICB0aGlzLnRyYW5zaXRpb25UbyhcImJlZm9yZUF0dHJpYnV0ZU5hbWVcIiAvKiBiZWZvcmVBdHRyaWJ1dGVOYW1lICovKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID09PSAnLycpIHtcbiAgICAgICAgICB0aGlzLmRlbGVnYXRlLmZpbmlzaEF0dHJpYnV0ZVZhbHVlKCk7XG4gICAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG8oXCJzZWxmQ2xvc2luZ1N0YXJ0VGFnXCIgLyogc2VsZkNsb3NpbmdTdGFydFRhZyAqLyk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gJyYnKSB7XG4gICAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5hcHBlbmRUb0F0dHJpYnV0ZVZhbHVlKHRoaXMuY29uc3VtZUNoYXJSZWYoKSB8fCAnJicpO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPT09ICc+Jykge1xuICAgICAgICAgIHRoaXMuZGVsZWdhdGUuZmluaXNoQXR0cmlidXRlVmFsdWUoKTtcbiAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgICB0aGlzLmRlbGVnYXRlLmZpbmlzaFRhZygpO1xuICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvKFwiYmVmb3JlRGF0YVwiIC8qIGJlZm9yZURhdGEgKi8pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgICAgIHRoaXMuZGVsZWdhdGUuYXBwZW5kVG9BdHRyaWJ1dGVWYWx1ZShjaGFyKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFmdGVyQXR0cmlidXRlVmFsdWVRdW90ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNoYXIgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgaWYgKGlzU3BhY2UoY2hhcikpIHtcbiAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgICB0aGlzLnRyYW5zaXRpb25UbyhcImJlZm9yZUF0dHJpYnV0ZU5hbWVcIiAvKiBiZWZvcmVBdHRyaWJ1dGVOYW1lICovKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID09PSAnLycpIHtcbiAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgICB0aGlzLnRyYW5zaXRpb25UbyhcInNlbGZDbG9zaW5nU3RhcnRUYWdcIiAvKiBzZWxmQ2xvc2luZ1N0YXJ0VGFnICovKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID09PSAnPicpIHtcbiAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgICB0aGlzLmRlbGVnYXRlLmZpbmlzaFRhZygpO1xuICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvKFwiYmVmb3JlRGF0YVwiIC8qIGJlZm9yZURhdGEgKi8pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvKFwiYmVmb3JlQXR0cmlidXRlTmFtZVwiIC8qIGJlZm9yZUF0dHJpYnV0ZU5hbWUgKi8pO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBzZWxmQ2xvc2luZ1N0YXJ0VGFnOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaGFyID0gdGhpcy5wZWVrKCk7XG4gICAgICAgIGlmIChjaGFyID09PSAnPicpIHtcbiAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgICB0aGlzLmRlbGVnYXRlLm1hcmtUYWdBc1NlbGZDbG9zaW5nKCk7XG4gICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5maW5pc2hUYWcoKTtcbiAgICAgICAgICB0aGlzLnRyYW5zaXRpb25UbyhcImJlZm9yZURhdGFcIiAvKiBiZWZvcmVEYXRhICovKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnRyYW5zaXRpb25UbyhcImJlZm9yZUF0dHJpYnV0ZU5hbWVcIiAvKiBiZWZvcmVBdHRyaWJ1dGVOYW1lICovKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZW5kVGFnT3BlbjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2hhciA9IHRoaXMuY29uc3VtZSgpO1xuICAgICAgICBpZiAoY2hhciA9PT0gJ0AnIHx8IGNoYXIgPT09ICc6JyB8fCBpc0FscGhhKGNoYXIpKSB7XG4gICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG8oXCJlbmRUYWdOYW1lXCIgLyogZW5kVGFnTmFtZSAqLyk7XG4gICAgICAgICAgdGhpcy50YWdOYW1lQnVmZmVyID0gJyc7XG4gICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5iZWdpbkVuZFRhZygpO1xuICAgICAgICAgIHRoaXMuYXBwZW5kVG9UYWdOYW1lKGNoYXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cbiAgRXZlbnRlZFRva2VuaXplci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy50cmFuc2l0aW9uVG8oXCJiZWZvcmVEYXRhXCIgLyogYmVmb3JlRGF0YSAqLyk7XG4gICAgdGhpcy5pbnB1dCA9ICcnO1xuICAgIHRoaXMudGFnTmFtZUJ1ZmZlciA9ICcnO1xuICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIHRoaXMubGluZSA9IDE7XG4gICAgdGhpcy5jb2x1bW4gPSAwO1xuICAgIHRoaXMuZGVsZWdhdGUucmVzZXQoKTtcbiAgfTtcbiAgRXZlbnRlZFRva2VuaXplci5wcm90b3R5cGUudHJhbnNpdGlvblRvID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICB9O1xuICBFdmVudGVkVG9rZW5pemVyLnByb3RvdHlwZS50b2tlbml6ZSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIHRoaXMucmVzZXQoKTtcbiAgICB0aGlzLnRva2VuaXplUGFydChpbnB1dCk7XG4gICAgdGhpcy50b2tlbml6ZUVPRigpO1xuICB9O1xuICBFdmVudGVkVG9rZW5pemVyLnByb3RvdHlwZS50b2tlbml6ZVBhcnQgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICB0aGlzLmlucHV0ICs9IHByZXByb2Nlc3NJbnB1dChpbnB1dCk7XG4gICAgd2hpbGUgKHRoaXMuaW5kZXggPCB0aGlzLmlucHV0Lmxlbmd0aCkge1xuICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzLnN0YXRlc1t0aGlzLnN0YXRlXTtcbiAgICAgIGlmIChoYW5kbGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5oYW5kbGVkIHN0YXRlIFwiICsgdGhpcy5zdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBFdmVudGVkVG9rZW5pemVyLnByb3RvdHlwZS50b2tlbml6ZUVPRiA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZsdXNoRGF0YSgpO1xuICB9O1xuICBFdmVudGVkVG9rZW5pemVyLnByb3RvdHlwZS5mbHVzaERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09ICdkYXRhJykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZS5maW5pc2hEYXRhKCk7XG4gICAgICB0aGlzLnRyYW5zaXRpb25UbyhcImJlZm9yZURhdGFcIiAvKiBiZWZvcmVEYXRhICovKTtcbiAgICB9XG4gIH07XG5cbiAgRXZlbnRlZFRva2VuaXplci5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnB1dC5jaGFyQXQodGhpcy5pbmRleCk7XG4gIH07XG4gIEV2ZW50ZWRUb2tlbml6ZXIucHJvdG90eXBlLmNvbnN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNoYXIgPSB0aGlzLnBlZWsoKTtcbiAgICB0aGlzLmluZGV4Kys7XG4gICAgaWYgKGNoYXIgPT09ICdcXG4nKSB7XG4gICAgICB0aGlzLmxpbmUrKztcbiAgICAgIHRoaXMuY29sdW1uID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb2x1bW4rKztcbiAgICB9XG4gICAgcmV0dXJuIGNoYXI7XG4gIH07XG4gIEV2ZW50ZWRUb2tlbml6ZXIucHJvdG90eXBlLmNvbnN1bWVDaGFyUmVmID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbmRJbmRleCA9IHRoaXMuaW5wdXQuaW5kZXhPZignOycsIHRoaXMuaW5kZXgpO1xuICAgIGlmIChlbmRJbmRleCA9PT0gLTEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGVudGl0eSA9IHRoaXMuaW5wdXQuc2xpY2UodGhpcy5pbmRleCwgZW5kSW5kZXgpO1xuICAgIHZhciBjaGFycyA9IHRoaXMuZW50aXR5UGFyc2VyLnBhcnNlKGVudGl0eSk7XG4gICAgaWYgKGNoYXJzKSB7XG4gICAgICB2YXIgY291bnQgPSBlbnRpdHkubGVuZ3RoO1xuICAgICAgLy8gY29uc3VtZSB0aGUgZW50aXR5IGNoYXJzXG4gICAgICB3aGlsZSAoY291bnQpIHtcbiAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICAgIGNvdW50LS07XG4gICAgICB9XG4gICAgICAvLyBjb25zdW1lIHRoZSBgO2BcbiAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgcmV0dXJuIGNoYXJzO1xuICAgIH1cbiAgfTtcbiAgRXZlbnRlZFRva2VuaXplci5wcm90b3R5cGUubWFya1RhZ1N0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGVsZWdhdGUudGFnT3BlbigpO1xuICB9O1xuICBFdmVudGVkVG9rZW5pemVyLnByb3RvdHlwZS5hcHBlbmRUb1RhZ05hbWUgPSBmdW5jdGlvbiAoY2hhcikge1xuICAgIHRoaXMudGFnTmFtZUJ1ZmZlciArPSBjaGFyO1xuICAgIHRoaXMuZGVsZWdhdGUuYXBwZW5kVG9UYWdOYW1lKGNoYXIpO1xuICB9O1xuICBFdmVudGVkVG9rZW5pemVyLnByb3RvdHlwZS5pc0lnbm9yZWRFbmRUYWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRhZyA9IHRoaXMudGFnTmFtZUJ1ZmZlcjtcbiAgICByZXR1cm4gdGFnID09PSAndGl0bGUnICYmIHRoaXMuaW5wdXQuc3Vic3RyaW5nKHRoaXMuaW5kZXgsIHRoaXMuaW5kZXggKyA4KSAhPT0gJzwvdGl0bGU+JyB8fCB0YWcgPT09ICdzdHlsZScgJiYgdGhpcy5pbnB1dC5zdWJzdHJpbmcodGhpcy5pbmRleCwgdGhpcy5pbmRleCArIDgpICE9PSAnPC9zdHlsZT4nIHx8IHRhZyA9PT0gJ3NjcmlwdCcgJiYgdGhpcy5pbnB1dC5zdWJzdHJpbmcodGhpcy5pbmRleCwgdGhpcy5pbmRleCArIDkpICE9PSAnPC9zY3JpcHQ+JztcbiAgfTtcbiAgcmV0dXJuIEV2ZW50ZWRUb2tlbml6ZXI7XG59KCk7XG52YXIgVG9rZW5pemVyID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVG9rZW5pemVyKGVudGl0eVBhcnNlciwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnRva2VuID0gbnVsbDtcbiAgICB0aGlzLnN0YXJ0TGluZSA9IDE7XG4gICAgdGhpcy5zdGFydENvbHVtbiA9IDA7XG4gICAgdGhpcy50b2tlbnMgPSBbXTtcbiAgICB0aGlzLnRva2VuaXplciA9IG5ldyBFdmVudGVkVG9rZW5pemVyKHRoaXMsIGVudGl0eVBhcnNlciwgb3B0aW9ucy5tb2RlKTtcbiAgICB0aGlzLl9jdXJyZW50QXR0cmlidXRlID0gdW5kZWZpbmVkO1xuICB9XG4gIFRva2VuaXplci5wcm90b3R5cGUudG9rZW5pemUgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICB0aGlzLnRva2VucyA9IFtdO1xuICAgIHRoaXMudG9rZW5pemVyLnRva2VuaXplKGlucHV0KTtcbiAgICByZXR1cm4gdGhpcy50b2tlbnM7XG4gIH07XG4gIFRva2VuaXplci5wcm90b3R5cGUudG9rZW5pemVQYXJ0ID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgdGhpcy50b2tlbnMgPSBbXTtcbiAgICB0aGlzLnRva2VuaXplci50b2tlbml6ZVBhcnQoaW5wdXQpO1xuICAgIHJldHVybiB0aGlzLnRva2VucztcbiAgfTtcbiAgVG9rZW5pemVyLnByb3RvdHlwZS50b2tlbml6ZUVPRiA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnRva2VucyA9IFtdO1xuICAgIHRoaXMudG9rZW5pemVyLnRva2VuaXplRU9GKCk7XG4gICAgcmV0dXJuIHRoaXMudG9rZW5zWzBdO1xuICB9O1xuICBUb2tlbml6ZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudG9rZW4gPSBudWxsO1xuICAgIHRoaXMuc3RhcnRMaW5lID0gMTtcbiAgICB0aGlzLnN0YXJ0Q29sdW1uID0gMDtcbiAgfTtcbiAgVG9rZW5pemVyLnByb3RvdHlwZS5jdXJyZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0b2tlbiA9IHRoaXMudG9rZW47XG4gICAgaWYgKHRva2VuID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Rva2VuIHdhcyB1bmV4cGVjdGVkbHkgbnVsbCcpO1xuICAgIH1cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRva2VuLnR5cGUgPT09IGFyZ3VtZW50c1tpXSkge1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcInRva2VuIHR5cGUgd2FzIHVuZXhwZWN0ZWRseSBcIiArIHRva2VuLnR5cGUpO1xuICB9O1xuICBUb2tlbml6ZXIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgdGhpcy50b2tlbnMucHVzaCh0b2tlbik7XG4gIH07XG4gIFRva2VuaXplci5wcm90b3R5cGUuY3VycmVudEF0dHJpYnV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudEF0dHJpYnV0ZTtcbiAgfTtcbiAgVG9rZW5pemVyLnByb3RvdHlwZS5hZGRMb2NJbmZvID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMubG9jKSB7XG4gICAgICB0aGlzLmN1cnJlbnQoKS5sb2MgPSB7XG4gICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgbGluZTogdGhpcy5zdGFydExpbmUsXG4gICAgICAgICAgY29sdW1uOiB0aGlzLnN0YXJ0Q29sdW1uXG4gICAgICAgIH0sXG4gICAgICAgIGVuZDoge1xuICAgICAgICAgIGxpbmU6IHRoaXMudG9rZW5pemVyLmxpbmUsXG4gICAgICAgICAgY29sdW1uOiB0aGlzLnRva2VuaXplci5jb2x1bW5cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5zdGFydExpbmUgPSB0aGlzLnRva2VuaXplci5saW5lO1xuICAgIHRoaXMuc3RhcnRDb2x1bW4gPSB0aGlzLnRva2VuaXplci5jb2x1bW47XG4gIH07XG4gIC8vIERhdGFcbiAgVG9rZW5pemVyLnByb3RvdHlwZS5iZWdpbkRvY3R5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5wdXNoKHtcbiAgICAgIHR5cGU6IFwiRG9jdHlwZVwiIC8qIERvY3R5cGUgKi8sXG4gICAgICBuYW1lOiAnJ1xuICAgIH0pO1xuICB9O1xuICBUb2tlbml6ZXIucHJvdG90eXBlLmFwcGVuZFRvRG9jdHlwZU5hbWUgPSBmdW5jdGlvbiAoY2hhcikge1xuICAgIHRoaXMuY3VycmVudChcIkRvY3R5cGVcIiAvKiBEb2N0eXBlICovKS5uYW1lICs9IGNoYXI7XG4gIH07XG4gIFRva2VuaXplci5wcm90b3R5cGUuYXBwZW5kVG9Eb2N0eXBlUHVibGljSWRlbnRpZmllciA9IGZ1bmN0aW9uIChjaGFyKSB7XG4gICAgdmFyIGRvY3R5cGUgPSB0aGlzLmN1cnJlbnQoXCJEb2N0eXBlXCIgLyogRG9jdHlwZSAqLyk7XG4gICAgaWYgKGRvY3R5cGUucHVibGljSWRlbnRpZmllciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBkb2N0eXBlLnB1YmxpY0lkZW50aWZpZXIgPSBjaGFyO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb2N0eXBlLnB1YmxpY0lkZW50aWZpZXIgKz0gY2hhcjtcbiAgICB9XG4gIH07XG4gIFRva2VuaXplci5wcm90b3R5cGUuYXBwZW5kVG9Eb2N0eXBlU3lzdGVtSWRlbnRpZmllciA9IGZ1bmN0aW9uIChjaGFyKSB7XG4gICAgdmFyIGRvY3R5cGUgPSB0aGlzLmN1cnJlbnQoXCJEb2N0eXBlXCIgLyogRG9jdHlwZSAqLyk7XG4gICAgaWYgKGRvY3R5cGUuc3lzdGVtSWRlbnRpZmllciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBkb2N0eXBlLnN5c3RlbUlkZW50aWZpZXIgPSBjaGFyO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb2N0eXBlLnN5c3RlbUlkZW50aWZpZXIgKz0gY2hhcjtcbiAgICB9XG4gIH07XG4gIFRva2VuaXplci5wcm90b3R5cGUuZW5kRG9jdHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFkZExvY0luZm8oKTtcbiAgfTtcbiAgVG9rZW5pemVyLnByb3RvdHlwZS5iZWdpbkRhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5wdXNoKHtcbiAgICAgIHR5cGU6IFwiQ2hhcnNcIiAvKiBDaGFycyAqLyxcbiAgICAgIGNoYXJzOiAnJ1xuICAgIH0pO1xuICB9O1xuICBUb2tlbml6ZXIucHJvdG90eXBlLmFwcGVuZFRvRGF0YSA9IGZ1bmN0aW9uIChjaGFyKSB7XG4gICAgdGhpcy5jdXJyZW50KFwiQ2hhcnNcIiAvKiBDaGFycyAqLykuY2hhcnMgKz0gY2hhcjtcbiAgfTtcbiAgVG9rZW5pemVyLnByb3RvdHlwZS5maW5pc2hEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYWRkTG9jSW5mbygpO1xuICB9O1xuICAvLyBDb21tZW50XG4gIFRva2VuaXplci5wcm90b3R5cGUuYmVnaW5Db21tZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucHVzaCh7XG4gICAgICB0eXBlOiBcIkNvbW1lbnRcIiAvKiBDb21tZW50ICovLFxuICAgICAgY2hhcnM6ICcnXG4gICAgfSk7XG4gIH07XG4gIFRva2VuaXplci5wcm90b3R5cGUuYXBwZW5kVG9Db21tZW50RGF0YSA9IGZ1bmN0aW9uIChjaGFyKSB7XG4gICAgdGhpcy5jdXJyZW50KFwiQ29tbWVudFwiIC8qIENvbW1lbnQgKi8pLmNoYXJzICs9IGNoYXI7XG4gIH07XG4gIFRva2VuaXplci5wcm90b3R5cGUuZmluaXNoQ29tbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFkZExvY0luZm8oKTtcbiAgfTtcbiAgLy8gVGFncyAtIGJhc2ljXG4gIFRva2VuaXplci5wcm90b3R5cGUudGFnT3BlbiA9IGZ1bmN0aW9uICgpIHt9O1xuICBUb2tlbml6ZXIucHJvdG90eXBlLmJlZ2luU3RhcnRUYWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5wdXNoKHtcbiAgICAgIHR5cGU6IFwiU3RhcnRUYWdcIiAvKiBTdGFydFRhZyAqLyxcbiAgICAgIHRhZ05hbWU6ICcnLFxuICAgICAgYXR0cmlidXRlczogW10sXG4gICAgICBzZWxmQ2xvc2luZzogZmFsc2VcbiAgICB9KTtcbiAgfTtcbiAgVG9rZW5pemVyLnByb3RvdHlwZS5iZWdpbkVuZFRhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnB1c2goe1xuICAgICAgdHlwZTogXCJFbmRUYWdcIiAvKiBFbmRUYWcgKi8sXG4gICAgICB0YWdOYW1lOiAnJ1xuICAgIH0pO1xuICB9O1xuICBUb2tlbml6ZXIucHJvdG90eXBlLmZpbmlzaFRhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFkZExvY0luZm8oKTtcbiAgfTtcbiAgVG9rZW5pemVyLnByb3RvdHlwZS5tYXJrVGFnQXNTZWxmQ2xvc2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmN1cnJlbnQoXCJTdGFydFRhZ1wiIC8qIFN0YXJ0VGFnICovKS5zZWxmQ2xvc2luZyA9IHRydWU7XG4gIH07XG4gIC8vIFRhZ3MgLSBuYW1lXG4gIFRva2VuaXplci5wcm90b3R5cGUuYXBwZW5kVG9UYWdOYW1lID0gZnVuY3Rpb24gKGNoYXIpIHtcbiAgICB0aGlzLmN1cnJlbnQoXCJTdGFydFRhZ1wiIC8qIFN0YXJ0VGFnICovLCBcIkVuZFRhZ1wiIC8qIEVuZFRhZyAqLykudGFnTmFtZSArPSBjaGFyO1xuICB9O1xuICAvLyBUYWdzIC0gYXR0cmlidXRlc1xuICBUb2tlbml6ZXIucHJvdG90eXBlLmJlZ2luQXR0cmlidXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2N1cnJlbnRBdHRyaWJ1dGUgPSBbJycsICcnLCBmYWxzZV07XG4gIH07XG4gIFRva2VuaXplci5wcm90b3R5cGUuYXBwZW5kVG9BdHRyaWJ1dGVOYW1lID0gZnVuY3Rpb24gKGNoYXIpIHtcbiAgICB0aGlzLmN1cnJlbnRBdHRyaWJ1dGUoKVswXSArPSBjaGFyO1xuICB9O1xuICBUb2tlbml6ZXIucHJvdG90eXBlLmJlZ2luQXR0cmlidXRlVmFsdWUgPSBmdW5jdGlvbiAoaXNRdW90ZWQpIHtcbiAgICB0aGlzLmN1cnJlbnRBdHRyaWJ1dGUoKVsyXSA9IGlzUXVvdGVkO1xuICB9O1xuICBUb2tlbml6ZXIucHJvdG90eXBlLmFwcGVuZFRvQXR0cmlidXRlVmFsdWUgPSBmdW5jdGlvbiAoY2hhcikge1xuICAgIHRoaXMuY3VycmVudEF0dHJpYnV0ZSgpWzFdICs9IGNoYXI7XG4gIH07XG4gIFRva2VuaXplci5wcm90b3R5cGUuZmluaXNoQXR0cmlidXRlVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jdXJyZW50KFwiU3RhcnRUYWdcIiAvKiBTdGFydFRhZyAqLykuYXR0cmlidXRlcy5wdXNoKHRoaXMuX2N1cnJlbnRBdHRyaWJ1dGUpO1xuICB9O1xuICBUb2tlbml6ZXIucHJvdG90eXBlLnJlcG9ydFN5bnRheEVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICB0aGlzLmN1cnJlbnQoKS5zeW50YXhFcnJvciA9IG1lc3NhZ2U7XG4gIH07XG4gIHJldHVybiBUb2tlbml6ZXI7XG59KCk7XG5mdW5jdGlvbiB0b2tlbml6ZShpbnB1dCwgb3B0aW9ucykge1xuICB2YXIgdG9rZW5pemVyID0gbmV3IFRva2VuaXplcihuZXcgRW50aXR5UGFyc2VyKEhUTUw1TmFtZWRDaGFyUmVmcyksIG9wdGlvbnMpO1xuICByZXR1cm4gdG9rZW5pemVyLnRva2VuaXplKGlucHV0KTtcbn1cblxuY29uc3QgTGlua2lmeVJlc3VsdCA9ICdMaW5raWZ5UmVzdWx0JztcbmNvbnN0IFN0YXJ0VGFnID0gJ1N0YXJ0VGFnJztcbmNvbnN0IEVuZFRhZyA9ICdFbmRUYWcnO1xuY29uc3QgQ2hhcnMgPSAnQ2hhcnMnO1xuY29uc3QgQ29tbWVudCA9ICdDb21tZW50JztcbmNvbnN0IERvY3R5cGUgPSAnRG9jdHlwZSc7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBodG1sIHN0cmluZyB0byBsaW5rXG4gKiBAcGFyYW0ge2ltcG9ydCgnbGlua2lmeWpzJykuT3B0c30gW29wdHNdIGxpbmtpZnkgb3B0aW9uc1xuICogQHJldHVybnMge3N0cmluZ30gcmVzdWx0aW5nIHN0cmluZ1xuICovXG5mdW5jdGlvbiBsaW5raWZ5SHRtbChzdHIsIG9wdHMpIHtcbiAgaWYgKG9wdHMgPT09IHZvaWQgMCkge1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuICAvLyBgdG9rZW5zYCBhbmQgYHRva2VuYCBpbiB0aGlzIHNlY3Rpb24gcmVmZXIgdG8gdG9rZW5zIGdlbmVyYXRlZCBieSB0aGVcbiAgLy8gSFRNTCBwYXJzZXIsIG5vdCBsaW5raWZ5J3MgcGFyc2VyXG4gIGNvbnN0IHRva2VucyA9IHRva2VuaXplKHN0cik7XG4gIGNvbnN0IGxpbmtpZmllZFRva2VucyA9IFtdO1xuICBjb25zdCBsaW5raWZpZWQgPSBbXTtcbiAgY29uc3Qgb3B0aW9ucyA9IG5ldyBPcHRpb25zKG9wdHMsIGRlZmF1bHRSZW5kZXIpO1xuXG4gIC8vIExpbmtpZnkgdGhlIHRva2VucyBnaXZlbiBieSB0aGUgcGFyc2VyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgaWYgKHRva2VuLnR5cGUgPT09IFN0YXJ0VGFnKSB7XG4gICAgICBsaW5raWZpZWRUb2tlbnMucHVzaCh0b2tlbik7XG5cbiAgICAgIC8vIElnbm9yZSBhbGwgdGhlIGNvbnRlbnRzIG9mIGlnbm9yZWQgdGFnc1xuICAgICAgY29uc3QgdGFnTmFtZSA9IHRva2VuLnRhZ05hbWUudG9VcHBlckNhc2UoKTtcbiAgICAgIGNvbnN0IGlzSWdub3JlZCA9IHRhZ05hbWUgPT09ICdBJyB8fCBvcHRpb25zLmlnbm9yZVRhZ3MuaW5kZXhPZih0YWdOYW1lKSA+PSAwO1xuICAgICAgaWYgKCFpc0lnbm9yZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBsZXQgcHJlc2tpcExlbiA9IGxpbmtpZmllZFRva2Vucy5sZW5ndGg7XG4gICAgICBza2lwVGFnVG9rZW5zKHRhZ05hbWUsIHRva2VucywgKytpLCBsaW5raWZpZWRUb2tlbnMpO1xuICAgICAgaSArPSBsaW5raWZpZWRUb2tlbnMubGVuZ3RoIC0gcHJlc2tpcExlbiAtIDE7XG4gICAgfSBlbHNlIGlmICh0b2tlbi50eXBlICE9PSBDaGFycykge1xuICAgICAgLy8gU2tpcCB0aGlzIHRva2VuLCBpdCdzIG5vdCBpbXBvcnRhbnRcbiAgICAgIGxpbmtpZmllZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVmFsaWQgdGV4dCB0b2tlbiwgbGlua2lmeSBpdCFcbiAgICAgIGNvbnN0IGxpbmtpZmVkQ2hhcnMgPSBsaW5raWZ5Q2hhcnModG9rZW4uY2hhcnMsIG9wdGlvbnMpO1xuICAgICAgbGlua2lmaWVkVG9rZW5zLnB1c2guYXBwbHkobGlua2lmaWVkVG9rZW5zLCBsaW5raWZlZENoYXJzKTtcbiAgICB9XG4gIH1cblxuICAvLyBDb252ZXJ0IHRoZSB0b2tlbnMgYmFjayBpbnRvIGEgc3RyaW5nXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGlua2lmaWVkVG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdG9rZW4gPSBsaW5raWZpZWRUb2tlbnNbaV07XG4gICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICBjYXNlIExpbmtpZnlSZXN1bHQ6XG4gICAgICAgIGxpbmtpZmllZC5wdXNoKHRva2VuLnJlbmRlcmVkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0YXJ0VGFnOlxuICAgICAgICB7XG4gICAgICAgICAgbGV0IGxpbmsgPSAnPCcgKyB0b2tlbi50YWdOYW1lO1xuICAgICAgICAgIGlmICh0b2tlbi5hdHRyaWJ1dGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxpbmsgKz0gJyAnICsgYXR0cmlidXRlQXJyYXlUb1N0cmluZ3ModG9rZW4uYXR0cmlidXRlcykuam9pbignICcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodG9rZW4uc2VsZkNsb3NpbmcpIHtcbiAgICAgICAgICAgIGxpbmsgKz0gJyAvJztcbiAgICAgICAgICB9XG4gICAgICAgICAgbGluayArPSAnPic7XG4gICAgICAgICAgbGlua2lmaWVkLnB1c2gobGluayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgRW5kVGFnOlxuICAgICAgICBsaW5raWZpZWQucHVzaChgPC8ke3Rva2VuLnRhZ05hbWV9PmApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ2hhcnM6XG4gICAgICAgIGxpbmtpZmllZC5wdXNoKGVzY2FwZVRleHQodG9rZW4uY2hhcnMpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENvbW1lbnQ6XG4gICAgICAgIGxpbmtpZmllZC5wdXNoKGA8IS0tJHtlc2NhcGVUZXh0KHRva2VuLmNoYXJzKX0tLT5gKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERvY3R5cGU6XG4gICAgICAgIHtcbiAgICAgICAgICBsZXQgZG9jdHlwZSA9IGA8IURPQ1RZUEUgJHt0b2tlbi5uYW1lfWA7XG4gICAgICAgICAgaWYgKHRva2VuLnB1YmxpY0lkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIGRvY3R5cGUgKz0gYCBQVUJMSUMgXCIke3Rva2VuLnB1YmxpY0lkZW50aWZpZXJ9XCJgO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodG9rZW4uc3lzdGVtSWRlbnRpZmllcikge1xuICAgICAgICAgICAgZG9jdHlwZSArPSBgIFwiJHt0b2tlbi5zeXN0ZW1JZGVudGlmaWVyfVwiYDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZG9jdHlwZSArPSAnPic7XG4gICAgICAgICAgbGlua2lmaWVkLnB1c2goZG9jdHlwZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxpbmtpZmllZC5qb2luKCcnKTtcbn1cblxuLyoqXG5cdGB0b2tlbnNgIGFuZCBgdG9rZW5gIGluIHRoaXMgc2VjdGlvbiByZWZlcmVzIHRvIHRva2VucyByZXR1cm5lZCBieVxuXHRgbGlua2lmeS50b2tlbml6ZWAuIGBsaW5raWZpZWRgIHdpbGwgY29udGFpbiBIVE1MIFBhcnNlci1zdHlsZSB0b2tlbnNcblx0QHBhcmFtIHtzdHJpbmd9XG5cdEBwYXJhbSB7aW1wb3J0KCdsaW5raWZ5anMnKS5PcHRpb25zfVxuKi9cbmZ1bmN0aW9uIGxpbmtpZnlDaGFycyhzdHIsIG9wdGlvbnMpIHtcbiAgY29uc3QgdG9rZW5zID0gdG9rZW5pemUkMShzdHIpO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICBpZiAodG9rZW4udCA9PT0gJ25sJyAmJiBvcHRpb25zLmdldCgnbmwyYnInKSkge1xuICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICB0eXBlOiBTdGFydFRhZyxcbiAgICAgICAgdGFnTmFtZTogJ2JyJyxcbiAgICAgICAgYXR0cmlidXRlczogW10sXG4gICAgICAgIHNlbGZDbG9zaW5nOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCF0b2tlbi5pc0xpbmsgfHwgIW9wdGlvbnMuY2hlY2sodG9rZW4pKSB7XG4gICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgIHR5cGU6IENoYXJzLFxuICAgICAgICBjaGFyczogdG9rZW4udG9TdHJpbmcoKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgdHlwZTogTGlua2lmeVJlc3VsdCxcbiAgICAgICAgcmVuZGVyZWQ6IG9wdGlvbnMucmVuZGVyKHRva2VuKVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuXHRSZXR1cm5zIGEgbGlzdCBvZiB0b2tlbnMgc2tpcHBlZCB1bnRpbCB0aGUgY2xvc2luZyB0YWcgb2YgdGFnTmFtZS5cblxuXHQqIGB0YWdOYW1lYCBpcyB0aGUgY2xvc2luZyB0YWcgd2hpY2ggd2lsbCBwcm9tcHQgdXMgdG8gc3RvcCBza2lwcGluZ1xuXHQqIGB0b2tlbnNgIGlzIHRoZSBhcnJheSBvZiB0b2tlbnMgZ2VuZXJhdGVkIGJ5IEhUTUw1VG9rZW5pemVyIHdoaWNoXG5cdCogYGlgIGlzIHRoZSBpbmRleCBpbW1lZGlhdGVseSBhZnRlciB0aGUgb3BlbmluZyB0YWcgdG8gc2tpcFxuXHQqIGBza2lwcGVkVG9rZW5zYCBpcyBhbiBhcnJheSB3aGljaCBza2lwcGVkIHRva2VucyBhcmUgYmVpbmcgcHVzaGVkIGludG9cblxuXHRDYXZlYXRzXG5cblx0KiBBc3N1bWVzIHRoYXQgaSBpcyB0aGUgZmlyc3QgdG9rZW4gYWZ0ZXIgdGhlIGdpdmVuIG9wZW5pbmcgdGFnTmFtZVxuXHQqIFRoZSBjbG9zaW5nIHRhZyB3aWxsIGJlIHNraXBwZWQsIGJ1dCBub3RoaW5nIGFmdGVyIGl0XG5cdCogV2lsbCB0cmFjayB3aGV0aGVyIHRoZXJlIGlzIGEgbmVzdGVkIHRhZyBvZiB0aGUgc2FtZSB0eXBlXG4qL1xuZnVuY3Rpb24gc2tpcFRhZ1Rva2Vucyh0YWdOYW1lLCB0b2tlbnMsIGksIHNraXBwZWRUb2tlbnMpIHtcbiAgLy8gbnVtYmVyIG9mIHRva2VucyBvZiB0aGlzIHR5cGUgb24gdGhlIFtmaWN0aW9uYWxdIHN0YWNrXG4gIGxldCBzdGFja0NvdW50ID0gMTtcbiAgd2hpbGUgKGkgPCB0b2tlbnMubGVuZ3RoICYmIHN0YWNrQ291bnQgPiAwKSB7XG4gICAgbGV0IHRva2VuID0gdG9rZW5zW2ldO1xuICAgIGlmICh0b2tlbi50eXBlID09PSBTdGFydFRhZyAmJiB0b2tlbi50YWdOYW1lLnRvVXBwZXJDYXNlKCkgPT09IHRhZ05hbWUpIHtcbiAgICAgIC8vIE5lc3RlZCB0YWcgb2YgdGhlIHNhbWUgdHlwZSwgXCJhZGQgdG8gc3RhY2tcIlxuICAgICAgc3RhY2tDb3VudCsrO1xuICAgIH0gZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gRW5kVGFnICYmIHRva2VuLnRhZ05hbWUudG9VcHBlckNhc2UoKSA9PT0gdGFnTmFtZSkge1xuICAgICAgLy8gQ2xvc2luZyB0YWdcbiAgICAgIHN0YWNrQ291bnQtLTtcbiAgICB9XG4gICAgc2tpcHBlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICBpKys7XG4gIH1cblxuICAvLyBOb3RlIHRoYXQgaWYgc3RhY2tDb3VudCA+IDAgaGVyZSwgdGhlIEhUTUwgaXMgcHJvYmFibHkgaW52YWxpZFxuICByZXR1cm4gc2tpcHBlZFRva2Vucztcbn1cbmZ1bmN0aW9uIGRlZmF1bHRSZW5kZXIoX3JlZikge1xuICBsZXQge1xuICAgIHRhZ05hbWUsXG4gICAgYXR0cmlidXRlcyxcbiAgICBjb250ZW50XG4gIH0gPSBfcmVmO1xuICByZXR1cm4gYDwke3RhZ05hbWV9ICR7YXR0cmlidXRlc1RvU3RyaW5nKGF0dHJpYnV0ZXMpfT4ke2VzY2FwZVRleHQoY29udGVudCl9PC8ke3RhZ05hbWV9PmA7XG59XG5mdW5jdGlvbiBlc2NhcGVUZXh0KHRleHQpIHtcbiAgcmV0dXJuIHRleHQucmVwbGFjZSgvJi9nLCAnJmFtcDsnKS5yZXBsYWNlKC88L2csICcmbHQ7JykucmVwbGFjZSgvPi9nLCAnJmd0OycpO1xufVxuZnVuY3Rpb24gZXNjYXBlQXR0cihhdHRyKSB7XG4gIHJldHVybiBhdHRyLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKTtcbn1cbmZ1bmN0aW9uIGF0dHJpYnV0ZXNUb1N0cmluZyhhdHRyaWJ1dGVzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmb3IgKGNvbnN0IGF0dHIgaW4gYXR0cmlidXRlcykge1xuICAgIGNvbnN0IHZhbCA9IGF0dHJpYnV0ZXNbYXR0cl0gKyAnJztcbiAgICByZXN1bHQucHVzaChgJHthdHRyfT1cIiR7ZXNjYXBlQXR0cih2YWwpfVwiYCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC5qb2luKCcgJyk7XG59XG5mdW5jdGlvbiBhdHRyaWJ1dGVBcnJheVRvU3RyaW5ncyhhdHRycykge1xuICBjb25zdCBhdHRyU3RycyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbmFtZSA9IGF0dHJzW2ldWzBdO1xuICAgIGNvbnN0IHZhbHVlID0gYXR0cnNbaV1bMV0gKyAnJztcbiAgICBhdHRyU3Rycy5wdXNoKGAke25hbWV9PVwiJHtlc2NhcGVBdHRyKHZhbHVlKX1cImApO1xuICB9XG4gIHJldHVybiBhdHRyU3Rycztcbn1cblxuZXhwb3J0IHsgbGlua2lmeUh0bWwgYXMgZGVmYXVsdCB9O1xuIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMveURBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///90\n")}}]);